<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="utf-8">
  
  <title>What the f*ck Python | WSC_ZOU_Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="What the f*ck Python 🐍 —— 一些Python的特性 ​														参考(https://github.com/leisurelicht/wtfpython-cn)  😎start your Journey： Strings can be tricky sometimes/微妙的字符串*  123456&amp;gt; &amp;gt;&amp;gt;&amp;gt; a = &quot;some">
<meta property="og:type" content="article">
<meta property="og:title" content="What the f*ck Python">
<meta property="og:url" content="http://WSCZou.com/2018/12/13/What-the-f-ck-Python/index.html">
<meta property="og:site_name" content="WSC_ZOU_Blog">
<meta property="og:description" content="What the f*ck Python 🐍 —— 一些Python的特性 ​														参考(https://github.com/leisurelicht/wtfpython-cn)  😎start your Journey： Strings can be tricky sometimes/微妙的字符串*  123456&amp;gt; &amp;gt;&amp;gt;&amp;gt; a = &quot;some">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://github.com/leisurelicht/wtfpython-cn/raw/master/images/string-intern/string_intern.png">
<meta property="og:image" content="https://github.com/leisurelicht/wtfpython-cn/raw/master/images/tic-tac-toe/after_row_initialized.png">
<meta property="og:image" content="https://github.com/leisurelicht/wtfpython-cn/raw/master/images/tic-tac-toe/after_board_initialized.png">
<meta property="og:updated_time" content="2019-02-25T12:07:47.722Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="What the f*ck Python">
<meta name="twitter:description" content="What the f*ck Python 🐍 —— 一些Python的特性 ​														参考(https://github.com/leisurelicht/wtfpython-cn)  😎start your Journey： Strings can be tricky sometimes/微妙的字符串*  123456&amp;gt; &amp;gt;&amp;gt;&amp;gt; a = &quot;some">
<meta name="twitter:image" content="https://github.com/leisurelicht/wtfpython-cn/raw/master/images/string-intern/string_intern.png">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/typing.css">
  <link rel="stylesheet" href="/css/donate.css">
  
</head>

  
    
      <body>
    
  
      <div id="container" class="container">
        <article id="post-What-the-f-ck-Python" class="article article-type-post" itemscope itemprop="blogPost">
  <header id="header" class="header">
  <nav class="mobile-nav">
    <h1 class="nickname">WSC_Zou</h1>
    <ul class="mobile-nav-menu">
      <label for="mobile-menu-toggle"><a>&#9776; Menu</a></label>
      <input type="checkbox" id="mobile-menu-toggle"/>
      <ul class="mobile-nav-link">
        
        <a href="/">Home</a>
        
        <a href="/archives">Archives</a>
        
        <a href="/about">About</a>
        
      </ul>
    </ul>
  </nav>
	
		<nav id="main-nav" class="main-nav nav-left">
	
	
	  <a class="main-nav-link" href="/">Home</a>
	
	  <a class="main-nav-link" href="/archives">Archives</a>
	
	  <a class="main-nav-link" href="/about">About</a>
	
  </nav>
</header>

  <hr/>
  <div class="article-inner">
    

    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      What the f*ck Python
    </h1>
  

      </header>
    
    <div class="article-entry typo" itemprop="articleBody">
      
        <h1>What the f*ck Python 🐍</h1>
<h2 id="一些python的特性">—— 一些Python的特性</h2>
<p>​														参考(<a href="https://github.com/leisurelicht/wtfpython-cn" target="_blank" rel="noopener">https://github.com/leisurelicht/wtfpython-cn</a>)</p>
<hr>
<p>😎start your Journey：</p>
<p>Strings can be tricky sometimes/微妙的字符串*</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt;&gt;&gt; a = <span class="string">"some_string"</span></span><br><span class="line">&gt; &gt;&gt;&gt; id(a)</span><br><span class="line">&gt; <span class="number">140420665652016</span></span><br><span class="line">&gt; &gt;&gt;&gt; id(<span class="string">"some"</span> + <span class="string">"_"</span> + <span class="string">"string"</span>) <span class="comment"># 注意两个的id值是相同的.</span></span><br><span class="line">&gt; <span class="number">140420665652016</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt;&gt;&gt; a = <span class="string">"wtf"</span></span><br><span class="line">&gt; &gt;&gt;&gt; b = <span class="string">"wtf"</span></span><br><span class="line">&gt; &gt;&gt;&gt; a <span class="keyword">is</span> b</span><br><span class="line">&gt; <span class="keyword">True</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; &gt;&gt;&gt; a = <span class="string">"wtf!"</span></span><br><span class="line">&gt; &gt;&gt;&gt; b = <span class="string">"wtf!"</span></span><br><span class="line">&gt; &gt;&gt;&gt; a <span class="keyword">is</span> b</span><br><span class="line">&gt; <span class="keyword">False</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; &gt;&gt;&gt; a, b = <span class="string">"wtf!"</span>, <span class="string">"wtf!"</span></span><br><span class="line">&gt; &gt;&gt;&gt; a <span class="keyword">is</span> b</span><br><span class="line">&gt; <span class="keyword">True</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt;&gt;&gt; <span class="string">'a'</span> * <span class="number">20</span> <span class="keyword">is</span> <span class="string">'aaaaaaaaaaaaaaaaaaaa'</span></span><br><span class="line">&gt; <span class="keyword">True</span></span><br><span class="line">&gt; &gt;&gt;&gt; <span class="string">'a'</span> * <span class="number">21</span> <span class="keyword">is</span> <span class="string">'aaaaaaaaaaaaaaaaaaaaa'</span></span><br><span class="line">&gt; <span class="keyword">False</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>💡<strong>提示</strong></p>
<ul>
<li>这些行为是由于 Cpython 在编译优化时, 某些情况下会尝试使用已经存在的不可变对象而不是每次都创建一个新对象. (这种行为被称作字符串的驻留[string interning])</li>
<li>发生驻留之后, 许多变量可能指向内存中的相同字符串对象. (从而节省内存)</li>
<li>在上面的代码中, 字符串是隐式驻留的. 何时发生隐式驻留则取决于具体的实现. 这里有一些方法可以用来猜测字符串是否会被驻留:
<ul>
<li>所有长度为 0 和长度为 1 的字符串都被驻留.</li>
<li>字符串在编译时被实现 (<code>'wtf'</code> 将被驻留, 但是 <code>''.join(['w', 't', 'f']</code> 将不会被驻留)</li>
<li>字符串中只包含字母，数字或下划线时将会驻留. 所以 <code>'wtf!'</code> 由于包含 <code>!</code> 而未被驻留. 可以在<a href="https://github.com/python/cpython/blob/3.6/Objects/codeobject.c#L19" target="_blank" rel="noopener">这里</a>找到 CPython 对此规则的实现.</li>
<li><img src="https://github.com/leisurelicht/wtfpython-cn/raw/master/images/string-intern/string_intern.png" alt="img"></li>
<li>当在同一行将 <code>a</code> 和 <code>b</code> 的值设置为 <code>&quot;wtf!&quot;</code> 的时候, Python 解释器会创建一个新对象, 然后同时引用第二个变量. 如果你在不同的行上进行赋值操作, 它就不会“知道”已经有一个 <code>wtf！</code> 对象 (因为 <code>&quot;wtf!&quot;</code> 不是按照上面提到的方式被隐式驻留的). 它是一种编译器优化, 特别适用于交互式环境.</li>
<li>常量折叠(constant folding) 是 Python 中的一种 <a href="https://en.wikipedia.org/wiki/Peephole_optimization" target="_blank" rel="noopener">窥孔优化(peephole optimization)</a> 技术. 这意味着在编译时表达式 <code>'a'*20</code>会被替换为 <code>'aaaaaaaaaaaaaaaaaaaa'</code> 以减少运行时的时钟周期. 只有长度小于 20 的字符串才会发生常量折叠. (为啥? 想象一下由于表达式 <code>'a'*10**10</code> 而生成的 <code>.pyc</code> 文件的大小). 相关的源码实现在<a href="https://github.com/python/cpython/blob/3.6/Python/peephole.c#L288" target="_blank" rel="noopener">这里</a>.</li>
</ul>
</li>
</ul>
</blockquote>
<hr>
<p>**&gt;Time for some hash brownies!/是时候来点蛋糕了!​ **</p>
<blockquote>
<ul>
<li>hash brownie指一种含有大麻成分的蛋糕, 所以这里是句双关</li>
</ul>
<ol>
<li></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; some_dict = &#123;&#125;</span><br><span class="line">&gt; some_dict[<span class="number">5.5</span>] = <span class="string">"Ruby"</span></span><br><span class="line">&gt; some_dict[<span class="number">5.0</span>] = <span class="string">"JavaScript"</span></span><br><span class="line">&gt; some_dict[<span class="number">5</span>] = <span class="string">"Python"</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>Output:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt;&gt;&gt; some_dict[<span class="number">5.5</span>]</span><br><span class="line">&gt; <span class="string">"Ruby"</span></span><br><span class="line">&gt; &gt;&gt;&gt; some_dict[<span class="number">5.0</span>]</span><br><span class="line">&gt; <span class="string">"Python"</span></span><br><span class="line">&gt; &gt;&gt;&gt; some_dict[<span class="number">5</span>]</span><br><span class="line">&gt; <span class="string">"Python"</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<h4 id="💡-提示">💡 提示:</h4>
<ul>
<li>
<p>Python 字典通过检查键值是否相等和比较哈希值来确定两个键是否相同.</p>
</li>
<li>
<p>具有相同值的不可变对象在Python中始终具有相同的哈希值.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;   &gt;&gt;&gt; <span class="number">5</span> == <span class="number">5.0</span></span><br><span class="line">&gt;   <span class="keyword">True</span></span><br><span class="line">&gt;   &gt;&gt;&gt; hash(<span class="number">5</span>) == hash(<span class="number">5.0</span>)</span><br><span class="line">&gt;   <span class="keyword">True</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<blockquote>
<p>注意:</p>
<p>具有不同值的对象也可能具有相同的哈希值（哈希冲突）.</p>
<ul>
<li>
<p>当执行 <code>some_dict[5] = &quot;Python&quot;</code> 语句时, 因为Python将 <code>5</code> 和 <code>5.0</code> 识别为 <code>some_dict</code> 的同一个键, 所以已有值 “JavaScript” 就被 “Python” 覆盖了.</p>
</li>
<li>
<p>这个 StackOverflow的 <a href="https://stackoverflow.com/a/32211042/4354153" target="_blank" rel="noopener">回答</a> 漂亮的解释了这背后的基本原理.</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>Return return everywhere!/到处返回!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">def</span> <span class="title">some_func</span><span class="params">()</span>:</span></span><br><span class="line">&gt; 	<span class="keyword">try</span>:</span><br><span class="line">&gt; 		<span class="keyword">return</span> <span class="string">'from_try'</span></span><br><span class="line">&gt; 	<span class="keyword">finally</span>:</span><br><span class="line">&gt; 		<span class="keyword">return</span> <span class="string">'from_finally'</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>Output:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt;&gt;&gt;some_func()</span><br><span class="line">&gt; <span class="string">'from_finally'</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<h4 id="💡-说明">💡 说明:</h4>
<ul>
<li>当在 “try…finally” 语句的 <code>try</code> 中执行 <code>return</code>, <code>break</code> 或 <code>continue</code> 后, <code>finally</code> 子句依然会执行.</li>
<li>函数的返回值由最后执行的 <code>return</code> 语句决定. 由于 <code>finally</code> 子句一定会执行, 所以 <code>finally</code> 子句中的 <code>return</code> 将始终是最后执行的语句.</li>
</ul>
</blockquote>
<hr>
<p><strong>&gt;Deep down, we’re all the same./本质上，我们都一样.</strong></p>
<blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">WTF</span>:</span></span><br><span class="line">&gt; 	<span class="keyword">pass</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>Output:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt;&gt;&gt; WTF() == WTF() <span class="comment"># 两个不同的对象应该不相等</span></span><br><span class="line">&gt; <span class="keyword">False</span></span><br><span class="line">&gt; &gt;&gt;&gt; WTF() <span class="keyword">is</span> WTF() <span class="comment"># 也不相同</span></span><br><span class="line">&gt; <span class="keyword">False</span></span><br><span class="line">&gt; &gt;&gt;&gt; hash(WTF()) == hash(WTF()) <span class="comment"># 哈希值也应该不同</span></span><br><span class="line">&gt; <span class="keyword">True</span></span><br><span class="line">&gt; &gt;&gt;&gt; id(WTF()) == id(WTF())</span><br><span class="line">&gt; <span class="keyword">True</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<h4 id="💡-说明-v2">💡 说明:</h4>
<ul>
<li>
<p>当调用 <code>id</code> 函数时, Python 创建了一个 <code>WTF</code> 类的对象并传给 <code>id</code> 函数. 然后 <code>id</code> 函数获取其id值 (也就是内存地址), 然后丢弃该对象. 该对象就被销毁了.</p>
</li>
<li>
<p>当我们连续两次进行这个操作时, Python会将相同的内存地址分配给第二个对象. 因为 (在CPython中) <code>id</code> 函数使用对象的内存地址作为对象的id值, 所以两个对象的id值是相同的.</p>
</li>
<li>
<p>综上, 对象的id值仅仅在对象的生命周期内唯一. 在对象被销毁之后, 或被创建之前, 其他对象可以具有相同的id值.</p>
</li>
<li>
<p>那为什么 <code>is</code> 操作的结果为 <code>False</code> 呢? 让我们看看这段代码.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">WTF</span><span class="params">(object)</span>:</span></span><br><span class="line">&gt;     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span> print(<span class="string">"I"</span>)</span><br><span class="line">&gt;     <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span> print(<span class="string">"D"</span>)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<blockquote>
<p><strong>Output:</strong></p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;   &gt;&gt;&gt; WTF() <span class="keyword">is</span> WTF()</span><br><span class="line">&gt;   I</span><br><span class="line">&gt;   I</span><br><span class="line">&gt;   D</span><br><span class="line">&gt;   D</span><br><span class="line">&gt;   <span class="keyword">False</span></span><br><span class="line">&gt;   &gt;&gt;&gt; id(WTF()) == id(WTF())</span><br><span class="line">&gt;   I</span><br><span class="line">&gt;   D</span><br><span class="line">&gt;   I</span><br><span class="line">&gt;   D</span><br><span class="line">&gt;   <span class="keyword">True</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>正如你所看到的, 对象销毁的顺序是造成所有不同之处的原因.</p>
<p>如果看完还是云里雾里：请看 <a href="https://www.jb51.net/article/60360.htm" target="_blank" rel="noopener">https://www.jb51.net/article/60360.htm</a></p>
</blockquote>
<hr>
<h3 id="for-what-为什么">&gt; For what?/为什么?</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">some_string = <span class="string">"wtf"</span></span><br><span class="line">some_dict = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i, some_dict[i] <span class="keyword">in</span> enumerate(some_string):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_dict <span class="comment"># 创建了索引字典.</span></span><br><span class="line">&#123;<span class="number">0</span>: <span class="string">'w'</span>, <span class="number">1</span>: <span class="string">'t'</span>, <span class="number">2</span>: <span class="string">'f'</span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="💡-说明-v3">💡 说明:</h4>
<ul>
<li>
<p><a href="https://docs.python.org/3/reference/grammar.html" target="_blank" rel="noopener">Python 语法</a> （如果对英文文档吃力的化推荐看 <a href="https://docspy3zh.readthedocs.io/en/latest/reference/compound_stmts.html#for" target="_blank" rel="noopener">for语句</a>）中对 <code>for</code> 的定义是:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_stmt: <span class="string">'for'</span> exprlist <span class="string">'in'</span> testlist <span class="string">':'</span> suite [<span class="string">'else'</span> <span class="string">':'</span> suite]</span><br></pre></td></tr></table></figure>
<p>其中 <code>exprlist</code> 指分配目标. 这意味着对可迭代对象中的<strong>每一项都会执行</strong>类似 <code>{exprlist} = {next_value}</code> 的操作.</p>
<p>一个有趣的例子说明了这一点:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    print(i)</span><br><span class="line">    i = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>你可曾觉得这个循环只会运行一次?</p>
<p><strong>💡 说明:</strong></p>
<ul>
<li>由于循环在Python中工作方式, 赋值语句 <code>i = 10</code> 并不会影响迭代循环, 在每次迭代开始之前, 迭代器(这里指 <code>range(4)</code>) 生成的下一个元素就被解包并赋值给目标列表的变量(这里指 <code>i</code>)了.</li>
</ul>
</li>
<li>
<p>在每一次的迭代中, <code>enumerate(some_string)</code> 函数就生成一个新值 <code>i</code> (计数器增加) 并从 <code>some_string</code> 中获取一个字符. 然后将字典 <code>some_dict</code> 键 <code>i</code> (刚刚分配的) 的值设为该字符. 本例中循环的展开可以简化为:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>i, some_dict[i] = (<span class="number">0</span>, <span class="string">'w'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i, some_dict[i] = (<span class="number">1</span>, <span class="string">'t'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i, some_dict[i] = (<span class="number">2</span>, <span class="string">'f'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_dict</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="evaluation-time-discrepancy-执行时机差异">&gt; Evaluation time discrepancy/执行时机差异</h3>
<ol>
<li></li>
</ol>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array = [<span class="number">1</span>, <span class="number">8</span>, <span class="number">15</span>]</span><br><span class="line">g = (x <span class="keyword">for</span> x <span class="keyword">in</span> array <span class="keyword">if</span> array.count(x) &gt; <span class="number">0</span>)</span><br><span class="line">array = [<span class="number">2</span>, <span class="number">8</span>, <span class="number">22</span>]</span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong></p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(g))</span><br><span class="line">[<span class="number">8</span>]</span><br></pre></td></tr></table></figure>
<ol start="2">
<li></li>
</ol>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">array_1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">g1 = (x <span class="keyword">for</span> x <span class="keyword">in</span> array_1)</span><br><span class="line">array_1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">array_2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">g2 = (x <span class="keyword">for</span> x <span class="keyword">in</span> array_2)</span><br><span class="line">array_2[:] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong></p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(g1))</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(g2))</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<h4 id="💡-说明-v4">💡 说明</h4>
<ul>
<li>
<p>在<a href="https://wiki.python.org/moin/Generators" target="_blank" rel="noopener">生成器</a>表达式中, <code>in</code> 子句在声明时执行, 而条件子句则是在运行时执行.</p>
<p>对上面一句的解释：</p>
<p>​	在第一个例子中，<code>x for x in array</code>写出来的时候就执行了，而后面的 <code>if array.count(x) &gt; 0</code> 则是在 <code>array = [2, 8, 22]</code> 写完后 执行整个代码块时执行.</p>
</li>
<li>
<p>所以在运行前, <code>array</code> 已经被重新赋值为 <code>[2, 8, 22]</code>, 因此对于之前的 <code>1</code>, <code>8</code> 和 <code>15</code>, 只有 <code>count(8)</code> 的结果是大于 <code>0</code> 的, 所以生成器只会生成 <code>8</code>.</p>
</li>
<li>
<p>第二部分中 <code>g1</code> 和 <code>g2</code> 的输出差异则是由于变量 <code>array_1</code> 和 <code>array_2</code> 被重新赋值的方式导致的.</p>
</li>
<li>
<p>在第一种情况下, <code>array_1</code> 被绑定到新对象 <code>[1,2,3,4,5]</code>, 因为 <code>in</code> 子句是在声明时被执行的， 所以它仍然引用旧对象 <code>[1,2,3,4]</code>(并没有被销毁).</p>
</li>
<li>
<p>在第二种情况下, 对 <code>array_2</code> 的切片赋值将相同的旧对象 <code>[1,2,3,4]</code> 原地更新为 <code>[1,2,3,4,5]</code>. 因此 <code>g2</code> 和 <code>array_2</code> 仍然引用同一个对象(这个对象现在已经更新为 <code>[1,2,3,4,5]</code>).</p>
<hr>
</li>
</ul>
<h3 id="is-is-not-what-it-is-出人意料的is">&gt;<code>is</code> is not what it is!/出人意料的<code>is</code>!</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">下面是一个在互联网上非常有名的例子.</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">257</span>; b = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 💡 说明:</span></span><br><span class="line"></span><br><span class="line">**<span class="keyword">is</span> 和 == 的区别**</span><br><span class="line"></span><br><span class="line">- `<span class="keyword">is</span>` 运算符检查两个运算对象是否引用自同一对象 (即, 它检查两个预算对象是否相同).</span><br><span class="line"></span><br><span class="line">- `==` 运算符比较两个运算对象的值是否相等.</span><br><span class="line"></span><br><span class="line">- 因此</span><br></pre></td></tr></table></figure>
<p>​</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```python</span><br><span class="line"><span class="keyword">is</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure>
<p>​</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代表引用相同,</span><br></pre></td></tr></table></figure>
<p>​</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```python</span><br><span class="line">==</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
<p>​</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">  代表值相等. 下面的例子可以很好的说明这点,</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  &gt;&gt;&gt; [] == []</span><br><span class="line">  <span class="keyword">True</span></span><br><span class="line">  &gt;&gt;&gt; [] <span class="keyword">is</span> [] <span class="comment"># 这两个空列表位于不同的内存地址.</span></span><br><span class="line">  <span class="keyword">False</span></span><br><span class="line">  ```</span><br><span class="line"></span><br><span class="line">**<span class="number">256</span> 是一个已经存在的对象, 而 <span class="number">257</span> 不是**</span><br><span class="line"></span><br><span class="line">当你启动Python 的时候, `<span class="number">-5</span>` 到 `<span class="number">256</span>` 的数值就已经被分配好了. 这些数字因为经常使用所以适合被提前准备好.</span><br><span class="line"></span><br><span class="line">引用自 &lt;https://docs.python.org/<span class="number">3</span>/c-api/long.html&gt;</span><br><span class="line"></span><br><span class="line">&gt; 当前的实现为<span class="number">-5</span>到<span class="number">256</span>之间的所有整数保留一个整数对象数组, 当你创建了一个该范围内的整数时, 你只需要返回现有对象的引用. 所以改变<span class="number">1</span>的值是有可能的. 我怀疑这种行为在Python中是未定义行为. :-)</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(<span class="number">256</span>)</span><br><span class="line"><span class="number">10922528</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">10922528</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="number">10922528</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(<span class="number">257</span>)</span><br><span class="line"><span class="number">140084850247312</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(x)</span><br><span class="line"><span class="number">140084850247440</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(y)</span><br><span class="line"><span class="number">140084850247344</span></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">这里解释器并没有智能到能在执行 `y = <span class="number">257</span>` 时意识到我们已经创建了一个整数 `<span class="number">257</span>`, 所以它在内存中又新建了另一个对象.</span><br><span class="line"></span><br><span class="line">**当 a 和 b 在同一行中使用相同的值初始化时，会指向同一个对象.**</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b = <span class="number">257</span>, <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">140640774013296</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="number">140640774013296</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">140640774013392</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="number">140640774013488</span></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">- 当 a 和 b 在同一行中被设置为 `<span class="number">257</span>` 时, Python 解释器会创建一个新对象, 然后同时引用第二个变量. 如果你在不同的行上进行, 它就不会 <span class="string">"知道"</span> 已经存在一个 `<span class="number">257</span>` 对象了.</span><br><span class="line">- 这是一种特别为交互式环境做的编译器优化. 当你在实时解释器中输入两行的时候, 他们会单独编译, 因此也会单独进行优化. 如果你在 `.py` 文件中尝试这个例子, 则不会看到相同的行为, 因为文件是一次性编译的.</span><br></pre></td></tr></table></figure>
<h3 id="a-tic-tac-toe-where-x-wins-in-the-first-attempt-一蹴即至">&gt; A tic-tac-toe where X wins in the first attempt!/一蹴即至!</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们先初始化一个变量row</span></span><br><span class="line">row = [<span class="string">""</span>]*<span class="number">3</span> <span class="comment">#row i['', '', '']</span></span><br><span class="line"><span class="comment"># 并创建一个变量board</span></span><br><span class="line">board = [row]*<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>board</span><br><span class="line">[[<span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>], [<span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>], [<span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board[<span class="number">0</span>]</span><br><span class="line">[<span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"><span class="string">''</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">"X"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board</span><br><span class="line">[[<span class="string">'X'</span>, <span class="string">''</span>, <span class="string">''</span>], [<span class="string">'X'</span>, <span class="string">''</span>, <span class="string">''</span>], [<span class="string">'X'</span>, <span class="string">''</span>, <span class="string">''</span>]]</span><br></pre></td></tr></table></figure>
<p>我们有没有赋值过3个 “X” 呢？</p>
<h4 id="💡-说明-v5">💡 说明:</h4>
<p>当我们初始化 <code>row</code> 变量时, 下面这张图展示了内存中的情况。</p>
<p><a href="https://github.com/leisurelicht/wtfpython-cn/blob/master/images/tic-tac-toe/after_row_initialized.png" target="_blank" rel="noopener"><img src="https://github.com/leisurelicht/wtfpython-cn/raw/master/images/tic-tac-toe/after_row_initialized.png" alt="image"></a></p>
<p>而当通过对 <code>row</code> 做乘法来初始化 <code>board</code> 时, 内存中的情况则如下图所示 (每个元素 <code>board[0]</code>, <code>board[1]</code> 和 <code>board[2]</code> 都和 <code>row</code> 一样引用了同一列表.)</p>
<p><a href="https://github.com/leisurelicht/wtfpython-cn/blob/master/images/tic-tac-toe/after_board_initialized.png" target="_blank" rel="noopener"><img src="https://github.com/leisurelicht/wtfpython-cn/raw/master/images/tic-tac-toe/after_board_initialized.png" alt="image"></a></p>
<p>我们可以通过不使用变量 <code>row</code> 生成 <code>board</code> 来避免这种情况. (<a href="https://github.com/satwikkansal/wtfpython/issues/68" target="_blank" rel="noopener">这个</a>issue提出了这个需求.)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>board = [[<span class="string">''</span>]*<span class="number">3</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">"X"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board</span><br><span class="line">[[<span class="string">'X'</span>, <span class="string">''</span>, <span class="string">''</span>], [<span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>], [<span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>]]</span><br></pre></td></tr></table></figure>
<h3 id="the-sticky-output-function-麻烦的输出">&gt; The sticky output function/麻烦的输出</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">funcs = []</span><br><span class="line">results = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">some_func</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    funcs.append(some_func)</span><br><span class="line">    results.append(some_func()) <span class="comment"># 注意这里函数被执行了</span></span><br><span class="line"></span><br><span class="line">funcs_results = [func() <span class="keyword">for</span> func <span class="keyword">in</span> funcs]</span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>results</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>funcs_results</span><br><span class="line">[<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<p>即使每次在迭代中将 <code>some_func</code> 加入 <code>funcs</code> 前的 <code>x</code> 值都不相同, 所有的函数还是都返回6.</p>
<p>// 再换个例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>powers_of_x = [<span class="keyword">lambda</span> x: x**i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[f(<span class="number">2</span>) <span class="keyword">for</span> f <span class="keyword">in</span> powers_of_x]</span><br><span class="line">[<span class="number">512</span>, <span class="number">512</span>, <span class="number">512</span>, <span class="number">512</span>, <span class="number">512</span>, <span class="number">512</span>, <span class="number">512</span>, <span class="number">512</span>, <span class="number">512</span>, <span class="number">512</span>]</span><br></pre></td></tr></table></figure>
<h4 id="💡-说明-v6">💡 说明:</h4>
<ul>
<li>
<p>当在循环内部定义一个函数时, 如果该函数在其主体中使用了循环变量, 则闭包函数将与循环变量绑定, 而不是它的值. 因此, 所有的函数都是使用最后分配给变量的值来进行计算的.</p>
</li>
<li>
<p>Python调用函数加括号和不加括号的区别：</p>
<p>一、不带括号时，调用的是这个函数本身 ，是整个函数体，是一个函数对象，不须等该函数执行完成</p>
<p>二、带括号（参数或者无参），调用的是函数的执行结果，须等该函数执行完成的结果</p>
</li>
</ul>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span>  <span class="title">bracket</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 不带括号调用的结果：&lt;function bracket at 0x0000000004DD0B38&gt;,a是整个函数体，是一个函数对象，不须等该函数执行完成</span></span><br><span class="line">    a = bracket</span><br><span class="line">    <span class="keyword">print</span> (a)</span><br><span class="line">    <span class="comment"># 带括号调用的结果：6 ,b是函数执行后返回的值6,须等该函数执行完成的结果</span></span><br><span class="line">    b = bracket(<span class="number">6</span>)</span><br><span class="line">    <span class="keyword">print</span> (b)</span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong></p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;function bracket at <span class="number">0x0000016B43B4C7B8</span>&gt;</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>可以通过将循环变量作为命名变量传递给函数来获得预期的结果. <strong>为什么这样可行?</strong> 因为这会在函数内再次定义一个局部变量.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">funcs = []s</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">some_func</span><span class="params">(x=x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    funcs.append(some_func)</span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>funcs_results = [func() <span class="keyword">for</span> func <span class="keyword">in</span> funcs]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>funcs_results</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="is-not-is-not-is-not-is-not-不是-is-not">&gt; <code>is not ...</code> is not <code>is (not ...)</code>/<code>is not ...</code> 不是 <code>is (not ...)</code></h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'something'</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'something'</span> <span class="keyword">is</span> (<span class="keyword">not</span> <span class="keyword">None</span>)</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h4 id="💡-说明-v7">💡 说明:</h4>
<ul>
<li><code>is not</code> 是个单独的二元运算符, 与分别使用 <code>is</code> 和 <code>not</code> 不同.</li>
<li>如果操作符两侧的变量指向同一个对象, 则 <code>is not</code> 的结果为 <code>False</code>, 否则结果为 <code>True</code>.</li>
</ul>
<h3 id="backslashes-at-the-end-of-string-字符串末尾的反斜杠">&gt; Backslashes at the end of string/字符串末尾的反斜杠</h3>
<p><strong>Output:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"\\ C:\\"</span>)</span><br><span class="line">\ C:\</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">r"\ C:"</span>)</span><br><span class="line">\ C:</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">r"\ C:\")</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    File "</span>&lt;stdin&gt;<span class="string">", line 1</span></span><br><span class="line"><span class="string">      print(r"</span>\ C:\<span class="string">")</span></span><br><span class="line"><span class="string">                     ^</span></span><br><span class="line"><span class="string">SyntaxError: EOL while scanning string literal</span></span><br></pre></td></tr></table></figure>
<h4 id="💡-说明-v8">💡 说明:</h4>
<ul>
<li>
<p>在以r开头的原始字符串中, 反斜杠并没有特殊含义.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(repr(<span class="string">r"wt\"f"</span>))</span><br><span class="line"><span class="string">'wt\\"f'</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>解释器所做的只是简单的改变了反斜杠的行为, 因此会直接放行反斜杠及后一个的字符. 这就是反斜杠在原始字符串末尾不起作用的原因.</p>
</li>
<li>
<p>字符串的末尾，即使是原始（raw）字符串末尾也不能带奇数个反斜杠，因为这会引起后续引号的转义：比如r’C:\Windows’这个字符串常量，后一个反斜杠会告诉解析器后面的单引号不是字符串的结尾，字符串由两个引号包围，少了一个引号结束字符串，所以出现&quot;SyntaxError: EOL while scanning single-quoted string &quot;这个错误</p>
</li>
<li>
<p>r’C:\Windows’new’不会出错，很多人理解的原始字符串会保留字符本来的意义，所以会认为字符串中r’C:\Windows’已经是一个合法的字符串了，后面还跟着new’使得字符串不合法，其实这个字符串中r’C:\Windows’不合法，应为后面的反斜杠告诉解析器&quot;我后面的引号的意义已经被我转义了，在这里不是字符串的结尾，你可以继续进行解析&quot;。</p>
</li>
</ul>
<h3 id="not-knot-别纠结">&gt; not knot!/别纠结!</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="keyword">True</span></span><br><span class="line">y = <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">not</span> x == y</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x == <span class="keyword">not</span> y</span><br><span class="line">  File <span class="string">"&lt;input&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    x == <span class="keyword">not</span> y</span><br><span class="line">           ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>
<h4 id="💡-说明-v9">💡 说明:</h4>
<ul>
<li>运算符的优先级会影响表达式的求值顺序, 而在 Python 中 <code>==</code> 运算符的优先级要高于 <code>not</code> 运算符.</li>
<li>所以 <code>not x == y</code> 相当于 <code>not (x == y)</code>, 同时等价于 <code>not (True == False)</code>, 最后的运算结果就是 <code>True</code>.</li>
<li>之所以 <code>x == not y</code> 会抛一个 <code>SyntaxError</code> 异常, 是因为它会被认为等价于 <code>(x == not) y</code>, 而不是你一开始期望的 <code>x == (not y)</code>.</li>
<li>解释器期望 <code>not</code> 标记是 <code>not in</code> 操作符的一部分 (因为 <code>==</code> 和 <code>not in</code> 操作符具有相同的优先级), 但是它在 <code>not</code> 标记后面找不到 <code>in</code> 标记, 所以会抛出 <code>SyntaxError</code> 异常.</li>
</ul>
<h3 id="half-triple-quoted-strings-三个引号">&gt; Half triple-quoted strings/三个引号</h3>
<p><strong>Output:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'wtfpython'</span><span class="string">''</span>)</span><br><span class="line">wtfpython</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"wtfpython"</span><span class="string">""</span>)</span><br><span class="line">wtfpython</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 下面的语句会抛出 `SyntaxError` 异常</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># print('''wtfpython')</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># print("""wtfpython")</span></span><br></pre></td></tr></table></figure>
<h4 id="💡-说明-v10">💡 说明:</h4>
<ul>
<li>
<p>Python 提供隐式的</p>
<p>字符串链接</p>
<p>, 例如,</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"wtf"</span> <span class="string">"python"</span>)</span><br><span class="line">wtfpython</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"wtf"</span> <span class="string">""</span>) <span class="comment"># or "wtf"""</span></span><br><span class="line">wtf</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>'''</code> 和 <code>&quot;&quot;&quot;</code> 在 Python中也是字符串定界符, Python 解释器在先遇到三个引号的的时候会尝试再寻找三个终止引号作为定界符, 如果不存在则会导致 <code>SyntaxError</code> 异常.</p>
<h3 id="midnight-time-doesn-t-exist-不存在的午夜">&gt; Midnight time doesn’t exist?/不存在的午夜?</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">midnight = datetime(<span class="number">2018</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">midnight_time = midnight.time()</span><br><span class="line"></span><br><span class="line">noon = datetime(<span class="number">2018</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">12</span>, <span class="number">0</span>)</span><br><span class="line">noon_time = noon.time()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> midnight_time:</span><br><span class="line">    print(<span class="string">"Time at midnight is"</span>, midnight_time)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> noon_time:</span><br><span class="line">    print(<span class="string">"Time at noon is"</span>, noon_time)</span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">'Time at noon is'</span>, datetime.time(<span class="number">12</span>, <span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p>midnight_time 并没有被输出.</p>
<h4 id="💡-说明-v11">💡 说明:</h4>
<p>在Python 3.5之前, 如果 <code>datetime.time</code> 对象存储的UTC的午夜时间(译: 就是 <code>00:00</code>), 那么它的布尔值会被认为是 <code>False</code>. 当使用 <code>if obj:</code> 语句来检查 <code>obj</code> 是否为 <code>null</code> 或者某些“空”值的时候, 很容易出错.</p>
</li>
</ul>
<h3 id="what-s-wrong-with-booleans-布尔你咋了">&gt; What’s wrong with booleans?/布尔你咋了?</h3>
<ol>
<li></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个简单的例子, 统计下面可迭代对象中的布尔型值的个数和整型值的个数</span></span><br><span class="line">mixed_list = [<span class="keyword">False</span>, <span class="number">1.0</span>, <span class="string">"some_string"</span>, <span class="number">3</span>, <span class="keyword">True</span>, [], <span class="keyword">False</span>]</span><br><span class="line">integers_found_so_far = <span class="number">0</span></span><br><span class="line">booleans_found_so_far = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> mixed_list:</span><br><span class="line">    <span class="keyword">if</span> isinstance(item, int):</span><br><span class="line">        integers_found_so_far += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> isinstance(item, bool):</span><br><span class="line">        booleans_found_so_far += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>integers_found_so_far</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>booleans_found_so_far</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">another_dict = &#123;&#125;</span><br><span class="line">another_dict[<span class="keyword">True</span>] = <span class="string">"JavaScript"</span></span><br><span class="line">another_dict[<span class="number">1</span>] = <span class="string">"Ruby"</span></span><br><span class="line">another_dict[<span class="number">1.0</span>] = <span class="string">"Python"</span></span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>another_dict[<span class="keyword">True</span>]</span><br><span class="line"><span class="string">"Python"</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_bool = <span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"wtf"</span>*some_bool</span><br><span class="line"><span class="string">'wtf'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_bool = <span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"wtf"</span>*some_bool</span><br><span class="line"><span class="string">''</span></span><br></pre></td></tr></table></figure>
<h4 id="💡-说明-v12">💡 说明:</h4>
<ul>
<li>
<p>布尔值是 <code>int</code> 的子类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="keyword">True</span>, int)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="keyword">False</span>, int)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>所以 <code>True</code> 的整数值是 <code>1</code>, 而 <code>False</code> 的整数值是 <code>0</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">True</span> == <span class="number">1</span> == <span class="number">1.0</span> <span class="keyword">and</span> <span class="keyword">False</span> == <span class="number">0</span> == <span class="number">0.0</span></span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>关于其背后的原理, 请看这个 StackOverflow 的<a href="https://stackoverflow.com/a/8169049/4354153" target="_blank" rel="noopener">回答</a>.</p>
</li>
</ul>
<h3 id="class-attributes-and-instance-attributes-类属性和实例属性">&gt; Class attributes and instance attributes/类属性和实例属性</h3>
<ol>
<li></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>A.x, B.x, C.x</span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B.x = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A.x, B.x, C.x</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A.x = <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A.x, B.x, C.x</span><br><span class="line">(<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = A()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.x, A.x</span><br><span class="line">(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.x += <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.x, A.x</span><br><span class="line">(<span class="number">4</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    some_var = <span class="number">15</span></span><br><span class="line">    some_list = [<span class="number">5</span>]</span><br><span class="line">    another_list = [<span class="number">5</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.some_var = x + <span class="number">1</span></span><br><span class="line">        self.some_list = self.some_list + [x]</span><br><span class="line">        self.another_list += [x]</span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_obj = SomeClass(<span class="number">420</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_obj.some_list</span><br><span class="line">[<span class="number">5</span>, <span class="number">420</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_obj.another_list</span><br><span class="line">[<span class="number">5</span>, <span class="number">420</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>another_obj = SomeClass(<span class="number">111</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>another_obj.some_list</span><br><span class="line">[<span class="number">5</span>, <span class="number">111</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>another_obj.another_list</span><br><span class="line">[<span class="number">5</span>, <span class="number">420</span>, <span class="number">111</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>another_obj.another_list <span class="keyword">is</span> SomeClass.another_list</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>another_obj.another_list <span class="keyword">is</span> some_obj.another_list</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h4 id="💡-说明-v13">💡 说明:</h4>
<ul>
<li>类变量和实例变量在内部是通过类对象的字典来处理(译: 就是 <code>__dict__</code> 属性). 如果在当前类的字典中找不到的话就去它的父类中寻找.</li>
<li><code>+=</code> 运算符会在原地修改可变对象, 而不是创建新对象.(即会指向同一块地址) 因此, 修改一个实例的属性会影响其他实例和类属性.</li>
</ul>
<h3 id="yielding-none-生成-none">&gt; yielding None/生成 None</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">some_iterable = (<span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">some_func</span><span class="params">(val)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"something"</span></span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> some_iterable]</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(<span class="keyword">yield</span> x) <span class="keyword">for</span> x <span class="keyword">in</span> some_iterable]</span><br><span class="line">&lt;generator object &lt;listcomp&gt; at <span class="number">0x7f70b0a4ad58</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list([(<span class="keyword">yield</span> x) <span class="keyword">for</span> x <span class="keyword">in</span> some_iterable])</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list((<span class="keyword">yield</span> x) <span class="keyword">for</span> x <span class="keyword">in</span> some_iterable)</span><br><span class="line">[<span class="string">'a'</span>, <span class="keyword">None</span>, <span class="string">'b'</span>, <span class="keyword">None</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(some_func((<span class="keyword">yield</span> x)) <span class="keyword">for</span> x <span class="keyword">in</span> some_iterable)</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'something'</span>, <span class="string">'b'</span>, <span class="string">'something'</span>]</span><br></pre></td></tr></table></figure>
<h4 id="💡-说明-v14">💡 说明:</h4>
<ul>
<li>
<p>首先来看看在列表推导式中使用 yield 会发生什么：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(<span class="keyword">yield</span> x) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]] <span class="comment"># 在列表推导式中使用 yield&gt;&gt;&gt; &lt;generator object &lt;listcomp&gt; at 0x00C21510&gt;</span></span><br></pre></td></tr></table></figure>
<p>相当奇怪，返回一个 <strong><listcomp></listcomp></strong> 类型的生成器而不是一个包含生成器的列表</p>
<p>既然是生成器，那我们就用 <code>list()</code> 展开看一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list([(<span class="keyword">yield</span> x) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]])&gt;&gt;&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>虽然打印出了预期的结果，但还是感觉很奇怪：</p>
<p>列表推导式本身并不需要用 <code>list()</code> 展开的，这里却需要加上才行</p>
<p>那我们来看看如果是生成器表达式会如何：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="keyword">yield</span> x) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment"># 在生成器表达式中使用 yield&gt;&gt;&gt; &lt;generator object &lt;genexpr&gt; at 0x00C21C30&gt;</span></span><br></pre></td></tr></table></figure>
<p>嗯，的确是返回一个 <strong><genexpr></genexpr></strong> 类型的生成器，这很正常，那我们用 <code>list()</code> 展开看一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list((<span class="keyword">yield</span> x) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])&gt;&gt;&gt; [<span class="number">1</span>, <span class="keyword">None</span>, <span class="number">2</span>, <span class="keyword">None</span>, <span class="number">3</span>, <span class="keyword">None</span>]</span><br></pre></td></tr></table></figure>
<p>不含 yeild 的生成器表达式 (x for x in [1,2,3]) 相当于函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">genexpr</span><span class="params">(some_iterable)</span>:</span>    </span><br><span class="line">	<span class="keyword">for</span> x <span class="keyword">in</span> some_iterable:        </span><br><span class="line">		<span class="keyword">yield</span> x <span class="comment"># 外界传进来的值不用保存了，POP_TOP</span></span><br><span class="line">genexpr([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&lt;generator object genexpr at <span class="number">0x054EE420</span>&gt;</span><br><span class="line">list(genexpr([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>含 yeild 的生成器表达式 ((yield x) for x in [1,2,3]) 相当于函数 ：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
<p>正是 <code>(yield x)</code> 造成的，这使得内部函数有两个连续的 YIELD_VALUE</p>
<p>外界传进来的值（这里是None）来不及 POP_TOP 就被 YIELD_VALUE 传递出去了！</p>
<p>最终外界的 list 会拿到自己传进去的None</p>
</li>
<li>
<p>我们不应该在列表（集合、字典）推导式或生成器表达式中使用 yield，有时会带来意想不到的结果</p>
<p>这其实是 Python 本身的一个 Bug，见 <a href="https://bugs.python.org/issue10544" target="_blank" rel="noopener">https://bugs.python.org/issue10544</a></p>
</li>
</ul>
<h3 id="mutating-the-immutable-强人所难">&gt; Mutating the immutable!/强人所难</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">some_tuple = (<span class="string">"A"</span>, <span class="string">"tuple"</span>, <span class="string">"with"</span>, <span class="string">"values"</span>)</span><br><span class="line">another_tuple = ([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>])</span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_tuple[<span class="number">2</span>] = <span class="string">"change this"</span></span><br><span class="line">TypeError: <span class="string">'tuple'</span> object does <span class="keyword">not</span> support item assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>another_tuple[<span class="number">2</span>].append(<span class="number">1000</span>) <span class="comment"># 这里不出现错误</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>another_tuple</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">1000</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>another_tuple[<span class="number">2</span>] += [<span class="number">99</span>, <span class="number">999</span>]</span><br><span class="line">TypeError: <span class="string">'tuple'</span> object does <span class="keyword">not</span> support item assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>another_tuple</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">1000</span>, <span class="number">99</span>, <span class="number">999</span>])</span><br></pre></td></tr></table></figure>
<p>我还以为元组是不可变的呢…</p>
<h4 id="💡-说明-v15">💡 说明:</h4>
<ul>
<li>
<p>引用 <a href="https://docs.python.org/2/reference/datamodel.html" target="_blank" rel="noopener">https://docs.python.org/2/reference/datamodel.html</a></p>
<blockquote>
<p>不可变序列 不可变序列的对象一旦创建就不能再改变. (如果对象包含对其他对象的引用，则这些其他对象可能是可变的并且可能会被修改; 但是，由不可变对象直接引用的对象集合不能更改.)</p>
</blockquote>
</li>
<li>
<p><code>+=</code> 操作符在原地修改了列表. 元素赋值操作并不工作, 但是当异常抛出时, 元素已经在原地被修改了.</p>
</li>
</ul>
<p>(译: 对于不可变对象, 这里指tuple, <code>+=</code> 并不是原子操作, 而是 <code>extend</code> 和 <code>=</code> 两个动作, 这里 <code>=</code> 操作虽然会抛出异常, 但 <code>extend</code>操作已经修改成功了. 详细解释可以看<a href="https://segmentfault.com/a/1190000010767068" target="_blank" rel="noopener">这里</a>)</p>
<p>换句话说，<code>+=</code><strong>并不是原子操作</strong>，相当于下面的两步:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t[2].extend([50,60])</span><br><span class="line">t[2] = t[2]</span><br></pre></td></tr></table></figure>
<p>第一步可以正确执行，但是第二步有了<code>=</code>，肯定会抛异常的。 同样这也可以解释在使用<code>+=</code>的时候，为何<code>t[2]</code>的<code>id</code>明明没有变化，但是仍然抛出异常了。</p>
<h3 id="the-disappearing-variable-from-outer-scope-消失的外部变量">&gt; The disappearing variable from outer scope/消失的外部变量</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e = <span class="number">7</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p><strong>Output (Python 2.x):</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(e)</span><br><span class="line"><span class="comment"># prints nothing</span></span><br></pre></td></tr></table></figure>
<p><strong>Output (Python 3.x):</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(e)</span><br><span class="line">NameError: name <span class="string">'e'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure>
<h4 id="💡-说明-v16">💡 说明:</h4>
<ul>
<li>
<p>出处: <a href="https://docs.python.org/3/reference/compound_stmts.html#except" target="_blank" rel="noopener">https://docs.python.org/3/reference/compound_stmts.html#except</a></p>
<p>当使用 <code>as</code> 为目标分配异常的时候, 将在except子句的末尾清除该异常.</p>
<p>这就好像</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">except</span> E <span class="keyword">as</span> N:</span><br><span class="line">    foo</span><br></pre></td></tr></table></figure>
<p>会被翻译成</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">except</span> E <span class="keyword">as</span> N:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        foo</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">del</span> N</span><br></pre></td></tr></table></figure>
<p>这意味着异常必须在被赋值给其他变量才能在 <code>except</code> 子句之后引用它. 而异常之所以会被清除, 则是由于上面附加的回溯信息(trackback)会和栈帧(stack frame)形成循环引用, 使得该栈帧中的所有本地变量在下一次垃圾回收发生之前都处于活动状态.(译: 也就是说不会被回收)</p>
</li>
<li>
<p>子句在 Python 中并没有独立的作用域. 示例中的所有内容都处于同一作用域内, 所以变量 <code>e</code> 会由于执行了 <code>except</code> 子句而被删除. 而对于有独立的内部作用域的函数来说情况就不一样了. 下面的例子说明了这一点:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">del</span>(x)</span><br><span class="line">    print(x)</span><br><span class="line"></span><br><span class="line">x = <span class="number">5</span></span><br><span class="line">y = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;f(x)</span><br><span class="line">UnboundLocalError: local variable <span class="string">'x'</span> referenced before assignment</span><br><span class="line">&gt;&gt;&gt;f(y)</span><br><span class="line">UnboundLocalError: local variable <span class="string">'x'</span> referenced before assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line">[<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在 Python 2.x 中, <code>Exception()</code> 实例被赋值给了变量 <code>e</code>, 所以当你尝试打印结果的时候, 它的输出为空.（译: 正常的Exception实例打印出来就是空）</p>
<p><strong>Output (Python 2.x):</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>e</span><br><span class="line">Exception()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> e</span><br><span class="line"><span class="comment"># 没有打印任何内容!</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="when-true-is-actually-false-真亦假">&gt; When True is actually False/真亦假</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">True = False</span><br><span class="line">if True == False:</span><br><span class="line">    print(&quot;I&apos;ve lost faith in truth!&quot;)</span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I&apos;ve lost faith in truth!</span><br></pre></td></tr></table></figure>
<h4 id="💡-说明-v17">💡 说明:</h4>
<ul>
<li>最初, Python 并没有 <code>bool</code> 型 (人们用0表示假值, 用非零值比如1作为真值). 后来他们添加了 <code>True</code>, <code>False</code>, 和 <code>bool</code> 型, 但是, 为了向后兼容, 他们没法把 <code>True</code> 和 <code>False</code> 设置为常量, 只是设置成了内置变量.</li>
<li>Python 3 由于不再需要向后兼容, 终于可以修复这个问题了, 所以这个例子无法在 Python 3.x 中执行! Python 3 中会出现 <code>SyntaxError: can't assign to keyword</code> 错误</li>
</ul>
<h3 id="from-filled-to-none-in-one-instruction-从有到无">&gt; From filled to None in one instruction…/从有到无…</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">some_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">some_dict = &#123;</span><br><span class="line">  <span class="string">"key_1"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">"key_2"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="string">"key_3"</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">print(id(some_list),id(some_dict))</span><br><span class="line">print(some_list)</span><br><span class="line">print(some_dict)</span><br><span class="line"></span><br><span class="line">some_list1 = some_list.append(<span class="number">4</span>)</span><br><span class="line">some_dict1 = some_dict.update(&#123;<span class="string">"key_4"</span>: <span class="number">4</span>&#125;)</span><br><span class="line">print(id(some_list1),id(some_dict1))</span><br><span class="line">print(some_list1)</span><br><span class="line">print(some_dict1)</span><br><span class="line"></span><br><span class="line">print(some_list)</span><br><span class="line">print(some_dict)</span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">139974154577824</span>, <span class="number">139974154583408</span>)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#123;<span class="string">'key_1'</span>: <span class="number">1</span>, <span class="string">'key_3'</span>: <span class="number">3</span>, <span class="string">'key_2'</span>: <span class="number">2</span>&#125;</span><br><span class="line">(<span class="number">139974153481728</span>, <span class="number">139974153481728</span>)</span><br><span class="line"><span class="keyword">None</span></span><br><span class="line"><span class="keyword">None</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">&#123;<span class="string">'key_4'</span>: <span class="number">4</span>, <span class="string">'key_1'</span>: <span class="number">1</span>, <span class="string">'key_3'</span>: <span class="number">3</span>, <span class="string">'key_2'</span>: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="💡-说明-v18">💡 说明:</h4>
<p>大多数修改序列/映射对象的方法, 比如 <code>list.append</code>, <code>dict.update</code>, <code>list.sort</code> 等等. 都是原地修改对象并返回 <code>None</code>. 这样做的理由是, 如果操作可以原地完成, 就可以避免创建对象的副本来提高性能.</p>
<h3 id="subclass-relationships-子类关系">&gt; Subclass relationships/子类关系 *</h3>
<p><strong>Output:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Hashable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(list, object)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(object, Hashable)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(list, Hashable)</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<p>子类关系应该是可传递的, 对吧? (即, 如果 <code>A</code> 是 <code>B</code> 的子类, <code>B</code> 是 <code>C</code> 的子类, 那么 <code>A</code> <em>应该</em> 是 <code>C</code> 的子类.)</p>
<h4 id="💡-说明-v19">💡 说明:</h4>
<ul>
<li>Python 中的子类关系并不必须是传递的. 任何人都可以在元类中随意定义 <code>__subclasscheck__</code>.</li>
<li>当 <code>issubclass(cls, Hashable)</code> 被调用时, 它只是在 <code>cls</code> 中寻找 “<code>__hash__</code>” 方法或继承自&quot;<code>__hash__</code>&quot;的方法.</li>
<li>由于 <code>object</code> is 可散列的(hashable), 但是 <code>list</code> 是不可散列的, 所以它打破了这种传递关系.</li>
</ul>
<h3 id="the-mysterious-key-type-conversion-神秘的键型转换">&gt; The mysterious key type conversion/神秘的键型转换 *</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span><span class="params">(str)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">some_dict = &#123;<span class="string">'s'</span>:<span class="number">42</span>&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(list(some_dict.keys())[<span class="number">0</span>])</span><br><span class="line">str</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = SomeClass(<span class="string">'s'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_dict[s] = <span class="number">40</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_dict <span class="comment"># 预期: 两个不同的键值对</span></span><br><span class="line">&#123;<span class="string">'s'</span>: <span class="number">40</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(list(some_dict.keys())[<span class="number">0</span>])</span><br><span class="line">str</span><br></pre></td></tr></table></figure>
<h4 id="💡-说明-v20">💡 说明:</h4>
<ul>
<li>
<p>由于 <code>SomeClass</code> 会从 <code>str</code> 自动继承 <code>__hash__</code> 方法, 所以 <code>s</code> 对象和 <code>&quot;s&quot;</code> 字符串的哈希值是相同的.</p>
</li>
<li>
<p>而 <code>SomeClass(&quot;s&quot;) == &quot;s&quot;</code> 为 <code>True</code> 是因为 <code>SomeClass</code> 也继承了 <code>str</code> 类 <code>__eq__</code> 方法.</p>
</li>
<li>
<p>可哈希的集合（hashed collections），需要集合的元素实现了eq和hash，而这两个方法可以作一个形象的比喻：<br>
哈希集合就是很多个桶，但每个桶里面只能放一个球。 hash函数的作用就是找到桶的位置，到底是几号桶。 eq函数的作用就是当桶里面已经有一个球了，但又来了一个球，它声称它也应该装进这个桶里面（hash函数给它说了桶的位置），双方僵持不下，那就得用eq函数来判断这两个球是不是相等的（equal），如果是判断是相等的，那么后来那个球就不应该放进桶里，哈希集合维持现状.</p>
</li>
<li>
<p>由于两者的哈希值相同且相等, 所以它们在字典中表示相同的键.</p>
</li>
<li>
<p>如果想要实现期望的功能, 我们可以重定义 <code>SomeClass</code> 的 <code>__eq__</code> 方法.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span><span class="params">(str)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">          type(self) <span class="keyword">is</span> SomeClass</span><br><span class="line">          <span class="keyword">and</span> type(other) <span class="keyword">is</span> SomeClass</span><br><span class="line">          <span class="keyword">and</span> super().__eq__(other)</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 当我们自定义 __eq__ 方法时, Python 不会再自动继承 __hash__ 方法</span></span><br><span class="line">  <span class="comment"># 所以我们也需要定义它</span></span><br><span class="line">  __hash__ = str.__hash__</span><br><span class="line"></span><br><span class="line">some_dict = &#123;<span class="string">'s'</span>:<span class="number">42</span>&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = SomeClass(<span class="string">'s'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_dict[s] = <span class="number">40</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_dict</span><br><span class="line">&#123;<span class="string">'s'</span>: <span class="number">40</span>, <span class="string">'s'</span>: <span class="number">42</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>keys = list(some_dict.keys())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(keys[<span class="number">0</span>]), type(keys[<span class="number">1</span>])</span><br><span class="line">(__main__.SomeClass, str)</span><br></pre></td></tr></table></figure></li>
</ul>

      
      
    </div>
    <footer class="article-footer">
      <ul class="article-meta">
        <li>
          <span class="label">Published Date:</span>
          <a href="/2018/12/13/What-the-f-ck-Python/" class="article-date">
  <time datetime="2018-12-13T12:56:05.000Z" itemprop="datePublished">2018-12-13</time>
</a>

        </li>
        
        
        <hr/>
      </ul>
    </footer>
  </div>
  
    
<nav id="article-nav" class="article-nav">
  
    <a href="/2019/01/09/python-动态生成变量名以及动态获取变量的变量名/" id="article-nav-newer" class="article-nav-link-wrap newer">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          python--动态生成变量名以及动态获取变量的变量名
        
      </div>
    </a>
  
  
    <a href="/2018/09/08/数据挖掘/" id="article-nav-older" class="article-nav-link-wrap older">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">数据挖掘</div>
    </a>
  
</nav>


  
</article>










      </div>
      
    <footer id="footer" class="post-footer footer">
      
      <hr/>
      <div id="footerContent" class="footer-content">
        <p>writing…</p>


      </div>
    </footer>

      







<script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>


  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>


<script src="/js/typing.js"></script>
<!--[if lt IE 9]><script src="https://cdn.jsdelivr.net/npm/html5shiv@3/dist/html5shiv.min.js"></script><![endif]-->







    </div>
  </body>
</html>
