<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WSC_ZOU_Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://WSCZou.com/"/>
  <updated>2019-02-25T07:06:13.904Z</updated>
  <id>http://WSCZou.com/</id>
  
  <author>
    <name>WSC_ZOU</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>cnn</title>
    <link href="http://WSCZou.com/2019/01/16/cnn/"/>
    <id>http://WSCZou.com/2019/01/16/cnn/</id>
    <published>2019-01-16T03:18:29.000Z</published>
    <updated>2019-02-25T07:06:13.904Z</updated>
    
    <content type="html"><![CDATA[<p>前言：</p><p>在做识别 MNIST 中用了 CNN 所以看了CNN。</p><h3 id="一-cnn-卷积神经网络">一.CNN（卷积神经网络）</h3><p>来历：</p><p>视皮层中的许多神经元有一个小的局部感受野，这意味着它们只对位于视野中有限的一部分区域的视觉刺激起作用</p><p>用途：</p><p>可以进行大型图像处理</p><p>特点：</p><p>该优点在网络的输入是多维图像时表现的更为明显，使图像可以直接作为网络的输入，避免了传统识别算法中复杂的特征提取和数据重建过程，卷积网络是为识别二维形状而特殊设计的一个多层感知器，这种网络结构对平移、比例缩放、倾斜或者共他形式的变形具有高度不变性。</p><p><img src="https://github.com/WSCZou/Markdown-pic/blob/master/cnn/13-1.png?raw=true" alt="13-1.png"></p><p>如图，五个神经元的局部感受野由虚线圆圈表示。不同神经元的感受野可能重叠，并且它们一起平铺了整个视野。注意到一些神经元具有较大的感受野，并且它们对较复杂的模式作出反应，这些模式是较低层模式的组合。这些观察结果让我们想到：更高级别的神经元是基于相邻低级神经元的输出（在图 13-1 中，请注意，每个神经元只与来自前一层的少数神经元相连）。这个强大的结构能够检测视野中任何区域的各种复杂图案。</p><h3 id="二-卷积层和卷积核">二.卷积层和卷积核</h3><p><img src="https://github.com/WSCZou/Markdown-pic/blob/master/cnn/13-2.png?raw=true" alt="13-2.png"></p><p>CNN 最重要的组成部分是卷积层：第一卷积层中的神经元不是连接到输入图像中的每一个像素（就像它们在前面的章节中那样），而是仅仅连接到它们的局部感受野中的像素（参见图 13-2）。 进而，第二卷积层中的每个神经元只与位于第一层中的小矩形内的神经元连接。 <strong>这种架构允许网络专注于第一隐藏层中的低级特征，然后将其组装成下一隐藏层中的高级特征</strong>，等等。 这种层次结构在现实世界的图像中是很常见的，这也是 CNN 在图像识别方面效果很好的原因之一。</p><p>作用：</p><p>实现了图片特征提取方法</p><p>卷积到底干了什么？</p><p>对图像（不同的数据窗口数据）和滤波矩阵（一组固定的权重：因为每个神经元的多个权重固定，所以又可以看做一个恒定的滤波器filter）做<strong>内积</strong>（逐个元素相乘再求和）的操作就是所谓的『卷积』操作</p><p><code>fh</code>和<code>fw</code>是局部感受野的高度和宽度（见图 13-3）。 为了使图层具有与前一图层相同的高度和宽度，通常在输入周围添加零，如图所示。 这被称为零填充：通俗地讲就是为了总长能被步长整除。</p><p><img src="https://github.com/WSCZou/Markdown-pic/blob/master/cnn/13-3.png?raw=true" alt="13-3.png"></p><p>CNN卷积的计算方式：</p><p><img src="https://img-blog.csdn.net/20160707204048899" alt="img"></p><p>蓝色的矩阵和红色的矩阵相乘 再加上偏差值就是绿色的值，一一对应。</p><p><code>Filter w0</code>和 <code>Filter w2</code> 即为卷积核</p><p>可以看到上图中 <code>Filter w0</code>和<code>Filter w2</code>的权重是固定的，这个权重不变即所谓的<code>CNN</code>中的参数（权重） <strong>共享机制</strong></p><p>这个机制简化了输入层的值，可以减少隐含层的参数数据量。</p><h3 id="三-叠加的多个特征映射">三.叠加的多个特征映射</h3><p>什么是特征映射：</p><p><img src="https://github.com/WSCZou/Markdown-pic/blob/master/cnn/13-5.png?raw=true" alt="13-5.png"></p><p>特征映射就是 比如上图中一个过滤器表示为中间有一条垂直的白线的黑色正方形(除了中间一列外，这是一个充满 0 的<code>7×7</code>矩阵，除了中央垂直线是 1).则神经元都检测在图像的不同位置处的同一个特征（即匹配与垂直的白线）。将从输入层到隐藏层的这种映射称为特征映射。</p><p>下面我们将说到<code>channels</code> 这个概念</p><p><img src="https://github.com/WSCZou/Markdown-pic/blob/master/cnn/13-6.png?raw=true" alt="13-6.png"></p><p>我们现在只谈输入图片样本的 <code>channels</code> ：就是指图片的颜色</p><p>单色图片的input，是2D， Width x Height<br>彩色图片的input，是3D， Width x Height x Channels</p><p>上图中<code>input layer</code> <code>channels</code>就是3</p><p>再说说卷积核：</p><p>卷积核的个数大于<code>channels</code> 个数时 图像通常也会越来越深（即更多的特征映射）。但小于输入<code>channels</code> 个数时就变小了 (如 CNN卷积的计算方式 那个动态图)</p><h3 id="四-池化层">四. 池化层</h3><p>一旦你理解了卷积层是如何工作的，池化层很容易掌握。 他们的目标是对输入图像进行二次抽样（即收缩）以<strong>减少计算负担，内存使用量和参数数量（从而限制过度拟合的风险）</strong>。 减少输入图像的大小也使得神经网络容忍一点点的图像变换（位置不变）。</p><p>就像在卷积图层中一样，池化层中的每个神经元都连接到前一层中有限数量的神经元的输出，位于一个小的矩形感受野内。 您必须像以前一样定义其大小，跨度和填充类型。 但是，汇集的神经元没有权重; 它所做的只是使用聚合函数（如最大值或平均值）来聚合输入。 图 13-8 显示了最大池层，这是最常见的池化类型。 在这个例子中，我们使用一个2×2的核，步幅为 2，没有填充。 请注意，只有每个核中的最大输入值才会进入下一层。 其他输入被丢弃。</p><p><img src="https://github.com/WSCZou/Markdown-pic/blob/master/cnn/13-8.png?raw=true" alt="13-8.png"></p><p>这显然是一个非常具有破坏性的层：即使只有一个<code>2×2</code>的核和 2 的步幅，输出在两个方向上都会减小两倍（所以它的面积将减少四倍），一下减少了 75% 的输入值</p><p>池化层通常独立于每个输入通道工作，因此输出深度与输入深度相同。 接下来可以看到，在这种情况下，图像的空间维度（高度和宽度）保持不变，但是通道数目可以减少。</p><h3 id="五cnn架构">五<code>CNN</code>架构</h3><p><strong>1.LeNet-5</strong></p><p><img src="https://github.com/WSCZou/Markdown-pic/blob/master/cnn/t-13-1.png?raw=true" alt="t-13-1.png"></p><ul><li><p><code>Avg Pooing</code>(平均池化层)比平常稍微复杂一些：每个神经元计算输入的平均值，然后将结果乘以一个可学习的系数（每个特征映射一个），并添加一个可学习的偏差项（每个特征映射一个），然后最后应用激活函数。</p></li><li><p>输出层有点特殊：每个神经元不是计算输入和权向量的点积，而是输出其输入向量和其权向量之间的欧几里德距离的平方。每个输出测量图像属于特定数字类别的多少。 交叉熵损失函数现在是首选，因为它更多地惩罚不好的预测，产生更大的梯度，从而更快地收敛。</p></li></ul><p><strong>2.AlexNet</strong></p><p><img src="https://github.com/WSCZou/Markdown-pic/blob/master/cnn/t-13-2.png?raw=true" alt="t-13-2.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前言：&lt;/p&gt;
&lt;p&gt;在做识别 MNIST 中用了 CNN 所以看了CNN。&lt;/p&gt;
&lt;h3 id=&quot;一-cnn-卷积神经网络&quot;&gt;一.CNN（卷积神经网络）&lt;/h3&gt;
&lt;p&gt;来历：&lt;/p&gt;
&lt;p&gt;视皮层中的许多神经元有一个小的局部感受野，这意味着它们只对位于视野中有限的一部
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vultr搭建ssr</title>
    <link href="http://WSCZou.com/2019/01/14/vultr%E6%90%AD%E5%BB%BAssr/"/>
    <id>http://WSCZou.com/2019/01/14/vultr搭建ssr/</id>
    <published>2019-01-14T06:59:26.000Z</published>
    <updated>2019-01-14T06:59:26.320Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>吴恩达学习笔记-使用Keras实现MNIST数据集手写数字识别</title>
    <link href="http://WSCZou.com/2019/01/12/%E5%90%B4%E6%81%A9%E8%BE%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BD%BF%E7%94%A8Keras%E5%AE%9E%E7%8E%B0MNIST%E6%95%B0%E6%8D%AE%E9%9B%86%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/"/>
    <id>http://WSCZou.com/2019/01/12/吴恩达学习笔记-使用Keras实现MNIST数据集手写数字识别/</id>
    <published>2019-01-12T07:55:32.000Z</published>
    <updated>2019-01-20T07:05:15.480Z</updated>
    
    <content type="html"><![CDATA[<p>知识点:</p><h3 id="添加丢弃层">添加丢弃层</h3><p>丢弃是由 Hinton 及其在多伦多大学的学生开发的，是最有效且最常用的神经网络正则化技术之一。丢弃（应用于某个层）是指在训练期间随机“丢弃”（即设置为 0）该层的多个输出特征。假设某个指定的层通常会在训练期间针对给定的输入样本返回一个向量 [0.2, 0.5, 1.3, 0.8, 1.1]；在应用丢弃后，此向量将随机分布几个 0 条目，例如 [0, 0.5, 1.3, 0, 1.1]。“丢弃率”指变为 0 的特征所占的比例，通常设置在 0.2 和 0.5 之间。在测试时，网络不会丢弃任何单元，而是将层的输出值按等同于丢弃率的比例进行缩减，以便平衡以下事实：测试时的活跃单元数大于训练时的活跃单元数。</p><p>在 tf.keras 中，您可以通过丢弃层将丢弃引入网络中，以便事先将其应用于层的输出。</p><p>使用例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.add(Dropout(<span class="number">0.2</span>))</span><br></pre></td></tr></table></figure><h2 id="在编写模型时-keras-会要求您指定损失函数和优化程序-我们在这里使用的损失函数称为分类交叉熵-并且是一种非常适合比较两个概率分布的损失函数">在编写模型时，Keras 会要求您指定损失函数和优化程序。我们在这里使用的损失函数称为分类交叉熵，并且是一种非常适合比较两个概率分布的损失函数。</h2><h3 id="keras-中的多分类损失函数-categorical-crossentropy">Keras 中的多分类损失函数 categorical_crossentropy</h3><p>当使用 <em>categorical_crossentropy</em> 损失函数时，你的标签应为多类模式，例如如果你有10个类别，每一个样本的标签应该是一个10维的向量，该向量在对应有值的索引位置为1其余为0。</p><h3 id="keras中to-categorical函数-one-hot-encoding-独热编码">keras中to_categorical函数(one_hot encoding(独热编码))</h3><p>to_categorical 的功能：</p><p>简单来说，to_categorical就是将类别向量转换为二进制（只有0和1）的矩阵类型表示。其表现为将原有的类别向量转换为独热编码的形式。先上代码看一下效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.utils.np_utils <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#类别向量定义</span></span><br><span class="line">b = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line"><span class="comment">#调用to_categorical将b按照9个类别来进行转换</span></span><br><span class="line">b = to_categorical(b, <span class="number">9</span>)</span><br><span class="line">print(b)</span><br><span class="line"> </span><br><span class="line">执行结果如下：</span><br><span class="line">[[<span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span>]]</span><br></pre></td></tr></table></figure><p>to_categorical最为keras中提供的一个工具方法，从以上代码运行可以看出，将原来类别向量中的每个值都转换为矩阵里的一个行向量，从左到右依次是0,1,2，…8个类别。2表示为[0. 0. 1. 0. 0. 0. 0. 0. 0.]，只有第3个为1，作为有效位，其余全部为0。</p><p>现在我们来码代码:</p><h3 id="一-导入需要的库">一.导入需要的库</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.image <span class="keyword">as</span> mpimg</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="comment">#将那些用matplotlib绘制的图显示在页面里而不是弹出一个窗口</span></span><br><span class="line">%matplotlib inline   </span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> keras.utils.np_utils <span class="keyword">import</span> to_categorical <span class="comment"># 转换成 one-hot-encoding</span></span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, Dropout, Flatten, Conv2D, MaxPool2D</span><br><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> adam, RMSprop</span><br><span class="line"><span class="keyword">from</span> keras.preprocessing.image <span class="keyword">import</span> ImageDataGenerator</span><br><span class="line"><span class="keyword">from</span> keras.callbacks <span class="keyword">import</span> ReduceLROnPlateau</span><br></pre></td></tr></table></figure><h3 id="二-数据准备工作">二.数据准备工作</h3><p>1.导入数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(X_train, y_train), (X_test, y_test) = mnist.load_data()</span><br><span class="line">print(<span class="string">"X_train original shape"</span>, X_train.shape)</span><br><span class="line">print(<span class="string">"y_train original shape"</span>, y_train.shape)</span><br></pre></td></tr></table></figure><p>为什么reshape里面有四个参数？</p><p>因为是四维张量</p><p>shape是返回数组几行几列</p><p>reshape第一个参数是有多少行，-1是让计算机自己计算，模糊的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;知识点:&lt;/p&gt;
&lt;h3 id=&quot;添加丢弃层&quot;&gt;添加丢弃层&lt;/h3&gt;
&lt;p&gt;丢弃是由 Hinton 及其在多伦多大学的学生开发的，是最有效且最常用的神经网络正则化技术之一。丢弃（应用于某个层）是指在训练期间随机“丢弃”（即设置为 0）该层的多个输出特征。假设某个指定的层通常
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>吴恩达学习笔记-神经网络中的常用激活函数及其导数</title>
    <link href="http://WSCZou.com/2019/01/11/%E5%90%B4%E6%81%A9%E8%BE%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E5%AF%BC%E6%95%B0/"/>
    <id>http://WSCZou.com/2019/01/11/吴恩达学习笔记-神经网络中的常用激活函数及其导数/</id>
    <published>2019-01-11T08:46:06.000Z</published>
    <updated>2019-01-11T10:29:17.200Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言：</strong></p><p>激活函数的作用：</p><p>激活函数是非线性的，所以激活函数保证了神经网络的非线性。</p><p><strong>一.常用的几种激活函数：</strong></p><p>sigmoid函数，tanh函数，ReLU函数</p><p><strong>1.sigmoid函数</strong></p><p>在逻辑回归中我们介绍过sigmoid函数，该函数是将取值为 (−∞,+∞)(−∞,+∞) 的数映射到 (0,1)(0,1) 之间。sigmoid函数的公式以及图形如下：</p><p><img src="https://github.com/WSCZou/Markdown-pic/blob/master/sigmoid_4.jpg?raw=true" alt="sigmoid_4.jpg"></p><p><img src="https://github.com/WSCZou/Markdown-pic/blob/master/Ng_note/sigmoid_8.jpg?raw=true" alt="sigmoid_8.jpg"></p><p>对于sigmoid函数的<strong>求导推导</strong>为：</p><p><img src="https://github.com/WSCZou/Markdown-pic/blob/master/Ng_note/sigmoid_6.jpg?raw=true" alt="sigmoid_6.jpg"></p><p>sigmoid其实并不被经常使用，缺点如下：</p><p>（1）当 zz 值<strong>非常大</strong>或者<strong>非常小</strong>时，通过上图我们可以看到，sigmoid函数的<strong>导数</strong> g′(z)g′(z) 将接近 00 。这会导致权重 WW 的<strong>梯度</strong>将接近 00 ，使得<strong>梯度更新十分缓慢</strong>，即<strong>梯度消失</strong>。下面我们举例来说明一下，假设我们使用如下一个只有一层隐藏层的简单网络：</p><p><img src="https://github.com/WSCZou/Markdown-pic/blob/master/Ng_note/sigmoid_7.jpg?raw=true" alt="sigmoid_7.jpg"></p><p>对于隐藏层第一个节点进行计算，假设该点实际值为 a ，激活值为 a[1]。于是在这个节点处的代价函数为（以一个样本为例）：</p><p><img src="https://github.com/WSCZou/Markdown-pic/blob/master/sigmoid_1.jpg?raw=true" alt="sigmoid_1.jpg"></p><p>而激活值 a[1] 的计算过程为：</p><p><img src="https://github.com/WSCZou/Markdown-pic/blob/master/sigmoid_2.jpg?raw=true" alt="sigmoid_2.jpg"></p><p>于是对权重 w11 求梯度为：</p><p><img src="https://github.com/WSCZou/Markdown-pic/blob/master/sigmoid_3.jpg?raw=true" alt="sigmoid_3.jpg"></p><p>（2）<strong>函数的输出不是以0为均值</strong>，这就导致一个后果：若Sigmoid函数的输出全部为正数，那么传入下一层神经网络的值永远大于0，这时参数无论怎么更新梯度都为正</p><p><strong>2.tanh函数</strong></p><p>该函数是将取值为 (−∞,+∞)(−∞,+∞) 的数映射到 (−1,1)(−1,1) 之间，其公式与图形为：</p><p><img src="https://github.com/WSCZou/Markdown-pic/blob/master/tanh.jpg?raw=true" alt="tanh.jpg"></p><p><img src="https://github.com/WSCZou/Markdown-pic/blob/master/Ng_note/sigmoid_5.jpg?raw=true" alt="sigmoid_5.jpg"></p><p>tanh函数在 00 附近很短一段区域内可看做线性的。由于tanh函数<strong>均值</strong>为 0 ，因此弥补了sigmoid函数均值为 0.5的缺点。</p><p>对于tanh函数的<strong>求导推导</strong>为：</p><p><img src="https://github.com/WSCZou/Markdown-pic/blob/master/Ng_note/tanh_2.jpg?raw=true" alt="tanh_2.jpg"></p><p>tanh 函数的<strong>缺点</strong>：</p><p>同sigmoid函数的第一个缺点一样，当 z <strong>很大或很小</strong>时，g′(z)接近于 0，会导致梯度很小，权重更新非常缓慢，即<strong>梯度消失问题</strong>。</p><p><strong>3.ReLU函数</strong></p><p>其弥补了sigmoid函数以及tanh函数的<strong>梯度消失问题</strong>。ReLU函数的公式以及图形如下：</p><p><img src="https://github.com/WSCZou/Markdown-pic/blob/master/ReLU_1.jpg?raw=true" alt="ReLU_1.jpg"></p><p><img src="https://github.com/WSCZou/Markdown-pic/blob/master/Ng_note/tanh_3.jpg?raw=true" alt="tanh_3.jpg"></p><p>从ReLU的函数图像我们可以发现，函数原点左侧的部分，输出值为0，斜率为0；函数原点右侧是斜率为1的直线，且输出值就是输入值。相比于上述的Sigmoid和tanh两种激活函数，ReLU激活函数完美的解决了梯度消失的问题，因为它的线性的、非饱和的。此外，它的计算也更加简单，只需要设置一个特定的阈值就可以计算激活值，这样极大的提高了运算的速度。所以近年来，ReLU激活函数的应用越来越广泛。</p><p>ReLU函数  <strong>缺点</strong>：</p><p>训练的时候不适合大梯度的输入数据，因为在参数更新之后，ReLU的神经元不会再任何数据节点被激活，这就会导致梯度永远为0。比如：输入的数据小于0时，梯度就会为0，这就导致了负的梯度被置0，而且今后也可能不会被任何数据所激活，也就是说ReLU的神经元“坏死”了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;前言：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;激活函数的作用：&lt;/p&gt;
&lt;p&gt;激活函数是非线性的，所以激活函数保证了神经网络的非线性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一.常用的几种激活函数：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;sigmoid函数，tanh函数，ReL
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>吴恩达学习笔记-softmax函数</title>
    <link href="http://WSCZou.com/2019/01/11/%E5%90%B4%E6%81%A9%E8%BE%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-softmax%E5%87%BD%E6%95%B0/"/>
    <id>http://WSCZou.com/2019/01/11/吴恩达学习笔记-softmax函数/</id>
    <published>2019-01-11T08:31:58.000Z</published>
    <updated>2019-01-11T08:39:10.586Z</updated>
    
    <content type="html"><![CDATA[<p>前言：</p><p>因为要用 Keras 实现 MNIST 数据集手写数字识别，在学习的时候用到了 softmax 函数。所以就学习了它。</p><h2 id="一-softmax-函数作用"><strong>一. softmax 函数作用</strong></h2><p><strong>softmax用于多分类过程中</strong>，它将多个神经元的输出，映射到（0,1）区间内，可以看成概率来理解，从而来进行多分类！</p><p>假设我们有一个数组，V，Vi表示V中的第i个元素，那么这个元素的softmax值就是</p><p><img src="https://pic4.zhimg.com/80/v2-65035de6fdfd8b2f13b930191e9a548b_hd.jpg" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-11758fbc2fc5bbbc60106926625b3a4f_hd.jpg" alt="img"></p><p>softmax 直白来说就是将原来输出是3,1,-3通过 softmax 函数一作用，就映射成为(0,1)的值，而这些值的累和为1（满足概率的性质），那么我们就可以将它理解成概率，在最后选取输出结点的时候，我们就可以选取概率最大（也就是值对应最大的）结点，作为我们的预测目标！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前言：&lt;/p&gt;
&lt;p&gt;因为要用 Keras 实现 MNIST 数据集手写数字识别，在学习的时候用到了 softmax 函数。所以就学习了它。&lt;/p&gt;
&lt;h2 id=&quot;一-softmax-函数作用&quot;&gt;&lt;strong&gt;一. softmax 函数作用&lt;/strong&gt;&lt;/h2&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python--动态生成变量名以及动态获取变量的变量名</title>
    <link href="http://WSCZou.com/2019/01/09/python-%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E5%8F%98%E9%87%8F%E5%90%8D%E4%BB%A5%E5%8F%8A%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96%E5%8F%98%E9%87%8F%E7%9A%84%E5%8F%98%E9%87%8F%E5%90%8D/"/>
    <id>http://WSCZou.com/2019/01/09/python-动态生成变量名以及动态获取变量的变量名/</id>
    <published>2019-01-09T06:43:29.000Z</published>
    <updated>2019-01-09T07:18:14.097Z</updated>
    
    <content type="html"><![CDATA[<p>前言：</p><p>因为看了闭包函数将与循环变量绑定所以想到如何解除绑定，然后就找到了今天要说的这个问题</p><h2 id="python-动态生成变量名">python 动态生成变量名</h2><p>locals函数<br>代码之前，先介绍一个函数：<br>locals() 函数会以字典类型返回当前位置的全部局部变量。<br>菜鸟上的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="function"><span class="keyword">def</span> <span class="title">runoob</span><span class="params">(arg)</span>:</span>    <span class="comment"># 两个局部变量：arg、z</span></span><br><span class="line"><span class="meta">... </span>    z = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> (locals())</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>runoob(<span class="number">4</span>)</span><br><span class="line">&#123;<span class="string">'z'</span>: <span class="number">1</span>, <span class="string">'arg'</span>: <span class="number">4</span>&#125;      <span class="comment"># 返回一个名字/值对的字典</span></span><br></pre></td></tr></table></figure><p>下面来实现 目标：需求：<br>必须现在需要动态创建16个list，每个list的名字不一样，但是是有规律可循，比如第一个list的名字叫： arriage_list_0=[]，第二个叫arriage_list_1=[]………依次类推，但是我又不想手动的去写16个这样的名字，太累了，而且增加了代码的冗余性，灵活性也不强，所以有没有一种方法是能动态创建list名称的呢？答案是有的！而与之对应，既然要对上面的列表动态操作，肯定是少不了动态去解析list名称。所以下面开始介绍方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_list_pre</span><span class="params">()</span>:</span></span><br><span class="line">    prepare_list = locals()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">        prepare_list[<span class="string">'list_'</span> + str(i)] = []</span><br><span class="line">        prepare_list[<span class="string">'list_'</span> + str(i)].append((<span class="string">'我是第'</span> + str(i)) + <span class="string">'个list'</span>)</span><br><span class="line">    print(prepare_list[<span class="string">'list_0'</span>])</span><br><span class="line">    print(prepare_list[<span class="string">'list_1'</span>])</span><br><span class="line">    print(prepare_list[<span class="string">'list_2'</span>])</span><br><span class="line">    print(prepare_list[<span class="string">'list_3'</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    test_list_pre()</span><br></pre></td></tr></table></figure><p><strong>output:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'我是第0个list'</span>]</span><br><span class="line">[<span class="string">'我是第1个list'</span>]</span><br><span class="line">[<span class="string">'我是第2个list'</span>]</span><br><span class="line">[<span class="string">'我是第3个list'</span>]</span><br></pre></td></tr></table></figure><h2 id="python-动态获取变量的变量名">python 动态获取变量的变量名</h2><p>需求目标：如果有了上面的动态命名list，那么当动态获取变量的变量名，就需要如下的操作：<br>利用python原生的inspect库来实现：<br>核心代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_variable_name</span><span class="params">(variable)</span>:</span></span><br><span class="line">    callers_local_vars = inspect.currentframe().f_back.f_locals.items()</span><br><span class="line">    <span class="keyword">return</span> [var_name <span class="keyword">for</span> var_name, var_val <span class="keyword">in</span> callers_local_vars <span class="keyword">if</span> var_val <span class="keyword">is</span> variable]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_variable_name</span><span class="params">(variable)</span>:</span></span><br><span class="line">    callers_local_vars = inspect.currentframe().f_back.f_locals.items()</span><br><span class="line">    <span class="keyword">return</span> [var_name <span class="keyword">for</span> var_name, var_val <span class="keyword">in</span> callers_local_vars <span class="keyword">if</span> var_val <span class="keyword">is</span> variable]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    prepare_list = locals()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">        prepare_list[<span class="string">'list_'</span> + str(i)] = []</span><br><span class="line">        prepare_list[<span class="string">'list_'</span> + str(i)].append((<span class="string">'我是第'</span> + str(i)) + <span class="string">'个list'</span>)</span><br><span class="line">    a = get_variable_name(prepare_list[<span class="string">'list_0'</span>]).pop()</span><br><span class="line">    b = get_variable_name(prepare_list[<span class="string">'list_1'</span>]).pop()</span><br><span class="line">    print(a)</span><br><span class="line">    print(b)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list_0</span><br><span class="line">list_1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前言：&lt;/p&gt;
&lt;p&gt;因为看了闭包函数将与循环变量绑定所以想到如何解除绑定，然后就找到了今天要说的这个问题&lt;/p&gt;
&lt;h2 id=&quot;python-动态生成变量名&quot;&gt;python 动态生成变量名&lt;/h2&gt;
&lt;p&gt;locals函数&lt;br&gt;
代码之前，先介绍一个函数：&lt;br&gt;
l
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>What the f*ck Python</title>
    <link href="http://WSCZou.com/2018/12/13/What-the-f-ck-Python/"/>
    <id>http://WSCZou.com/2018/12/13/What-the-f-ck-Python/</id>
    <published>2018-12-13T12:56:05.000Z</published>
    <updated>2019-03-07T12:55:13.773Z</updated>
    
    <content type="html"><![CDATA[<h1>What the f*ck Python 🐍</h1><h2 id="一些python的特性">—— 一些Python的特性</h2><p>​参考(<a href="https://github.com/leisurelicht/wtfpython-cn" target="_blank" rel="noopener">https://github.com/leisurelicht/wtfpython-cn</a>)</p><hr><p>😎start your Journey：</p><p>Strings can be tricky sometimes/微妙的字符串*</p><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt;&gt;&gt; a = <span class="string">"some_string"</span></span><br><span class="line">&gt; &gt;&gt;&gt; id(a)</span><br><span class="line">&gt; <span class="number">140420665652016</span></span><br><span class="line">&gt; &gt;&gt;&gt; id(<span class="string">"some"</span> + <span class="string">"_"</span> + <span class="string">"string"</span>) <span class="comment"># 注意两个的id值是相同的.</span></span><br><span class="line">&gt; <span class="number">140420665652016</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt;&gt;&gt; a = <span class="string">"wtf"</span></span><br><span class="line">&gt; &gt;&gt;&gt; b = <span class="string">"wtf"</span></span><br><span class="line">&gt; &gt;&gt;&gt; a <span class="keyword">is</span> b</span><br><span class="line">&gt; <span class="keyword">True</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; &gt;&gt;&gt; a = <span class="string">"wtf!"</span></span><br><span class="line">&gt; &gt;&gt;&gt; b = <span class="string">"wtf!"</span></span><br><span class="line">&gt; &gt;&gt;&gt; a <span class="keyword">is</span> b</span><br><span class="line">&gt; <span class="keyword">False</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; &gt;&gt;&gt; a, b = <span class="string">"wtf!"</span>, <span class="string">"wtf!"</span></span><br><span class="line">&gt; &gt;&gt;&gt; a <span class="keyword">is</span> b</span><br><span class="line">&gt; <span class="keyword">True</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt;&gt;&gt; <span class="string">'a'</span> * <span class="number">20</span> <span class="keyword">is</span> <span class="string">'aaaaaaaaaaaaaaaaaaaa'</span></span><br><span class="line">&gt; <span class="keyword">True</span></span><br><span class="line">&gt; &gt;&gt;&gt; <span class="string">'a'</span> * <span class="number">21</span> <span class="keyword">is</span> <span class="string">'aaaaaaaaaaaaaaaaaaaaa'</span></span><br><span class="line">&gt; <span class="keyword">False</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>💡<strong>提示</strong></p><ul><li>这些行为是由于 Cpython 在编译优化时, 某些情况下会尝试使用已经存在的不可变对象而不是每次都创建一个新对象. (这种行为被称作字符串的驻留[string interning])</li><li>发生驻留之后, 许多变量可能指向内存中的相同字符串对象. (从而节省内存)</li><li>在上面的代码中, 字符串是隐式驻留的. 何时发生隐式驻留则取决于具体的实现. 这里有一些方法可以用来猜测字符串是否会被驻留:<ul><li>所有长度为 0 和长度为 1 的字符串都被驻留.</li><li>字符串在编译时被实现 (<code>'wtf'</code> 将被驻留, 但是 <code>''.join(['w', 't', 'f']</code> 将不会被驻留)</li><li>字符串中只包含字母，数字或下划线时将会驻留. 所以 <code>'wtf!'</code> 由于包含 <code>!</code> 而未被驻留. 可以在<a href="https://github.com/python/cpython/blob/3.6/Objects/codeobject.c#L19" target="_blank" rel="noopener">这里</a>找到 CPython 对此规则的实现.</li><li><img src="https://github.com/leisurelicht/wtfpython-cn/raw/master/images/string-intern/string_intern.png" alt="img"></li><li>当在同一行将 <code>a</code> 和 <code>b</code> 的值设置为 <code>&quot;wtf!&quot;</code> 的时候, Python 解释器会创建一个新对象, 然后同时引用第二个变量. 如果你在不同的行上进行赋值操作, 它就不会“知道”已经有一个 <code>wtf！</code> 对象 (因为 <code>&quot;wtf!&quot;</code> 不是按照上面提到的方式被隐式驻留的). 它是一种编译器优化, 特别适用于交互式环境.</li><li>常量折叠(constant folding) 是 Python 中的一种 <a href="https://en.wikipedia.org/wiki/Peephole_optimization" target="_blank" rel="noopener">窥孔优化(peephole optimization)</a> 技术. 这意味着在编译时表达式 <code>'a'*20</code>会被替换为 <code>'aaaaaaaaaaaaaaaaaaaa'</code> 以减少运行时的时钟周期. 只有长度小于 20 的字符串才会发生常量折叠. (为啥? 想象一下由于表达式 <code>'a'*10**10</code> 而生成的 <code>.pyc</code> 文件的大小). 相关的源码实现在<a href="https://github.com/python/cpython/blob/3.6/Python/peephole.c#L288" target="_blank" rel="noopener">这里</a>.</li></ul></li></ul></blockquote><hr><p>**&gt;Time for some hash brownies!/是时候来点蛋糕了!​ **</p><blockquote><ul><li>hash brownie指一种含有大麻成分的蛋糕, 所以这里是句双关</li></ul><ol><li></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; some_dict = &#123;&#125;</span><br><span class="line">&gt; some_dict[<span class="number">5.5</span>] = <span class="string">"Ruby"</span></span><br><span class="line">&gt; some_dict[<span class="number">5.0</span>] = <span class="string">"JavaScript"</span></span><br><span class="line">&gt; some_dict[<span class="number">5</span>] = <span class="string">"Python"</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>Output:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt;&gt;&gt; some_dict[<span class="number">5.5</span>]</span><br><span class="line">&gt; <span class="string">"Ruby"</span></span><br><span class="line">&gt; &gt;&gt;&gt; some_dict[<span class="number">5.0</span>]</span><br><span class="line">&gt; <span class="string">"Python"</span></span><br><span class="line">&gt; &gt;&gt;&gt; some_dict[<span class="number">5</span>]</span><br><span class="line">&gt; <span class="string">"Python"</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><h4 id="💡-提示">💡 提示:</h4><ul><li><p>Python 字典通过检查键值是否相等和比较哈希值来确定两个键是否相同.</p></li><li><p>具有相同值的不可变对象在Python中始终具有相同的哈希值.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;   &gt;&gt;&gt; <span class="number">5</span> == <span class="number">5.0</span></span><br><span class="line">&gt;   <span class="keyword">True</span></span><br><span class="line">&gt;   &gt;&gt;&gt; hash(<span class="number">5</span>) == hash(<span class="number">5.0</span>)</span><br><span class="line">&gt;   <span class="keyword">True</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p>注意:</p><p>具有不同值的对象也可能具有相同的哈希值（哈希冲突）.</p><ul><li><p>当执行 <code>some_dict[5] = &quot;Python&quot;</code> 语句时, 因为Python将 <code>5</code> 和 <code>5.0</code> 识别为 <code>some_dict</code> 的同一个键, 所以已有值 “JavaScript” 就被 “Python” 覆盖了.</p></li><li><p>这个 StackOverflow的 <a href="https://stackoverflow.com/a/32211042/4354153" target="_blank" rel="noopener">回答</a> 漂亮的解释了这背后的基本原理.</p></li></ul></blockquote><blockquote><p>Return return everywhere!/到处返回!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">def</span> <span class="title">some_func</span><span class="params">()</span>:</span></span><br><span class="line">&gt; <span class="keyword">try</span>:</span><br><span class="line">&gt; <span class="keyword">return</span> <span class="string">'from_try'</span></span><br><span class="line">&gt; <span class="keyword">finally</span>:</span><br><span class="line">&gt; <span class="keyword">return</span> <span class="string">'from_finally'</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>Output:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt;&gt;&gt;some_func()</span><br><span class="line">&gt; <span class="string">'from_finally'</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><h4 id="💡-说明">💡 说明:</h4><ul><li>当在 “try…finally” 语句的 <code>try</code> 中执行 <code>return</code>, <code>break</code> 或 <code>continue</code> 后, <code>finally</code> 子句依然会执行.</li><li>函数的返回值由最后执行的 <code>return</code> 语句决定. 由于 <code>finally</code> 子句一定会执行, 所以 <code>finally</code> 子句中的 <code>return</code> 将始终是最后执行的语句.</li></ul></blockquote><hr><p><strong>&gt;Deep down, we’re all the same./本质上，我们都一样.</strong></p><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">WTF</span>:</span></span><br><span class="line">&gt; <span class="keyword">pass</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>Output:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt;&gt;&gt; WTF() == WTF() <span class="comment"># 两个不同的对象应该不相等</span></span><br><span class="line">&gt; <span class="keyword">False</span></span><br><span class="line">&gt; &gt;&gt;&gt; WTF() <span class="keyword">is</span> WTF() <span class="comment"># 也不相同</span></span><br><span class="line">&gt; <span class="keyword">False</span></span><br><span class="line">&gt; &gt;&gt;&gt; hash(WTF()) == hash(WTF()) <span class="comment"># 哈希值也应该不同</span></span><br><span class="line">&gt; <span class="keyword">True</span></span><br><span class="line">&gt; &gt;&gt;&gt; id(WTF()) == id(WTF())</span><br><span class="line">&gt; <span class="keyword">True</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><h4 id="💡-说明-v2">💡 说明:</h4><ul><li><p>当调用 <code>id</code> 函数时, Python 创建了一个 <code>WTF</code> 类的对象并传给 <code>id</code> 函数. 然后 <code>id</code> 函数获取其id值 (也就是内存地址), 然后丢弃该对象. 该对象就被销毁了.</p></li><li><p>当我们连续两次进行这个操作时, Python会将相同的内存地址分配给第二个对象. 因为 (在CPython中) <code>id</code> 函数使用对象的内存地址作为对象的id值, 所以两个对象的id值是相同的.</p></li><li><p>综上, 对象的id值仅仅在对象的生命周期内唯一. 在对象被销毁之后, 或被创建之前, 其他对象可以具有相同的id值.</p></li><li><p>那为什么 <code>is</code> 操作的结果为 <code>False</code> 呢? 让我们看看这段代码.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">WTF</span><span class="params">(object)</span>:</span></span><br><span class="line">&gt;     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span> print(<span class="string">"I"</span>)</span><br><span class="line">&gt;     <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span> print(<span class="string">"D"</span>)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p><strong>Output:</strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;   &gt;&gt;&gt; WTF() <span class="keyword">is</span> WTF()</span><br><span class="line">&gt;   I</span><br><span class="line">&gt;   I</span><br><span class="line">&gt;   D</span><br><span class="line">&gt;   D</span><br><span class="line">&gt;   <span class="keyword">False</span></span><br><span class="line">&gt;   &gt;&gt;&gt; id(WTF()) == id(WTF())</span><br><span class="line">&gt;   I</span><br><span class="line">&gt;   D</span><br><span class="line">&gt;   I</span><br><span class="line">&gt;   D</span><br><span class="line">&gt;   <span class="keyword">True</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>正如你所看到的, 对象销毁的顺序是造成所有不同之处的原因.</p><p>如果看完还是云里雾里：请看 <a href="https://www.jb51.net/article/60360.htm" target="_blank" rel="noopener">https://www.jb51.net/article/60360.htm</a></p></blockquote><hr><h3 id="for-what-为什么">&gt; For what?/为什么?</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">some_string = <span class="string">"wtf"</span></span><br><span class="line">some_dict = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i, some_dict[i] <span class="keyword">in</span> enumerate(some_string):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><strong>Output:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_dict <span class="comment"># 创建了索引字典.</span></span><br><span class="line">&#123;<span class="number">0</span>: <span class="string">'w'</span>, <span class="number">1</span>: <span class="string">'t'</span>, <span class="number">2</span>: <span class="string">'f'</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="💡-说明-v3">💡 说明:</h4><ul><li><p><a href="https://docs.python.org/3/reference/grammar.html" target="_blank" rel="noopener">Python 语法</a> （如果对英文文档吃力的化推荐看 <a href="https://docspy3zh.readthedocs.io/en/latest/reference/compound_stmts.html#for" target="_blank" rel="noopener">for语句</a>）中对 <code>for</code> 的定义是:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_stmt: <span class="string">'for'</span> exprlist <span class="string">'in'</span> testlist <span class="string">':'</span> suite [<span class="string">'else'</span> <span class="string">':'</span> suite]</span><br></pre></td></tr></table></figure><p>其中 <code>exprlist</code> 指分配目标. 这意味着对可迭代对象中的<strong>每一项都会执行</strong>类似 <code>{exprlist} = {next_value}</code> 的操作.</p><p>一个有趣的例子说明了这一点:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    print(i)</span><br><span class="line">    i = <span class="number">10</span></span><br></pre></td></tr></table></figure><p><strong>Output:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>你可曾觉得这个循环只会运行一次?</p><p><strong>💡 说明:</strong></p><ul><li>由于循环在Python中工作方式, 赋值语句 <code>i = 10</code> 并不会影响迭代循环, 在每次迭代开始之前, 迭代器(这里指 <code>range(4)</code>) 生成的下一个元素就被解包并赋值给目标列表的变量(这里指 <code>i</code>)了.</li></ul></li><li><p>在每一次的迭代中, <code>enumerate(some_string)</code> 函数就生成一个新值 <code>i</code> (计数器增加) 并从 <code>some_string</code> 中获取一个字符. 然后将字典 <code>some_dict</code> 键 <code>i</code> (刚刚分配的) 的值设为该字符. 本例中循环的展开可以简化为:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>i, some_dict[i] = (<span class="number">0</span>, <span class="string">'w'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i, some_dict[i] = (<span class="number">1</span>, <span class="string">'t'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i, some_dict[i] = (<span class="number">2</span>, <span class="string">'f'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_dict</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="evaluation-time-discrepancy-执行时机差异">&gt; Evaluation time discrepancy/执行时机差异</h3><ol><li></li></ol>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array = [<span class="number">1</span>, <span class="number">8</span>, <span class="number">15</span>]</span><br><span class="line">g = (x <span class="keyword">for</span> x <span class="keyword">in</span> array <span class="keyword">if</span> array.count(x) &gt; <span class="number">0</span>)</span><br><span class="line">array = [<span class="number">2</span>, <span class="number">8</span>, <span class="number">22</span>]</span><br></pre></td></tr></table></figure><p><strong>Output:</strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(g))</span><br><span class="line">[<span class="number">8</span>]</span><br></pre></td></tr></table></figure><ol start="2"><li></li></ol>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">array_1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">g1 = (x <span class="keyword">for</span> x <span class="keyword">in</span> array_1)</span><br><span class="line">array_1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">array_2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">g2 = (x <span class="keyword">for</span> x <span class="keyword">in</span> array_2)</span><br><span class="line">array_2[:] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p><strong>Output:</strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(g1))</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(g2))</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><h4 id="💡-说明-v4">💡 说明</h4><ul><li><p>在<a href="https://wiki.python.org/moin/Generators" target="_blank" rel="noopener">生成器</a>表达式中, <code>in</code> 子句在声明时执行, 而条件子句则是在运行时执行.</p><p>对上面一句的解释：</p><p>​在第一个例子中，<code>x for x in array</code>写出来的时候就执行了，而后面的 <code>if array.count(x) &gt; 0</code> 则是在 <code>array = [2, 8, 22]</code> 写完后 执行整个代码块时执行.</p></li><li><p>所以在运行前, <code>array</code> 已经被重新赋值为 <code>[2, 8, 22]</code>, 因此对于之前的 <code>1</code>, <code>8</code> 和 <code>15</code>, 只有 <code>count(8)</code> 的结果是大于 <code>0</code> 的, 所以生成器只会生成 <code>8</code>.</p></li><li><p>第二部分中 <code>g1</code> 和 <code>g2</code> 的输出差异则是由于变量 <code>array_1</code> 和 <code>array_2</code> 被重新赋值的方式导致的.</p></li><li><p>在第一种情况下, <code>array_1</code> 被绑定到新对象 <code>[1,2,3,4,5]</code>, 因为 <code>in</code> 子句是在声明时被执行的， 所以它仍然引用旧对象 <code>[1,2,3,4]</code>(并没有被销毁).</p></li><li><p>在第二种情况下, 对 <code>array_2</code> 的切片赋值将相同的旧对象 <code>[1,2,3,4]</code> 原地更新为 <code>[1,2,3,4,5]</code>. 因此 <code>g2</code> 和 <code>array_2</code> 仍然引用同一个对象(这个对象现在已经更新为 <code>[1,2,3,4,5]</code>).</p><hr></li></ul><h3 id="is-is-not-what-it-is-出人意料的is">&gt;<code>is</code> is not what it is!/出人意料的<code>is</code>!</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">下面是一个在互联网上非常有名的例子.</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">257</span>; b = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 💡 说明:</span></span><br><span class="line"></span><br><span class="line">**<span class="keyword">is</span> 和 == 的区别**</span><br><span class="line"></span><br><span class="line">- `<span class="keyword">is</span>` 运算符检查两个运算对象是否引用自同一对象 (即, 它检查两个预算对象是否相同).</span><br><span class="line"></span><br><span class="line">- `==` 运算符比较两个运算对象的值是否相等.</span><br><span class="line"></span><br><span class="line">- 因此</span><br></pre></td></tr></table></figure><p>​</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```python</span><br><span class="line"><span class="keyword">is</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>​</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代表引用相同,</span><br></pre></td></tr></table></figure><p>​</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```python</span><br><span class="line">==</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>​</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">  代表值相等. 下面的例子可以很好的说明这点,</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  &gt;&gt;&gt; [] == []</span><br><span class="line">  <span class="keyword">True</span></span><br><span class="line">  &gt;&gt;&gt; [] <span class="keyword">is</span> [] <span class="comment"># 这两个空列表位于不同的内存地址.</span></span><br><span class="line">  <span class="keyword">False</span></span><br><span class="line">  ```</span><br><span class="line"></span><br><span class="line">**<span class="number">256</span> 是一个已经存在的对象, 而 <span class="number">257</span> 不是**</span><br><span class="line"></span><br><span class="line">当你启动Python 的时候, `<span class="number">-5</span>` 到 `<span class="number">256</span>` 的数值就已经被分配好了. 这些数字因为经常使用所以适合被提前准备好.</span><br><span class="line"></span><br><span class="line">引用自 &lt;https://docs.python.org/<span class="number">3</span>/c-api/long.html&gt;</span><br><span class="line"></span><br><span class="line">&gt; 当前的实现为<span class="number">-5</span>到<span class="number">256</span>之间的所有整数保留一个整数对象数组, 当你创建了一个该范围内的整数时, 你只需要返回现有对象的引用. 所以改变<span class="number">1</span>的值是有可能的. 我怀疑这种行为在Python中是未定义行为. :-)</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(<span class="number">256</span>)</span><br><span class="line"><span class="number">10922528</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">10922528</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="number">10922528</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(<span class="number">257</span>)</span><br><span class="line"><span class="number">140084850247312</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(x)</span><br><span class="line"><span class="number">140084850247440</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(y)</span><br><span class="line"><span class="number">140084850247344</span></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">这里解释器并没有智能到能在执行 `y = <span class="number">257</span>` 时意识到我们已经创建了一个整数 `<span class="number">257</span>`, 所以它在内存中又新建了另一个对象.</span><br><span class="line"></span><br><span class="line">**当 a 和 b 在同一行中使用相同的值初始化时，会指向同一个对象.**</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b = <span class="number">257</span>, <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">140640774013296</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="number">140640774013296</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">140640774013392</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="number">140640774013488</span></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">- 当 a 和 b 在同一行中被设置为 `<span class="number">257</span>` 时, Python 解释器会创建一个新对象, 然后同时引用第二个变量. 如果你在不同的行上进行, 它就不会 <span class="string">"知道"</span> 已经存在一个 `<span class="number">257</span>` 对象了.</span><br><span class="line">- 这是一种特别为交互式环境做的编译器优化. 当你在实时解释器中输入两行的时候, 他们会单独编译, 因此也会单独进行优化. 如果你在 `.py` 文件中尝试这个例子, 则不会看到相同的行为, 因为文件是一次性编译的.</span><br></pre></td></tr></table></figure><h3 id="a-tic-tac-toe-where-x-wins-in-the-first-attempt-一蹴即至">&gt; A tic-tac-toe where X wins in the first attempt!/一蹴即至!</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们先初始化一个变量row</span></span><br><span class="line">row = [<span class="string">""</span>]*<span class="number">3</span> <span class="comment">#row i['', '', '']</span></span><br><span class="line"><span class="comment"># 并创建一个变量board</span></span><br><span class="line">board = [row]*<span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>Output:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>board</span><br><span class="line">[[<span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>], [<span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>], [<span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board[<span class="number">0</span>]</span><br><span class="line">[<span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"><span class="string">''</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">"X"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board</span><br><span class="line">[[<span class="string">'X'</span>, <span class="string">''</span>, <span class="string">''</span>], [<span class="string">'X'</span>, <span class="string">''</span>, <span class="string">''</span>], [<span class="string">'X'</span>, <span class="string">''</span>, <span class="string">''</span>]]</span><br></pre></td></tr></table></figure><p>我们有没有赋值过3个 “X” 呢？</p><h4 id="💡-说明-v5">💡 说明:</h4><p>当我们初始化 <code>row</code> 变量时, 下面这张图展示了内存中的情况。</p><p><a href="https://github.com/leisurelicht/wtfpython-cn/blob/master/images/tic-tac-toe/after_row_initialized.png" target="_blank" rel="noopener"><img src="https://github.com/leisurelicht/wtfpython-cn/raw/master/images/tic-tac-toe/after_row_initialized.png" alt="image"></a></p><p>而当通过对 <code>row</code> 做乘法来初始化 <code>board</code> 时, 内存中的情况则如下图所示 (每个元素 <code>board[0]</code>, <code>board[1]</code> 和 <code>board[2]</code> 都和 <code>row</code> 一样引用了同一列表.)</p><p><a href="https://github.com/leisurelicht/wtfpython-cn/blob/master/images/tic-tac-toe/after_board_initialized.png" target="_blank" rel="noopener"><img src="https://github.com/leisurelicht/wtfpython-cn/raw/master/images/tic-tac-toe/after_board_initialized.png" alt="image"></a></p><p>我们可以通过不使用变量 <code>row</code> 生成 <code>board</code> 来避免这种情况. (<a href="https://github.com/satwikkansal/wtfpython/issues/68" target="_blank" rel="noopener">这个</a>issue提出了这个需求.)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>board = [[<span class="string">''</span>]*<span class="number">3</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">"X"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board</span><br><span class="line">[[<span class="string">'X'</span>, <span class="string">''</span>, <span class="string">''</span>], [<span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>], [<span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>]]</span><br></pre></td></tr></table></figure><h3 id="the-sticky-output-function-麻烦的输出">&gt; The sticky output function/麻烦的输出</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">funcs = []</span><br><span class="line">results = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">some_func</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    funcs.append(some_func)</span><br><span class="line">    results.append(some_func()) <span class="comment"># 注意这里函数被执行了</span></span><br><span class="line"></span><br><span class="line">funcs_results = [func() <span class="keyword">for</span> func <span class="keyword">in</span> funcs]</span><br></pre></td></tr></table></figure><p><strong>Output:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>results</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>funcs_results</span><br><span class="line">[<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure><p>即使每次在迭代中将 <code>some_func</code> 加入 <code>funcs</code> 前的 <code>x</code> 值都不相同, 所有的函数还是都返回6.</p><p>// 再换个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>powers_of_x = [<span class="keyword">lambda</span> x: x**i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[f(<span class="number">2</span>) <span class="keyword">for</span> f <span class="keyword">in</span> powers_of_x]</span><br><span class="line">[<span class="number">512</span>, <span class="number">512</span>, <span class="number">512</span>, <span class="number">512</span>, <span class="number">512</span>, <span class="number">512</span>, <span class="number">512</span>, <span class="number">512</span>, <span class="number">512</span>, <span class="number">512</span>]</span><br></pre></td></tr></table></figure><h4 id="💡-说明-v6">💡 说明:</h4><ul><li><p>当在循环内部定义一个函数时, 如果该函数在其主体中使用了循环变量, 则闭包函数将与循环变量绑定, 而不是它的值. 因此, 所有的函数都是使用最后分配给变量的值来进行计算的.</p></li><li><p>Python调用函数加括号和不加括号的区别：</p><p>一、不带括号时，调用的是这个函数本身 ，是整个函数体，是一个函数对象，不须等该函数执行完成</p><p>二、带括号（参数或者无参），调用的是函数的执行结果，须等该函数执行完成的结果</p></li></ul>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span>  <span class="title">bracket</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 不带括号调用的结果：&lt;function bracket at 0x0000000004DD0B38&gt;,a是整个函数体，是一个函数对象，不须等该函数执行完成</span></span><br><span class="line">    a = bracket</span><br><span class="line">    <span class="keyword">print</span> (a)</span><br><span class="line">    <span class="comment"># 带括号调用的结果：6 ,b是函数执行后返回的值6,须等该函数执行完成的结果</span></span><br><span class="line">    b = bracket(<span class="number">6</span>)</span><br><span class="line">    <span class="keyword">print</span> (b)</span><br></pre></td></tr></table></figure><p><strong>Output:</strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;function bracket at <span class="number">0x0000016B43B4C7B8</span>&gt;</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><ul><li><p>可以通过将循环变量作为命名变量传递给函数来获得预期的结果. <strong>为什么这样可行?</strong> 因为这会在函数内再次定义一个局部变量.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">funcs = []s</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">some_func</span><span class="params">(x=x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    funcs.append(some_func)</span><br></pre></td></tr></table></figure><p><strong>Output:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>funcs_results = [func() <span class="keyword">for</span> func <span class="keyword">in</span> funcs]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>funcs_results</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="is-not-is-not-is-not-is-not-不是-is-not">&gt; <code>is not ...</code> is not <code>is (not ...)</code>/<code>is not ...</code> 不是 <code>is (not ...)</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'something'</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'something'</span> <span class="keyword">is</span> (<span class="keyword">not</span> <span class="keyword">None</span>)</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><h4 id="💡-说明-v7">💡 说明:</h4><ul><li><code>is not</code> 是个单独的二元运算符, 与分别使用 <code>is</code> 和 <code>not</code> 不同.</li><li>如果操作符两侧的变量指向同一个对象, 则 <code>is not</code> 的结果为 <code>False</code>, 否则结果为 <code>True</code>.</li></ul><h3 id="backslashes-at-the-end-of-string-字符串末尾的反斜杠">&gt; Backslashes at the end of string/字符串末尾的反斜杠</h3><p><strong>Output:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"\\ C:\\"</span>)</span><br><span class="line">\ C:\</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">r"\ C:"</span>)</span><br><span class="line">\ C:</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">r"\ C:\")</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    File "</span>&lt;stdin&gt;<span class="string">", line 1</span></span><br><span class="line"><span class="string">      print(r"</span>\ C:\<span class="string">")</span></span><br><span class="line"><span class="string">                     ^</span></span><br><span class="line"><span class="string">SyntaxError: EOL while scanning string literal</span></span><br></pre></td></tr></table></figure><h4 id="💡-说明-v8">💡 说明:</h4><ul><li><p>在以r开头的原始字符串中, 反斜杠并没有特殊含义.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(repr(<span class="string">r"wt\"f"</span>))</span><br><span class="line"><span class="string">'wt\\"f'</span></span><br></pre></td></tr></table></figure></li><li><p>解释器所做的只是简单的改变了反斜杠的行为, 因此会直接放行反斜杠及后一个的字符. 这就是反斜杠在原始字符串末尾不起作用的原因.</p></li><li><p>字符串的末尾，即使是原始（raw）字符串末尾也不能带奇数个反斜杠，因为这会引起后续引号的转义：比如r’C:\Windows’这个字符串常量，后一个反斜杠会告诉解析器后面的单引号不是字符串的结尾，字符串由两个引号包围，少了一个引号结束字符串，所以出现&quot;SyntaxError: EOL while scanning single-quoted string &quot;这个错误</p></li><li><p>r’C:\Windows’new’不会出错，很多人理解的原始字符串会保留字符本来的意义，所以会认为字符串中r’C:\Windows’已经是一个合法的字符串了，后面还跟着new’使得字符串不合法，其实这个字符串中r’C:\Windows’不合法，应为后面的反斜杠告诉解析器&quot;我后面的引号的意义已经被我转义了，在这里不是字符串的结尾，你可以继续进行解析&quot;。</p></li></ul><h3 id="not-knot-别纠结">&gt; not knot!/别纠结!</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="keyword">True</span></span><br><span class="line">y = <span class="keyword">False</span></span><br></pre></td></tr></table></figure><p><strong>Output:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">not</span> x == y</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x == <span class="keyword">not</span> y</span><br><span class="line">  File <span class="string">"&lt;input&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    x == <span class="keyword">not</span> y</span><br><span class="line">           ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><h4 id="💡-说明-v9">💡 说明:</h4><ul><li>运算符的优先级会影响表达式的求值顺序, 而在 Python 中 <code>==</code> 运算符的优先级要高于 <code>not</code> 运算符.</li><li>所以 <code>not x == y</code> 相当于 <code>not (x == y)</code>, 同时等价于 <code>not (True == False)</code>, 最后的运算结果就是 <code>True</code>.</li><li>之所以 <code>x == not y</code> 会抛一个 <code>SyntaxError</code> 异常, 是因为它会被认为等价于 <code>(x == not) y</code>, 而不是你一开始期望的 <code>x == (not y)</code>.</li><li>解释器期望 <code>not</code> 标记是 <code>not in</code> 操作符的一部分 (因为 <code>==</code> 和 <code>not in</code> 操作符具有相同的优先级), 但是它在 <code>not</code> 标记后面找不到 <code>in</code> 标记, 所以会抛出 <code>SyntaxError</code> 异常.</li></ul><h3 id="half-triple-quoted-strings-三个引号">&gt; Half triple-quoted strings/三个引号</h3><p><strong>Output:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'wtfpython'</span><span class="string">''</span>)</span><br><span class="line">wtfpython</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"wtfpython"</span><span class="string">""</span>)</span><br><span class="line">wtfpython</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 下面的语句会抛出 `SyntaxError` 异常</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># print('''wtfpython')</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># print("""wtfpython")</span></span><br></pre></td></tr></table></figure><h4 id="💡-说明-v10">💡 说明:</h4><ul><li><p>Python 提供隐式的</p><p>字符串链接</p><p>, 例如,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"wtf"</span> <span class="string">"python"</span>)</span><br><span class="line">wtfpython</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"wtf"</span> <span class="string">""</span>) <span class="comment"># or "wtf"""</span></span><br><span class="line">wtf</span><br></pre></td></tr></table></figure></li><li><p><code>'''</code> 和 <code>&quot;&quot;&quot;</code> 在 Python中也是字符串定界符, Python 解释器在先遇到三个引号的的时候会尝试再寻找三个终止引号作为定界符, 如果不存在则会导致 <code>SyntaxError</code> 异常.</p><h3 id="midnight-time-doesn-t-exist-不存在的午夜">&gt; Midnight time doesn’t exist?/不存在的午夜?</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">midnight = datetime(<span class="number">2018</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">midnight_time = midnight.time()</span><br><span class="line"></span><br><span class="line">noon = datetime(<span class="number">2018</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">12</span>, <span class="number">0</span>)</span><br><span class="line">noon_time = noon.time()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> midnight_time:</span><br><span class="line">    print(<span class="string">"Time at midnight is"</span>, midnight_time)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> noon_time:</span><br><span class="line">    print(<span class="string">"Time at noon is"</span>, noon_time)</span><br></pre></td></tr></table></figure><p><strong>Output:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">'Time at noon is'</span>, datetime.time(<span class="number">12</span>, <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>midnight_time 并没有被输出.</p><h4 id="💡-说明-v11">💡 说明:</h4><p>在Python 3.5之前, 如果 <code>datetime.time</code> 对象存储的UTC的午夜时间(译: 就是 <code>00:00</code>), 那么它的布尔值会被认为是 <code>False</code>. 当使用 <code>if obj:</code> 语句来检查 <code>obj</code> 是否为 <code>null</code> 或者某些“空”值的时候, 很容易出错.</p></li></ul><h3 id="what-s-wrong-with-booleans-布尔你咋了">&gt; What’s wrong with booleans?/布尔你咋了?</h3><ol><li></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个简单的例子, 统计下面可迭代对象中的布尔型值的个数和整型值的个数</span></span><br><span class="line">mixed_list = [<span class="keyword">False</span>, <span class="number">1.0</span>, <span class="string">"some_string"</span>, <span class="number">3</span>, <span class="keyword">True</span>, [], <span class="keyword">False</span>]</span><br><span class="line">integers_found_so_far = <span class="number">0</span></span><br><span class="line">booleans_found_so_far = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> mixed_list:</span><br><span class="line">    <span class="keyword">if</span> isinstance(item, int):</span><br><span class="line">        integers_found_so_far += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> isinstance(item, bool):</span><br><span class="line">        booleans_found_so_far += <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>Output:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>integers_found_so_far</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>booleans_found_so_far</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><ol start="2"><li></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">another_dict = &#123;&#125;</span><br><span class="line">another_dict[<span class="keyword">True</span>] = <span class="string">"JavaScript"</span></span><br><span class="line">another_dict[<span class="number">1</span>] = <span class="string">"Ruby"</span></span><br><span class="line">another_dict[<span class="number">1.0</span>] = <span class="string">"Python"</span></span><br></pre></td></tr></table></figure><p><strong>Output:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>another_dict[<span class="keyword">True</span>]</span><br><span class="line"><span class="string">"Python"</span></span><br></pre></td></tr></table></figure><ol start="3"><li></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_bool = <span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"wtf"</span>*some_bool</span><br><span class="line"><span class="string">'wtf'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_bool = <span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"wtf"</span>*some_bool</span><br><span class="line"><span class="string">''</span></span><br></pre></td></tr></table></figure><h4 id="💡-说明-v12">💡 说明:</h4><ul><li><p>布尔值是 <code>int</code> 的子类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="keyword">True</span>, int)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="keyword">False</span>, int)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure></li><li><p>所以 <code>True</code> 的整数值是 <code>1</code>, 而 <code>False</code> 的整数值是 <code>0</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">True</span> == <span class="number">1</span> == <span class="number">1.0</span> <span class="keyword">and</span> <span class="keyword">False</span> == <span class="number">0</span> == <span class="number">0.0</span></span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure></li><li><p>关于其背后的原理, 请看这个 StackOverflow 的<a href="https://stackoverflow.com/a/8169049/4354153" target="_blank" rel="noopener">回答</a>.</p></li></ul><h3 id="class-attributes-and-instance-attributes-类属性和实例属性">&gt; Class attributes and instance attributes/类属性和实例属性</h3><ol><li></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><strong>Output:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>A.x, B.x, C.x</span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B.x = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A.x, B.x, C.x</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A.x = <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A.x, B.x, C.x</span><br><span class="line">(<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = A()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.x, A.x</span><br><span class="line">(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.x += <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.x, A.x</span><br><span class="line">(<span class="number">4</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    some_var = <span class="number">15</span></span><br><span class="line">    some_list = [<span class="number">5</span>]</span><br><span class="line">    another_list = [<span class="number">5</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.some_var = x + <span class="number">1</span></span><br><span class="line">        self.some_list = self.some_list + [x]</span><br><span class="line">        self.another_list += [x]</span><br></pre></td></tr></table></figure><p><strong>Output:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_obj = SomeClass(<span class="number">420</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_obj.some_list</span><br><span class="line">[<span class="number">5</span>, <span class="number">420</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_obj.another_list</span><br><span class="line">[<span class="number">5</span>, <span class="number">420</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>another_obj = SomeClass(<span class="number">111</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>another_obj.some_list</span><br><span class="line">[<span class="number">5</span>, <span class="number">111</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>another_obj.another_list</span><br><span class="line">[<span class="number">5</span>, <span class="number">420</span>, <span class="number">111</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>another_obj.another_list <span class="keyword">is</span> SomeClass.another_list</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>another_obj.another_list <span class="keyword">is</span> some_obj.another_list</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><h4 id="💡-说明-v13">💡 说明:</h4><ul><li>类变量和实例变量在内部是通过类对象的字典来处理(译: 就是 <code>__dict__</code> 属性). 如果在当前类的字典中找不到的话就去它的父类中寻找.</li><li><code>+=</code> 运算符会在原地修改可变对象, 而不是创建新对象.(即会指向同一块地址) 因此, 修改一个实例的属性会影响其他实例和类属性.</li></ul><h3 id="yielding-none-生成-none">&gt; yielding None/生成 None</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">some_iterable = (<span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">some_func</span><span class="params">(val)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"something"</span></span><br></pre></td></tr></table></figure><p><strong>Output:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> some_iterable]</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(<span class="keyword">yield</span> x) <span class="keyword">for</span> x <span class="keyword">in</span> some_iterable]</span><br><span class="line">&lt;generator object &lt;listcomp&gt; at <span class="number">0x7f70b0a4ad58</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list([(<span class="keyword">yield</span> x) <span class="keyword">for</span> x <span class="keyword">in</span> some_iterable])</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list((<span class="keyword">yield</span> x) <span class="keyword">for</span> x <span class="keyword">in</span> some_iterable)</span><br><span class="line">[<span class="string">'a'</span>, <span class="keyword">None</span>, <span class="string">'b'</span>, <span class="keyword">None</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(some_func((<span class="keyword">yield</span> x)) <span class="keyword">for</span> x <span class="keyword">in</span> some_iterable)</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'something'</span>, <span class="string">'b'</span>, <span class="string">'something'</span>]</span><br></pre></td></tr></table></figure><h4 id="💡-说明-v14">💡 说明:</h4><ul><li><p>首先来看看在列表推导式中使用 yield 会发生什么：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(<span class="keyword">yield</span> x) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]] <span class="comment"># 在列表推导式中使用 yield&gt;&gt;&gt; &lt;generator object &lt;listcomp&gt; at 0x00C21510&gt;</span></span><br></pre></td></tr></table></figure><p>相当奇怪，返回一个 <strong><listcomp></listcomp></strong> 类型的生成器而不是一个包含生成器的列表</p><p>既然是生成器，那我们就用 <code>list()</code> 展开看一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list([(<span class="keyword">yield</span> x) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]])&gt;&gt;&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>虽然打印出了预期的结果，但还是感觉很奇怪：</p><p>列表推导式本身并不需要用 <code>list()</code> 展开的，这里却需要加上才行</p><p>那我们来看看如果是生成器表达式会如何：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="keyword">yield</span> x) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment"># 在生成器表达式中使用 yield&gt;&gt;&gt; &lt;generator object &lt;genexpr&gt; at 0x00C21C30&gt;</span></span><br></pre></td></tr></table></figure><p>嗯，的确是返回一个 <strong><genexpr></genexpr></strong> 类型的生成器，这很正常，那我们用 <code>list()</code> 展开看一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list((<span class="keyword">yield</span> x) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])&gt;&gt;&gt; [<span class="number">1</span>, <span class="keyword">None</span>, <span class="number">2</span>, <span class="keyword">None</span>, <span class="number">3</span>, <span class="keyword">None</span>]</span><br></pre></td></tr></table></figure><p>不含 yeild 的生成器表达式 (x for x in [1,2,3]) 相当于函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">genexpr</span><span class="params">(some_iterable)</span>:</span>    </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> some_iterable:        </span><br><span class="line"><span class="keyword">yield</span> x <span class="comment"># 外界传进来的值不用保存了，POP_TOP</span></span><br><span class="line">genexpr([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&lt;generator object genexpr at <span class="number">0x054EE420</span>&gt;</span><br><span class="line">list(genexpr([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>含 yeild 的生成器表达式 ((yield x) for x in [1,2,3]) 相当于函数 ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure><p>正是 <code>(yield x)</code> 造成的，这使得内部函数有两个连续的 YIELD_VALUE</p><p>外界传进来的值（这里是None）来不及 POP_TOP 就被 YIELD_VALUE 传递出去了！</p><p>最终外界的 list 会拿到自己传进去的None</p></li><li><p>我们不应该在列表（集合、字典）推导式或生成器表达式中使用 yield，有时会带来意想不到的结果</p><p>这其实是 Python 本身的一个 Bug，见 <a href="https://bugs.python.org/issue10544" target="_blank" rel="noopener">https://bugs.python.org/issue10544</a></p></li></ul><h3 id="mutating-the-immutable-强人所难">&gt; Mutating the immutable!/强人所难</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">some_tuple = (<span class="string">"A"</span>, <span class="string">"tuple"</span>, <span class="string">"with"</span>, <span class="string">"values"</span>)</span><br><span class="line">another_tuple = ([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>])</span><br></pre></td></tr></table></figure><p><strong>Output:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_tuple[<span class="number">2</span>] = <span class="string">"change this"</span></span><br><span class="line">TypeError: <span class="string">'tuple'</span> object does <span class="keyword">not</span> support item assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>another_tuple[<span class="number">2</span>].append(<span class="number">1000</span>) <span class="comment"># 这里不出现错误</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>another_tuple</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">1000</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>another_tuple[<span class="number">2</span>] += [<span class="number">99</span>, <span class="number">999</span>]</span><br><span class="line">TypeError: <span class="string">'tuple'</span> object does <span class="keyword">not</span> support item assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>another_tuple</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">1000</span>, <span class="number">99</span>, <span class="number">999</span>])</span><br></pre></td></tr></table></figure><p>我还以为元组是不可变的呢…</p><h4 id="💡-说明-v15">💡 说明:</h4><ul><li><p>引用 <a href="https://docs.python.org/2/reference/datamodel.html" target="_blank" rel="noopener">https://docs.python.org/2/reference/datamodel.html</a></p><blockquote><p>不可变序列 不可变序列的对象一旦创建就不能再改变. (如果对象包含对其他对象的引用，则这些其他对象可能是可变的并且可能会被修改; 但是，由不可变对象直接引用的对象集合不能更改.)</p></blockquote></li><li><p><code>+=</code> 操作符在原地修改了列表. 元素赋值操作并不工作, 但是当异常抛出时, 元素已经在原地被修改了.</p></li></ul><p>(译: 对于不可变对象, 这里指tuple, <code>+=</code> 并不是原子操作, 而是 <code>extend</code> 和 <code>=</code> 两个动作, 这里 <code>=</code> 操作虽然会抛出异常, 但 <code>extend</code>操作已经修改成功了. 详细解释可以看<a href="https://segmentfault.com/a/1190000010767068" target="_blank" rel="noopener">这里</a>)</p><p>换句话说，<code>+=</code><strong>并不是原子操作</strong>，相当于下面的两步:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t[2].extend([50,60])</span><br><span class="line">t[2] = t[2]</span><br></pre></td></tr></table></figure><p>第一步可以正确执行，但是第二步有了<code>=</code>，肯定会抛异常的。 同样这也可以解释在使用<code>+=</code>的时候，为何<code>t[2]</code>的<code>id</code>明明没有变化，但是仍然抛出异常了。</p><h3 id="the-disappearing-variable-from-outer-scope-消失的外部变量">&gt; The disappearing variable from outer scope/消失的外部变量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e = <span class="number">7</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><strong>Output (Python 2.x):</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(e)</span><br><span class="line"><span class="comment"># prints nothing</span></span><br></pre></td></tr></table></figure><p><strong>Output (Python 3.x):</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(e)</span><br><span class="line">NameError: name <span class="string">'e'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure><h4 id="💡-说明-v16">💡 说明:</h4><ul><li><p>出处: <a href="https://docs.python.org/3/reference/compound_stmts.html#except" target="_blank" rel="noopener">https://docs.python.org/3/reference/compound_stmts.html#except</a></p><p>当使用 <code>as</code> 为目标分配异常的时候, 将在except子句的末尾清除该异常.</p><p>这就好像</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">except</span> E <span class="keyword">as</span> N:</span><br><span class="line">    foo</span><br></pre></td></tr></table></figure><p>会被翻译成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">except</span> E <span class="keyword">as</span> N:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        foo</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">del</span> N</span><br></pre></td></tr></table></figure><p>这意味着异常必须在被赋值给其他变量才能在 <code>except</code> 子句之后引用它. 而异常之所以会被清除, 则是由于上面附加的回溯信息(trackback)会和栈帧(stack frame)形成循环引用, 使得该栈帧中的所有本地变量在下一次垃圾回收发生之前都处于活动状态.(译: 也就是说不会被回收)</p></li><li><p>子句在 Python 中并没有独立的作用域. 示例中的所有内容都处于同一作用域内, 所以变量 <code>e</code> 会由于执行了 <code>except</code> 子句而被删除. 而对于有独立的内部作用域的函数来说情况就不一样了. 下面的例子说明了这一点:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">del</span>(x)</span><br><span class="line">    print(x)</span><br><span class="line"></span><br><span class="line">x = <span class="number">5</span></span><br><span class="line">y = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p><strong>Output:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;f(x)</span><br><span class="line">UnboundLocalError: local variable <span class="string">'x'</span> referenced before assignment</span><br><span class="line">&gt;&gt;&gt;f(y)</span><br><span class="line">UnboundLocalError: local variable <span class="string">'x'</span> referenced before assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line">[<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure></li><li><p>在 Python 2.x 中, <code>Exception()</code> 实例被赋值给了变量 <code>e</code>, 所以当你尝试打印结果的时候, 它的输出为空.（译: 正常的Exception实例打印出来就是空）</p><p><strong>Output (Python 2.x):</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>e</span><br><span class="line">Exception()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> e</span><br><span class="line"><span class="comment"># 没有打印任何内容!</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="when-true-is-actually-false-真亦假">&gt; When True is actually False/真亦假</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">True = False</span><br><span class="line">if True == False:</span><br><span class="line">    print(&quot;I&apos;ve lost faith in truth!&quot;)</span><br></pre></td></tr></table></figure><p><strong>Output:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I&apos;ve lost faith in truth!</span><br></pre></td></tr></table></figure><h4 id="💡-说明-v17">💡 说明:</h4><ul><li>最初, Python 并没有 <code>bool</code> 型 (人们用0表示假值, 用非零值比如1作为真值). 后来他们添加了 <code>True</code>, <code>False</code>, 和 <code>bool</code> 型, 但是, 为了向后兼容, 他们没法把 <code>True</code> 和 <code>False</code> 设置为常量, 只是设置成了内置变量.</li><li>Python 3 由于不再需要向后兼容, 终于可以修复这个问题了, 所以这个例子无法在 Python 3.x 中执行! Python 3 中会出现 <code>SyntaxError: can't assign to keyword</code> 错误</li></ul><h3 id="from-filled-to-none-in-one-instruction-从有到无">&gt; From filled to None in one instruction…/从有到无…</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">some_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">some_dict = &#123;</span><br><span class="line">  <span class="string">"key_1"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">"key_2"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="string">"key_3"</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">print(id(some_list),id(some_dict))</span><br><span class="line">print(some_list)</span><br><span class="line">print(some_dict)</span><br><span class="line"></span><br><span class="line">some_list1 = some_list.append(<span class="number">4</span>)</span><br><span class="line">some_dict1 = some_dict.update(&#123;<span class="string">"key_4"</span>: <span class="number">4</span>&#125;)</span><br><span class="line">print(id(some_list1),id(some_dict1))</span><br><span class="line">print(some_list1)</span><br><span class="line">print(some_dict1)</span><br><span class="line"></span><br><span class="line">print(some_list)</span><br><span class="line">print(some_dict)</span><br></pre></td></tr></table></figure><p><strong>Output:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">139974154577824</span>, <span class="number">139974154583408</span>)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#123;<span class="string">'key_1'</span>: <span class="number">1</span>, <span class="string">'key_3'</span>: <span class="number">3</span>, <span class="string">'key_2'</span>: <span class="number">2</span>&#125;</span><br><span class="line">(<span class="number">139974153481728</span>, <span class="number">139974153481728</span>)</span><br><span class="line"><span class="keyword">None</span></span><br><span class="line"><span class="keyword">None</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">&#123;<span class="string">'key_4'</span>: <span class="number">4</span>, <span class="string">'key_1'</span>: <span class="number">1</span>, <span class="string">'key_3'</span>: <span class="number">3</span>, <span class="string">'key_2'</span>: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="💡-说明-v18">💡 说明:</h4><p>大多数修改序列/映射对象的方法, 比如 <code>list.append</code>, <code>dict.update</code>, <code>list.sort</code> 等等. 都是原地修改对象并返回 <code>None</code>. 这样做的理由是, 如果操作可以原地完成, 就可以避免创建对象的副本来提高性能.</p><h3 id="subclass-relationships-子类关系">&gt; Subclass relationships/子类关系 *</h3><p><strong>Output:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Hashable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(list, object)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(object, Hashable)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(list, Hashable)</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>子类关系应该是可传递的, 对吧? (即, 如果 <code>A</code> 是 <code>B</code> 的子类, <code>B</code> 是 <code>C</code> 的子类, 那么 <code>A</code> <em>应该</em> 是 <code>C</code> 的子类.)</p><h4 id="💡-说明-v19">💡 说明:</h4><ul><li>Python 中的子类关系并不必须是传递的. 任何人都可以在元类中随意定义 <code>__subclasscheck__</code>.</li><li>当 <code>issubclass(cls, Hashable)</code> 被调用时, 它只是在 <code>cls</code> 中寻找 “<code>__hash__</code>” 方法或继承自&quot;<code>__hash__</code>&quot;的方法.</li><li>由于 <code>object</code> is 可散列的(hashable), 但是 <code>list</code> 是不可散列的, 所以它打破了这种传递关系.</li></ul><h3 id="the-mysterious-key-type-conversion-神秘的键型转换">&gt; The mysterious key type conversion/神秘的键型转换 *</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span><span class="params">(str)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">some_dict = &#123;<span class="string">'s'</span>:<span class="number">42</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>Output:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(list(some_dict.keys())[<span class="number">0</span>])</span><br><span class="line">str</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = SomeClass(<span class="string">'s'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_dict[s] = <span class="number">40</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_dict <span class="comment"># 预期: 两个不同的键值对</span></span><br><span class="line">&#123;<span class="string">'s'</span>: <span class="number">40</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(list(some_dict.keys())[<span class="number">0</span>])</span><br><span class="line">str</span><br></pre></td></tr></table></figure><h4 id="💡-说明-v20">💡 说明:</h4><ul><li><p>由于 <code>SomeClass</code> 会从 <code>str</code> 自动继承 <code>__hash__</code> 方法, 所以 <code>s</code> 对象和 <code>&quot;s&quot;</code> 字符串的哈希值是相同的.</p></li><li><p>而 <code>SomeClass(&quot;s&quot;) == &quot;s&quot;</code> 为 <code>True</code> 是因为 <code>SomeClass</code> 也继承了 <code>str</code> 类 <code>__eq__</code> 方法.</p></li><li><p>可哈希的集合（hashed collections），需要集合的元素实现了eq和hash，而这两个方法可以作一个形象的比喻：<br>哈希集合就是很多个桶，但每个桶里面只能放一个球。 hash函数的作用就是找到桶的位置，到底是几号桶。 eq函数的作用就是当桶里面已经有一个球了，但又来了一个球，它声称它也应该装进这个桶里面（hash函数给它说了桶的位置），双方僵持不下，那就得用eq函数来判断这两个球是不是相等的（equal），如果是判断是相等的，那么后来那个球就不应该放进桶里，哈希集合维持现状.</p></li><li><p>由于两者的哈希值相同且相等, 所以它们在字典中表示相同的键.</p></li><li><p>如果想要实现期望的功能, 我们可以重定义 <code>SomeClass</code> 的 <code>__eq__</code> 方法.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span><span class="params">(str)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">          type(self) <span class="keyword">is</span> SomeClass</span><br><span class="line">          <span class="keyword">and</span> type(other) <span class="keyword">is</span> SomeClass</span><br><span class="line">          <span class="keyword">and</span> super().__eq__(other)</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 当我们自定义 __eq__ 方法时, Python 不会再自动继承 __hash__ 方法</span></span><br><span class="line">  <span class="comment"># 所以我们也需要定义它</span></span><br><span class="line">  __hash__ = str.__hash__</span><br><span class="line"></span><br><span class="line">some_dict = &#123;<span class="string">'s'</span>:<span class="number">42</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>Output:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = SomeClass(<span class="string">'s'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_dict[s] = <span class="number">40</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_dict</span><br><span class="line">&#123;<span class="string">'s'</span>: <span class="number">40</span>, <span class="string">'s'</span>: <span class="number">42</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>keys = list(some_dict.keys())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(keys[<span class="number">0</span>]), type(keys[<span class="number">1</span>])</span><br><span class="line">(__main__.SomeClass, str)</span><br></pre></td></tr></table></figure></li></ul><h3 id="let-s-see-if-you-can-guess-this-看看你能否猜到这一点">&gt; Let’s see if you can guess this?/看看你能否猜到这一点?</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b = a[b] = &#123;&#125;, <span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>Output:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&#123;<span class="number">5</span>: (&#123;...&#125;, <span class="number">5</span>)&#125;</span><br></pre></td></tr></table></figure><h4 id="💡-说明-v21">💡 说明:</h4><ul><li><p>根据 <a href="https://docs.python.org/2/reference/simple_stmts.html#assignment-statements" target="_blank" rel="noopener">Python 语言参考</a>, 赋值语句的形式如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(target_list <span class="string">"="</span>)+ (expression_list | yield_expression)</span><br></pre></td></tr></table></figure><blockquote><p>赋值语句计算表达式列表(expression list)(牢记 这可以是单个表达式或以逗号分隔的列表, 后者返回元组)并将单个结果对象从左到右分配给目标列表中的每一项.</p></blockquote></li><li><p><code>(target_list &quot;=&quot;)+</code> 中的 <code>+</code> 意味着可以有<strong>一个或多个</strong>目标列表. 在这个例子中, 目标列表是 <code>a, b</code> 和 <code>a[b]</code> (注意表达式列表只能有一个, 在我们的例子中是 <code>{}, 5</code>).</p></li><li><p>表达式列表计算结束后, 将其值自动解包后<strong>从左到右</strong>分配给目标列表(target list). 因此, 在我们的例子中, 首先将 <code>{}, 5</code> 元组并赋值给 <code>a, b</code>, 然后我们就可以得到 <code>a = {}</code> 且 <code>b = 5</code>.</p></li><li><p><code>a</code> 被赋值的 <code>{}</code> 是可变对象.</p></li><li><p>第二个目标列表是 <code>a[b]</code> (你可能觉得这里会报错, 因为在之前的语句中 <code>a</code> 和 <code>b</code> 都还没有被定义. 但是别忘了, 我们刚刚将 <code>a</code> 赋值 <code>{}</code> 且将 <code>b</code> 赋值为 <code>5</code>).</p></li><li><p>现在, 我们将通过将字典中键 <code>5</code> 的值设置为元组 <code>({}, 5)</code> 来创建<strong>循环引用</strong> (输出中的 <code>{...}</code> 指与 <code>a</code> 引用了相同的对象). 下面是一个更简单的循环引用的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_list = some_list[<span class="number">0</span>] = [<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_list</span><br><span class="line">[[...]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_list[<span class="number">0</span>]</span><br><span class="line">[[...]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_list <span class="keyword">is</span> some_list[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_list[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] == some_list</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>我们的例子就是这种情况 (<code>a[b][0]</code> 与 <code>a</code> 是相同的对象)</p></li><li><p>总结一下, 你也可以把例子拆成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a, b = &#123;&#125;, <span class="number">5</span></span><br><span class="line">a[b] = a, b</span><br></pre></td></tr></table></figure><p>并且可以通过 <code>a[b][0]</code> 与 <code>a</code> 是相同的对象来证明是循环引用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[b][<span class="number">0</span>] <span class="keyword">is</span> a</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>循环引用：</p><p><img src="https://github.com/WSCZou/Markdown-pic/blob/master/2118879-09fed596c7d95b42.png?raw=true" alt="2118879-09fed596c7d95b42.png"></p></li></ul><h2 id="section-appearances-are-deceptive-外表是靠不住的">Section: Appearances are deceptive!/外表是靠不住的!</h2><h3 id="skipping-lines-跳过一行">&gt; Skipping lines?/跳过一行?</h3><p><strong>Output:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; value = 11</span><br><span class="line">&gt;&gt;&gt; valuе = 32</span><br><span class="line">&gt;&gt;&gt; value</span><br><span class="line">11</span><br></pre></td></tr></table></figure><p>什么鬼?</p><p><strong>注意:</strong> 如果你想要重现的话最简单的方法是直接复制上面的代码片段到你的文件或命令行里.</p><h4 id="💡-说明-v22">💡 说明:</h4><p>一些非西方字符虽然看起来和英语字母相同, 但会被解释器识别为不同的字母.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ord(&apos;е&apos;) # 西里尔语的 &apos;e&apos; (Ye)</span><br><span class="line">1077</span><br><span class="line">&gt;&gt;&gt; ord(&apos;e&apos;) # 拉丁语的 &apos;e&apos;, 用于英文并使用标准键盘输入</span><br><span class="line">101</span><br><span class="line">&gt;&gt;&gt; &apos;е&apos; == &apos;e&apos;</span><br><span class="line">False</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; value = 42 # 拉丁语 e</span><br><span class="line">&gt;&gt;&gt; valuе = 23 # 西里尔语 &apos;e&apos;, Python 2.x 的解释器在这会抛出 `SyntaxError` 异常</span><br><span class="line">&gt;&gt;&gt; value</span><br><span class="line">42</span><br></pre></td></tr></table></figure><p>内置的 <code>ord()</code> 函数可以返回一个字符的 Unicode <a href="https://en.wikipedia.org/wiki/Code_point" target="_blank" rel="noopener">代码点</a>, 这里西里尔语 ‘e’ 和拉丁语 ‘e’ 的代码点不同证实了上述例子.</p><h3 id="teleportation-空间移动">&gt; Teleportation/空间移动 *</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">def energy_send(x):</span><br><span class="line">    # 初始化一个 numpy 数组</span><br><span class="line">    np.array([float(x)])</span><br><span class="line"></span><br><span class="line">def energy_receive():</span><br><span class="line">    # 返回一个空的 numpy 数组</span><br><span class="line">    return np.empty((), dtype=np.float).tolist()</span><br></pre></td></tr></table></figure><p><strong>Output:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; energy_send(123.456)</span><br><span class="line">&gt;&gt;&gt; energy_receive()</span><br><span class="line">123.456</span><br></pre></td></tr></table></figure><p>谁来给我发个诺贝尔奖?</p><h4 id="💡-说明-v23">💡 说明:</h4><ul><li><p>注意在 <code>energy_send</code> 函数中创建的 numpy 数组并没有返回, 因此内存空间被释放并可以被重新分配.</p><p>无<code>return</code>函数调用完，就会被释放.</p><p><code>numpy.empty()</code> 直接返回下一段空闲内存，而不重新初始化. 而这个内存点恰好就是刚刚释放的那个(通常情况下, 并不绝对).</p></li></ul><h3 id="well-something-is-fishy-嗯-有些可疑">&gt; Well, something is fishy…/嗯，有些可疑…</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    一个通过加法计算平方的简单函数.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    sum_so_far = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> counter <span class="keyword">in</span> range(x):</span><br><span class="line">        sum_so_far = sum_so_far + x</span><br><span class="line">  <span class="keyword">return</span> sum_so_far</span><br></pre></td></tr></table></figure><p><strong>Output (Python 2.x):</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>square(<span class="number">10</span>)</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>难道不应该是100吗?</p><h4 id="💡-说明-v24">💡 说明:</h4><ul><li><p><strong>不要混用制表符(tab)和空格(space)!</strong> 在上面的例子中, return 的前面是&quot;1个制表符&quot;, 而其他部分的代码前面是 “4个空格”.</p></li><li><p>Python是这么处理制表符的:</p><blockquote><p>首先, 制表符会从左到右依次被替换成8个空格, 直到被替换后的字符总数是八的倍数 &lt;…&gt;</p></blockquote></li><li><p>因此, <code>square</code> 函数最后一行的制表符会被替换成8个空格, 导致return语句进入循环语句里面.</p></li><li><p>Python 3 很友好, 在这种情况下会自动抛出错误.</p><p><strong>Output (Python 3.x):</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TabError: inconsistent use of tabs <span class="keyword">and</span> spaces <span class="keyword">in</span> indentation</span><br></pre></td></tr></table></figure></li></ul><h3 id="modifying-a-dictionary-while-iterating-over-it-迭代字典时的修改">&gt; Modifying a dictionary while iterating over it/迭代字典时的修改</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = &#123;<span class="number">0</span>: <span class="keyword">None</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">    <span class="keyword">del</span> x[i]</span><br><span class="line">    x[i+<span class="number">1</span>] = <span class="keyword">None</span></span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><p><strong>Output (Python 2.7- Python 3.5):</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><p>是的, 它运行了<strong>八次</strong>然后才停下来.</p><h4 id="💡-说明-v25">💡 说明:</h4><ul><li>Python不支持对字典进行迭代的同时修改它.</li><li>它之所以运行8次, 应该是因为字典的初始最小值是8, 扩容会导致散列表地址发生变化而中断循环.</li><li>在不同的Python实现中什么时候扩容在不同版本中可能是不同的, 在3.6及3.7的版本中到<a href="https://github.com/python/cpython/blob/v3.6.1/Objects/dictobject.c#L103-L110" target="_blank" rel="noopener">5</a>就会自动扩容了. 以后也有可能再次发生变化. 顺带一提,后面两次扩容会扩展为32和256. 8-&gt;32-&gt;256</li></ul><h3 id="stubborn-del-operator-坚强的-del">&gt; Stubborn <code>del</code> operator/坚强的 <code>del</code> *</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Deleted!"</span>)</span><br></pre></td></tr></table></figure><p><strong>Output:</strong> 1.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = SomeClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> x <span class="comment"># 这里应该会输出 "Deleted!"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> y</span><br><span class="line">Deleted!</span><br></pre></td></tr></table></figure><p>唷, 终于删除了. 你可能已经猜到了在我们第一次尝试删除 <code>x</code> 时是什么让 <code>__del__</code> 免于被调用的. 那让我们给这个例子增加点难度.</p><ol start="2"><li></li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = SomeClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y <span class="comment"># 检查一下y是否存在</span></span><br><span class="line">&lt;__main__.SomeClass instance at <span class="number">0x7f98a1a67fc8</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> y <span class="comment"># 像之前一样, 这里应该会输出 "Deleted!"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>globals() <span class="comment"># 好吧, 并没有. 让我们看一下所有的全局变量</span></span><br><span class="line">Deleted!</span><br><span class="line">&#123;'__builtins__': &lt;module '__builtin__' (built-in)&gt;, 'SomeClass': &lt;class __main__.SomeClass at 0x7f98a1a5f668&gt;, '__package__': None, '__name__': '__main__', '__doc__': None&#125;</span><br></pre></td></tr></table></figure><p>好了，现在它被删除了 😕</p><h4 id="💡-说明-v26">💡 说明:</h4><ul><li><p><code>del x</code> 并不会立刻调用 <code>x.__del__()</code>.</p></li><li><p>每当遇到 <code>del x</code>, Python 会将 <code>x</code> 的引用数减1, 当 <code>x</code> 的引用数减到0时就会调用 <code>x.__del__()</code>.</p></li><li><p>在第二个例子中, <code>y.__del__()</code> 之所以未被调用, 是因为前一条语句 (<code>&gt;&gt;&gt; y</code>) 对同一对象创建了另一个引用, 从而防止在执行 <code>del y</code> 后对象的引用数变为0.</p></li><li><p>调用 <code>globals</code> 导致引用被销毁, 因此我们可以看到 “Deleted!” 终于被输出了.</p></li><li><p>Python 的交互控制台有一个特性是 <code>_</code> 会自动保存上一个表达式输出的非 <code>None</code> 值.</p><p>因此在删除y的以后 <code>SomeClass</code> 实例的引用计数器的值为1，而不是0.</p><p>所以 <code>__del__</code> 不会被调用。</p><p>当有新的表达式在控制台输出其他非 <code>None</code> 值时， <code>_</code> 就会改为保存新的输出值。</p><p>这时 <code>SomeClass</code> 实例的引用计数器的值就会变成0，GC就会启动调用 <code>__del__</code> 并回收对象。</p></li></ul><h3 id="deleting-a-list-item-while-iterating-迭代列表时删除元素">&gt; Deleting a list item while iterating/迭代列表时删除元素</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">list_1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">list_2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">list_3 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">list_4 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx, item <span class="keyword">in</span> enumerate(list_1):</span><br><span class="line">    <span class="keyword">del</span> item</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx, item <span class="keyword">in</span> enumerate(list_2):</span><br><span class="line">    list_2.remove(item)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx, item <span class="keyword">in</span> enumerate(list_3[:]):</span><br><span class="line">    list_3.remove(item)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx, item <span class="keyword">in</span> enumerate(list_4):</span><br><span class="line">    list_4.pop(idx)</span><br></pre></td></tr></table></figure><p><strong>Output:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list_1</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list_2</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list_3</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list_4</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>你能猜到为什么输出是 <code>[2, 4]</code> 吗?</p><h4 id="💡-说明-v27">💡 说明:</h4><ul><li><p>在迭代时修改对象是一个很愚蠢的主意. 正确的做法是迭代对象的副本,然后遍历备份列表，删除的时候就删除原列表<code>list_3[:]</code> 就是这么做的.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(some_list)</span><br><span class="line"><span class="number">139798789457608</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(some_list[:]) <span class="comment"># 注意python为切片列表创建了新对象.</span></span><br><span class="line"><span class="number">139798779601192</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>del, remove 和 pop 的不同:</strong></p><ul><li><code>del var_name</code> 只是从本地或全局命名空间中删除了 <code>var_name</code> (这就是为什么 <code>list_1</code> 没有受到影响).</li><li><code>remove</code> 会删除第一个匹配到的指定值, 而不是特定的索引, 如果找不到值则抛出 <code>ValueError</code> 异常.</li><li><code>pop</code> 则会删除指定索引处的元素并返回它, 如果指定了无效的索引则抛出 <code>IndexError</code> 异常.</li></ul><p><strong>为什么输出是 [2, 4]?</strong></p><ul><li>列表迭代是按索引进行的, 所以当我们从 <code>list_2</code> 或 <code>list_4</code> 中删除 <code>1</code> 时, 列表的内容就变成了 <code>[2, 3, 4]</code>. 剩余元素会依次位移, 也就是说, <code>2</code> 的索引会变为 0, <code>3</code> 会变为 1. 由于下一次迭代将获取索引为 1 的元素 (即 <code>3</code>), 因此 <code>2</code> 将被彻底的跳过. 类似的情况会交替发生在列表中的每个元素上.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;What the f*ck Python 🐍&lt;/h1&gt;
&lt;h2 id=&quot;一些python的特性&quot;&gt;—— 一些Python的特性&lt;/h2&gt;
&lt;p&gt;​														参考(&lt;a href=&quot;https://github.com/leisurelicht/wtfp
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据挖掘</title>
    <link href="http://WSCZou.com/2018/09/08/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    <id>http://WSCZou.com/2018/09/08/数据挖掘/</id>
    <published>2018-09-08T04:34:04.000Z</published>
    <updated>2018-09-15T02:46:16.623Z</updated>
    
    <content type="html"><![CDATA[<h1>线性回归算法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#线性回归</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#训练集交叉验证，得到平均值</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> KFold</span><br></pre></td></tr></table></figure><h2 id="补充知识：训练集-验证集-测试集">补充知识：训练集、验证集、测试集</h2><p>如果给定的样本数据充足，我们通常使用均匀随机抽样的方式将数据集划分成3个部分——训练集、验证集和测试集，这三个集合不能有交集，常见的比例是8:1:1。需要注意的是，通常都会给定训练集和测试集，而不会给验证集。这时候验证集该从哪里得到呢？一般的做法是，从训练集中均匀随机抽样一部分样本作为验证集。</p><p>交叉验证（Cross validation)，交叉验证用于防止模型过于复杂而引起的过拟合.有时亦称循环估计， 是一种统计学上将数据样本切割成较小子集的实用方法。<strong>之所以出现交叉验证，主要是因为训练集较小。无法直接像前面那样只分出训练集，验证集，测试就可以了（简单交叉验证）。  需要说明的是，在实际情况下，人们不是很喜欢用交叉验证，主要是因为它会耗费较多的计算资源。一般直接把训练集按照50%-90%的比例分成训练集和验证集。但这也是根据具体情况来定的：如果超参数数量多，你可能就想用更大的验证集，而验证集的数量不够，那么最好还是用交叉验证吧。至于分成几份比较好，一般都是分成3、5和10份。</strong></p><h2 id="k折交叉验证">K折交叉验证</h2><ol><li>将数据集平均分割成K个等份</li><li>使用1份数据作为测试数据，其余作为训练数据</li><li>计算测试准确率</li><li>使用不同的测试集，重复2、3步骤</li><li>对测试准确率做平均，作为对未知数据预测准确率的估计<br><img src="https://img-blog.csdn.net/20171109144308208?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1d2VpeXV4aWFuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#样本平均分成3份，3折交叉验证  </span></span><br><span class="line">kf = KFold(n_splits=<span class="number">3</span>,shuffle=<span class="keyword">False</span>,random_state=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>n_splits：表示划分几等份</p><p>shuffle：在每次划分时，是否进行洗牌</p><p>①若为Falses时，其效果等同于random_state等于整数，每次划分的结果相同</p><p>②若为True时，每次划分的结果都不一样，表示经过洗牌，随机取样的</p><p>random_state：随机种子数</p><h1>随机森林算法</h1><p>1.随机森林原理：  随机森林由Leo Breiman（2001）提出的一种分类算法，它通过自助法（bootstrap）重采样技术，从原始训练样本集N中有放回地重复随机抽取n个样本生成新的训练样本集合训练决策树，然后按以上步骤生成m棵决策树组成随机森林，新数据的分类结果按分类树投票多少形成的分数而定。其实质是对决策树算法的一种改进，将多个决策树合并在一起，每棵树的建立依赖于独立抽取的样本。  单棵树的分类能力可能很小，但在随机产生大量的决策树后，一个测试样本可以通过每一棵树的分类结果经统计后选择最可能的分类。</p><p>随机森林大致过程如下：  1）从样本集中有放回随机采样选出n个样本；  2）从所有特征中随机选择k个特征，对选出的样本利用这些特征建立决策树（一般是CART，也可是别的或混合）；  3）重复以上两步m次，即生成m棵决策树，形成随机森林；  4）对于新数据，经过每棵树决策，最后投票确认分到哪一类。</p><h1>特征处理</h1><p>一般用pd.factorize()和pd.get_dummies()</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;线性回归算法&lt;/h1&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/spa
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>入门JAVA</title>
    <link href="http://WSCZou.com/2018/09/07/%E5%85%A5%E9%97%A8JAVA/"/>
    <id>http://WSCZou.com/2018/09/07/入门JAVA/</id>
    <published>2018-09-07T03:04:35.000Z</published>
    <updated>2018-09-07T04:55:32.096Z</updated>
    
    <content type="html"><![CDATA[<ul><li>在命令行窗口键入 javac HelloWorld.java  按下enter键编译代码。如果代码没有错误，cmd命令提示符会进入下一行。（假设环境变量都设置好了）。</li><li>再键入java HelloWorld 按下Enter键就可以运行程序了</li></ul><h2 id="java中的类">Java中的类</h2><p>一个类可以包含以下类型变量：</p><ul><li><strong>局部变量</strong>：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，<strong>方法结束后，变量就会自动销毁。</strong></li><li><strong>成员变量</strong>：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li><li><strong>类变量</strong>：类变量也声明在类中，方法体之外，但必须声明为static类型。</li></ul><p>一个类可以拥有多个方法，在上面的例子中：barking()、hungry()和sleeping()都是Dog类的方法。</p><h2 id="构造方法">构造方法</h2><p>每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。</p><p>在创建一个对象的时候，至少要调用一个构造方法。<strong>构造方法的名称必须与类同名</strong>，一个类可以有多个构造方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;在命令行窗口键入 javac HelloWorld.java  按下enter键编译代码。如果代码没有错误，cmd命令提示符会进入下一行。（假设环境变量都设置好了）。&lt;/li&gt;
&lt;li&gt;再键入java HelloWorld 按下Enter键就可以运行程序了&lt;/l
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>高数</title>
    <link href="http://WSCZou.com/2018/06/11/%E9%AB%98%E6%95%B0/"/>
    <id>http://WSCZou.com/2018/06/11/高数/</id>
    <published>2018-06-11T08:29:19.000Z</published>
    <updated>2018-06-20T10:36:40.366Z</updated>
    
    <content type="html"><![CDATA[<h1>微分方程</h1><p>通解不一定是所有解（lnc的例子）</p><h2 id="变量可分离">变量可分离</h2><h2 id="齐次：">齐次：</h2><p>把y看成自变量</p><p>设x\y=u时记得结果回代</p><h2 id="一阶线性公式法">一阶线性公式法</h2><h2 id="二阶常系数线性齐次方程">二阶常系数线性齐次方程</h2><p>三角函数 特征方程а（e的次方数）+ui=r1(or r2) k=1，Pm()cosux+Qn(x)sinux m,n选两者最大的次数作为一般方程次数</p><h2 id="y通-y齐通-y非齐特">y通=y齐通+y非齐特</h2><h1>多元微分学</h1><h2 id="链式求导规则">链式求导规则</h2><h2 id="偏导数">偏导数</h2><h2 id="极最值">极最值</h2><p>（无条件极值（大同小异只适用于二元），条件极（最）值）</p><h1>平面及方程</h1><p>3x-7y+5z-12=0的平面法向量为(3,-7,5)</p><p>方程中只有x或y或z表示与之垂直的平面</p><p>方程中缺少一个变量则与之平行</p><p>![TIM图片20180620132008](C:\Users\12143\Pictures\Saved Pictures\TIM图片20180620132008.png)</p><p>![TIM图片20180620132127](C:\Users\12143\Pictures\Saved Pictures\TIM图片20180620132127.png)</p><p>两平面的叉乘为相交直线的方向向量![TIM图片20180620133802](C:\Users\12143\Pictures\Saved Pictures\TIM图片20180620133802.png)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;微分方程&lt;/h1&gt;
&lt;p&gt;通解不一定是所有解（lnc的例子）&lt;/p&gt;
&lt;h2 id=&quot;变量可分离&quot;&gt;变量可分离&lt;/h2&gt;
&lt;h2 id=&quot;齐次：&quot;&gt;齐次：&lt;/h2&gt;
&lt;p&gt;把y看成自变量&lt;/p&gt;
&lt;p&gt;设x\y=u时记得结果回代&lt;/p&gt;
&lt;h2 id=&quot;一阶线性公式法&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据分析入门</title>
    <link href="http://WSCZou.com/2018/05/28/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/"/>
    <id>http://WSCZou.com/2018/05/28/数据分析入门/</id>
    <published>2018-05-28T01:33:26.000Z</published>
    <updated>2018-08-06T02:16:35.471Z</updated>
    
    <content type="html"><![CDATA[<h1>Jupyter Notebook</h1><h2 id="tab补全">Tab补全</h2><p>从外观上，IPython shell和标准的Python解释器只是看起来不同。IPython shell的进步之一是其它IDE和交互计算分析环境都有的tab补全功能。在shell中输入表达式，按下Tab，会搜索已输入变量（对象、函数等等）的命名空间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: an_apple = <span class="number">27</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: an_example = <span class="number">42</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: an&lt;Tab&gt;</span><br><span class="line">an_apple    <span class="keyword">and</span>         an_example  any</span><br></pre></td></tr></table></figure><p>在这个例子中，IPython呈现除了之前两个定义的变量和Python的关键字和内建的函数<code>any</code>。当然，你也可以补全任何对象的方法和属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">3</span>]: b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: b.&lt;Tab&gt;</span><br><span class="line">b.append  b.count   b.insert  b.reverse</span><br><span class="line">b.clear   b.extend  b.pop     b.sort</span><br><span class="line">b.copy    b.index   b.remove</span><br></pre></td></tr></table></figure><p>同样也适用于模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: datetime.&lt;Tab&gt;</span><br><span class="line">datetime.date          datetime.MAXYEAR       datetime.timedelta</span><br><span class="line">datetime.datetime      datetime.MINYEAR       datetime.timezone</span><br><span class="line">datetime.datetime_CAPI datetime.time          datetime.tzinfo</span><br></pre></td></tr></table></figure><p>在Jupyter notebook和新版的IPython（5.0及以上），自动补全功能是下拉框的形式。</p><blockquote><p>笔记：注意，默认情况下，IPython会隐藏下划线开头的方法和属性，比如魔术方法和内部的“私有”方法和属性，以避免混乱的显示（和让新手迷惑！）这些也可以tab补全，但是你必须首先键入一个下划线才能看到它们。如果你喜欢总是在tab补全中看到这样的方法，你可以IPython配置中进行设置。可以在IPython文档中查找方法。</p></blockquote><p>除了补全命名、对象和模块属性，Tab还可以补全其它的。当输入看似文件路径时（即使是Python字符串），按下Tab也可以补全电脑上对应的文件信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">7</span>]: datasets/movielens/&lt;Tab&gt;</span><br><span class="line">datasets/movielens/movies.dat    datasets/movielens/README</span><br><span class="line">datasets/movielens/ratings.dat   datasets/movielens/users.dat</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: path = <span class="string">'datasets/movielens/&lt;Tab&gt;</span></span><br><span class="line"><span class="string">datasets/movielens/movies.dat    datasets/movielens/README</span></span><br><span class="line"><span class="string">datasets/movielens/ratings.dat   datasets/movielens/users.dat</span></span><br></pre></td></tr></table></figure><p>结合<code>%run</code>，tab补全可以节省许多键盘操作。</p><p>另外，tab补全可以补全函数的关键词参数（包括等于号=）。见图2-4。</p><p><img src="//upload-images.jianshu.io/upload_images/7178691-8188b0386238c16a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/579" alt="img"></p><p>图2-4 Jupyter notebook中自动补全函数关键词</p><p>我们来仔细看看函数。</p><h2 id="自省">自省</h2><p>在变量前后使用问号？，可以显示对象的信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">8</span>]: b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">In [9]: b?</span><br><span class="line">Type:       list</span><br><span class="line">String Form:[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">Length:     <span class="number">3</span></span><br><span class="line">Docstring:</span><br><span class="line">list() -&gt; new empty list</span><br><span class="line">list(iterable) -&gt; new list initialized from iterable's items</span><br><span class="line"></span><br><span class="line">In [10]: print?</span><br><span class="line">Docstring:</span><br><span class="line">print(value, ..., sep=<span class="string">' '</span>, end=<span class="string">'\n'</span>, file=sys.stdout, flush=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line">Prints the values to a stream, <span class="keyword">or</span> to sys.stdout by default.</span><br><span class="line">Optional keyword arguments:</span><br><span class="line">file:  a file-like object (stream); defaults to the current sys.stdout.</span><br><span class="line">sep:   string inserted between values, default a space.</span><br><span class="line">end:   string appended after the last value, default a newline.</span><br><span class="line">flush: whether to forcibly flush the stream.</span><br><span class="line">Type:      builtin_function_or_method</span><br></pre></td></tr></table></figure><p>这可以作为对象的自省。如果对象是一个函数或实例方法，定义过的文档字符串，也会显示出信息。假设我们写了一个如下的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_numbers</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Add two numbers together</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    the_sum : type of arguments</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure><p>然后使用?符号，就可以显示如下的文档字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [11]: add_numbers?</span><br><span class="line">Signature: add_numbers(a, b)</span><br><span class="line">Docstring:</span><br><span class="line">Add two numbers together</span><br><span class="line"></span><br><span class="line">Returns</span><br><span class="line">-------</span><br><span class="line">the_sum : type of arguments</span><br><span class="line">File:      &lt;ipython-input<span class="number">-9</span><span class="number">-6</span>a548a216e27&gt;</span><br><span class="line">Type:      function</span><br></pre></td></tr></table></figure><p>使用??会显示函数的源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [12]: add_numbers??</span><br><span class="line">Signature: add_numbers(a, b)</span><br><span class="line">Source:</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_numbers</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Add two numbers together</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    the_sum : type of arguments</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">File:      &lt;ipython-input<span class="number">-9</span><span class="number">-6</span>a548a216e27&gt;</span><br><span class="line">Type:      function</span><br></pre></td></tr></table></figure><p>?还有一个用途，就是像Unix或Windows命令行一样搜索IPython的命名空间。字符与通配符结合可以匹配所有的名字。例如，我们可以获得所有包含load的顶级NumPy命名空间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [13]: np.*load*?</span><br><span class="line">np.__loader__</span><br><span class="line">np.load</span><br><span class="line">np.loads</span><br><span class="line">np.loadtxt</span><br><span class="line">np.pkgload</span><br></pre></td></tr></table></figure><h2 id="run命令">%run命令</h2><p>你可以用<code>%run</code>命令运行所有的Python程序。假设有一个文件<code>ipython_script_test.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x, y, z)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (x + y) / z</span><br><span class="line"></span><br><span class="line">a = <span class="number">5</span></span><br><span class="line">b = <span class="number">6</span></span><br><span class="line">c = <span class="number">7.5</span></span><br><span class="line"></span><br><span class="line">result = f(a, b, c)</span><br></pre></td></tr></table></figure><p>可以如下运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">14</span>]: %run ipython_script_test.py</span><br></pre></td></tr></table></figure><p>这段脚本运行在空的命名空间（没有import和其它定义的变量），因此结果和普通的运行方式<code>python script.py</code>相同。文件中所有定义的变量（import、函数和全局变量，除非抛出异常），都可以在IPython shell中随后访问：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">15</span>]: c</span><br><span class="line">Out [<span class="number">15</span>]: <span class="number">7.5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: result</span><br><span class="line">Out[<span class="number">16</span>]: <span class="number">1.4666666666666666</span></span><br></pre></td></tr></table></figure><p>如果一个Python脚本需要命令行参数（在<code>sys.argv</code>中查找），可以在文件路径之后传递，就像在命令行上运行一样。</p><blockquote><p>笔记：如果想让一个脚本访问IPython已经定义过的变量，可以使用<code>%run -i</code>。</p></blockquote><p>在Jupyter notebook中，你也可以使用<code>%load</code>，它将脚本导入到一个代码格中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>%load ipython_script_test.py</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x, y, z)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (x + y) / z</span><br><span class="line">    a = <span class="number">5</span></span><br><span class="line">    b = <span class="number">6</span></span><br><span class="line">    c = <span class="number">7.5</span></span><br><span class="line"></span><br><span class="line">    result = f(a, b, c)</span><br></pre></td></tr></table></figure><h2 id="命名空间">命名空间`</h2><p>python<code>使用命名空间记录变量。</code>python<code>中的命名空间就像是一个</code>dict<code>，</code>key<code>是变量的名字，</code>value`是变量的值。</p><p><code>python</code>中，每个函数都有一个自己的命名空间，叫做<code>local namespace</code>，它记录了函数的变量。</p><p><code>python</code>中，每个<code>module</code>有一个自己的命名空间，叫做<code>global namespace</code>，它记录了<code>module</code>的变量，包括 <code>functions, classes</code>和其它<code>imported modules</code>，还有 <code>module</code>级别的 变量和常量。</p><p>还有一个<code>build-in</code> 命名空间，可以被任意模块访问，这个<code>build-in</code>命名空间中包含了<code>build-in function</code> 和 <code>exceptions</code>。</p><h1>NumPy基础：数组和矢量计算</h1><p>NumPy之于数值计算特别重要的原因之一，是因为它可以高效处理大数组的数据。这是因为：</p><ul><li>NumPy是在一个连续的内存块中存储数据，独立于其他Python内置对象。<strong>NumPy的C语言编写的算法库可以操作内存</strong>，而不必进行类型检查或其它前期工作。比起Python的内置序列，NumPy数组使用的内存更少。</li><li>NumPy可以在整个数组上执行复杂的计算，而不需要Python的for循环。</li></ul><h2 id="numpy的ndarray：一种多维数组对象">NumPy的ndarray：一种多维数组对象</h2><h3 id="创建ndarray">创建ndarray</h3><h3 id="ndarray的数据类型">ndarray的数据类型</h3><p><em>arange会根据步长自动选取数据类型</em></p><h3 id="数组和标量之间的运算">数组和标量之间的运算</h3><h3 id="基本的索引和切片">基本的索引和切片</h3><h2 id="利用数组进行数据处理：">利用数组进行数据处理：</h2><p><strong><em>用数组表达式代替循环的做法，通常被称为矢量化</em></strong></p><h2 id="1-计算-x2-y2-用meshgrid函数把x-y分开成两个独立数组-然后用np-sqrt-xs-2-ys-2">1.计算（x<sup>2,y</sup>2）:用meshgrid函数把x，y分开成两个独立数组，然后用np.sqrt(xs ** 2+ys ** 2)</h2><ul><li><h3 id="np-meshgrid函数">np.meshgrid函数</h3></li></ul><p>接受两个一维数组，并产生两个二维矩阵（对应于两个数组中所有的(x,y)对）：</p><p><a href="http://baike.baidu.com/view/244398.htm" target="_blank" rel="noopener">mesh</a>grid是MATLAB中用于生成网格<a href="http://baike.baidu.com/view/984096.htm" target="_blank" rel="noopener">采样点</a>的函数。在使用MATLAB进行3-D图形绘制方面有着广泛的应用。</p><ul><li><h4 id="函数功能">函数功能</h4></li></ul><p>生成绘制3-D图形所需的<a href="http://baike.baidu.com/view/1396040.htm" target="_blank" rel="noopener">网格数据</a>。在计算机中进行绘图操作时， 往往需要一些<a href="http://baike.baidu.com/view/984096.htm" target="_blank" rel="noopener">采样点</a>，然后根据这些采样点来绘制出整个图形。在进行3-D绘图操作时，涉及到x、y、z三组数据，而x、y这两组数据可以看做是在Oxy平面内对坐标进行采样得到的坐标对(x, y)。</p><p>例如， 要在“3&lt;=x&lt;=5，6&lt;=y&lt;=9，z不限制<a href="http://baike.baidu.com/view/70334.htm" target="_blank" rel="noopener">区间</a>” 这个区域内绘制一个3-D图形，如果只需要整数坐标为<a href="http://baike.baidu.com/view/984096.htm" target="_blank" rel="noopener">采样点</a>的话。我们可能需要下面这样一个坐标构成的<a href="http://baike.baidu.com/view/10337.htm" target="_blank" rel="noopener">矩阵</a>：</p><p>(3,9),(4,9),(5,9);</p><p>(3,8),(4,8),(5,8);</p><p>(3,7),(4,7),(5,7);</p><p>(3,6),(4,6),(5,6);   // <strong>这些都是XOY平面的坐标点</strong></p><p>在matlab中我们可以这样描述这个坐标<a href="http://baike.baidu.com/view/10337.htm" target="_blank" rel="noopener">矩阵</a>：</p><p>把各个点的x坐标独立出来，得：</p><p>3,4,5;</p><p>3,4,5;</p><p>3,4,5;</p><p>3,4,5;</p><p>可以把这个矩阵设为X~~</p><p>再把各个点的y坐标也独立出来：</p><p>9,9,9;</p><p>8,8,8;</p><p>7,7,7;</p><p>6,6,6;</p><p>可以把这个矩阵设为Y~~</p><p>这样对应的x、y结合，便表示了上面的坐标<a href="http://baike.baidu.com/view/10337.htm" target="_blank" rel="noopener">矩阵</a>。<a href="http://baike.baidu.com/view/244398.htm" target="_blank" rel="noopener">mesh</a>grid就是产生这样两个<a href="http://baike.baidu.com/view/10337.htm" target="_blank" rel="noopener">矩阵</a>，来简化我们的操作。然后根据(x, y)计算获得z，并绘制出三维图形。</p><ul><li><h4 id="语法">语法</h4></li></ul><p>[X,Y] = <a href="http://baike.baidu.com/view/244398.htm" target="_blank" rel="noopener">mesh</a>grid(x,y)    // <strong>这个语句是用的最多的语句</strong></p><p>上面的描述，我们可以知道，<a href="http://baike.baidu.com/view/244398.htm" target="_blank" rel="noopener">mesh</a>grid返回的两个<a href="http://baike.baidu.com/view/10337.htm" target="_blank" rel="noopener">矩阵</a>X、Y必定是行数、列数相等的（即X、Y两个矩阵都有相同的行数，和相同的列数）</p><p>且X、Y的行数都等于输入参数y中元素的总个数，X、Y的列数都等于输入参数x中元素总个数（这个结论可以通过查看<a href="http://baike.baidu.com/view/244398.htm" target="_blank" rel="noopener">mesh</a>grid的源代码得到，可以通过示例程序得到验证）。（我们自己也可以体会到）</p><p>[X,Y]=<a href="http://baike.baidu.com/view/244398.htm" target="_blank" rel="noopener">mesh</a>grid(x)与[X,Y]=<a href="http://baike.baidu.com/view/244398.htm" target="_blank" rel="noopener">mesh</a>grid(x,x)是等同的</p><p>[X,Y,Z]=<a href="http://baike.baidu.com/view/244398.htm" target="_blank" rel="noopener">mesh</a>grid(x,y,z)生成三维<a href="http://baike.baidu.com/view/209670.htm" target="_blank" rel="noopener">数组</a>，可用来计算三<a href="http://baike.baidu.com/view/296689.htm" target="_blank" rel="noopener">变量</a>的函数和绘制三维立体图</p><p>相关函数： plot3、<a href="http://baike.baidu.com/view/244398.htm" target="_blank" rel="noopener">mesh</a>、<a href="http://baike.baidu.com/view/385941.htm" target="_blank" rel="noopener">surf</a>、automesh、<a href="http://baike.baidu.com/view/8025701.htm" target="_blank" rel="noopener">ndgrid</a></p><h2 id="将条件逻辑表述为数组运算">将条件逻辑表述为数组运算</h2><p>numpy.where函数是三元表达式x if condition else y的矢量化版本</p><p>假设有一个由随机数据组成的矩阵，你希望将所有正值替换为2，将所有负值替换为－2。若利用np.where，则会非常简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">172</span>]: arr = np.random.randn(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">173</span>]: arr</span><br><span class="line">Out[<span class="number">173</span>]: </span><br><span class="line">array([[<span class="number">-0.5031</span>, <span class="number">-0.6223</span>, <span class="number">-0.9212</span>, <span class="number">-0.7262</span>],</span><br><span class="line">       [ <span class="number">0.2229</span>,  <span class="number">0.0513</span>, <span class="number">-1.1577</span>,  <span class="number">0.8167</span>],</span><br><span class="line">       [ <span class="number">0.4336</span>,  <span class="number">1.0107</span>,  <span class="number">1.8249</span>, <span class="number">-0.9975</span>],</span><br><span class="line">       [ <span class="number">0.8506</span>, <span class="number">-0.1316</span>,  <span class="number">0.9124</span>,  <span class="number">0.1882</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">174</span>]: arr &gt; <span class="number">0</span></span><br><span class="line">Out[<span class="number">174</span>]: </span><br><span class="line">array([[<span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span>],</span><br><span class="line">       [ <span class="keyword">True</span>,  <span class="keyword">True</span>, <span class="keyword">False</span>,  <span class="keyword">True</span>],</span><br><span class="line">       [ <span class="keyword">True</span>,  <span class="keyword">True</span>,  <span class="keyword">True</span>, <span class="keyword">False</span>],</span><br><span class="line">       [ <span class="keyword">True</span>, <span class="keyword">False</span>,  <span class="keyword">True</span>,  <span class="keyword">True</span>]], dtype=bool)</span><br><span class="line"></span><br><span class="line">In [<span class="number">175</span>]: np.where(arr &gt; <span class="number">0</span>, <span class="number">2</span>, <span class="number">-2</span>)</span><br><span class="line">Out[<span class="number">175</span>]: </span><br><span class="line">array([[<span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-2</span>],</span><br><span class="line">       [ <span class="number">2</span>,  <span class="number">2</span>, <span class="number">-2</span>,  <span class="number">2</span>],</span><br><span class="line">       [ <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>, <span class="number">-2</span>],</span><br><span class="line">       [ <span class="number">2</span>, <span class="number">-2</span>,  <span class="number">2</span>,  <span class="number">2</span>]])</span><br></pre></td></tr></table></figure><p>使用np.where，可以将标量和数组结合起来。例如，我可用常数2替换arr中所有正的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">176</span>]: np.where(arr &gt; <span class="number">0</span>, <span class="number">2</span>, arr) <span class="comment"># set only positive values to 2</span></span><br><span class="line">Out[<span class="number">176</span>]: </span><br><span class="line">array([[<span class="number">-0.5031</span>, <span class="number">-0.6223</span>, <span class="number">-0.9212</span>, <span class="number">-0.7262</span>],</span><br><span class="line">       [ <span class="number">2.</span>    ,  <span class="number">2.</span>    , <span class="number">-1.1577</span>,  <span class="number">2.</span>    ],</span><br><span class="line">       [ <span class="number">2.</span>    ,  <span class="number">2.</span>    ,  <span class="number">2.</span>    , <span class="number">-0.9975</span>],</span><br><span class="line">       [ <span class="number">2.</span>    , <span class="number">-0.1316</span>,  <span class="number">2.</span>    ,  <span class="number">2.</span>    ]])</span><br></pre></td></tr></table></figure><p>传递给where的数组大小可以不相等，甚至可以是标量值。</p><h2 id="数学和统计方法：">数学和统计方法：</h2><p>arr.mean(axis=1):求取均值</p><p>arr.sum(0)</p><p>mean和sum这类的函数可以接受一个axis选项参数，用于计算该轴向上的统计值，最终结果是一个少一维的数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">182</span>]: arr.mean(axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">182</span>]: array([ <span class="number">1.022</span> ,  <span class="number">0.1875</span>, <span class="number">-0.502</span> , <span class="number">-0.0881</span>,  <span class="number">0.3611</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">183</span>]: arr.sum(axis=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">183</span>]: array([ <span class="number">3.1693</span>, <span class="number">-2.6345</span>,  <span class="number">2.2381</span>,  <span class="number">1.1486</span>])</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/7178691-a6c6df3ca8e0b98e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"><img src="https://upload-images.jianshu.io/upload_images/7178691-866fcde885b1d357.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p><p>python3中numpy生成随机数是:np.random.randn()而不是arr=randn()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">arr=np.random.randn(<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">arr</span><br><span class="line">array([[[ <span class="number">0.64940349</span>, <span class="number">-0.15975234</span>],</span><br><span class="line">        [ <span class="number">0.29735591</span>,  <span class="number">0.55789277</span>],</span><br><span class="line">        [<span class="number">-0.89126438</span>, <span class="number">-0.17877176</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">0.423854</span>  ,  <span class="number">0.20532171</span>],</span><br><span class="line">        [ <span class="number">2.10879442</span>,  <span class="number">0.65558143</span>],</span><br><span class="line">        [<span class="number">-1.24561077</span>,  <span class="number">0.5913198</span> ]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">0.87765436</span>, <span class="number">-1.10474883</span>],</span><br><span class="line">        [ <span class="number">0.55865895</span>, <span class="number">-0.29967409</span>],</span><br><span class="line">        [<span class="number">-1.62506822</span>,  <span class="number">1.18154769</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">2.03562367</span>,  <span class="number">2.61382019</span>],</span><br><span class="line">        [<span class="number">-0.36074442</span>,  <span class="number">0.1386859</span> ],</span><br><span class="line">        [ <span class="number">1.01916762</span>, <span class="number">-0.90662428</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">-0.60707229</span>, <span class="number">-0.65355764</span>],</span><br><span class="line">        [<span class="number">-0.39045661</span>,  <span class="number">1.39100898</span>],</span><br><span class="line">        [<span class="number">-0.44060985</span>, <span class="number">-0.39515</span>   ]]])</span><br><span class="line">arr.sort(<span class="number">1</span>)</span><br><span class="line">arr</span><br><span class="line">array([[[<span class="number">-0.89126438</span>, <span class="number">-0.17877176</span>],</span><br><span class="line">        [<span class="number">-0.15975234</span>,  <span class="number">0.55789277</span>],</span><br><span class="line">        [ <span class="number">0.29735591</span>,  <span class="number">0.64940349</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">-1.24561077</span>,  <span class="number">0.423854</span>  ],</span><br><span class="line">        [ <span class="number">0.20532171</span>,  <span class="number">0.5913198</span> ],</span><br><span class="line">        [ <span class="number">0.65558143</span>,  <span class="number">2.10879442</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">-1.62506822</span>,  <span class="number">0.55865895</span>],</span><br><span class="line">        [<span class="number">-1.10474883</span>,  <span class="number">0.87765436</span>],</span><br><span class="line">        [<span class="number">-0.29967409</span>,  <span class="number">1.18154769</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">-0.90662428</span>,  <span class="number">0.1386859</span> ],</span><br><span class="line">        [<span class="number">-0.36074442</span>,  <span class="number">1.01916762</span>],</span><br><span class="line">        [ <span class="number">2.03562367</span>,  <span class="number">2.61382019</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">-0.65355764</span>, <span class="number">-0.60707229</span>],</span><br><span class="line">        [<span class="number">-0.44060985</span>, <span class="number">-0.39515</span>   ],</span><br><span class="line">        [<span class="number">-0.39045661</span>,  <span class="number">1.39100898</span>]]])</span><br><span class="line">arr.sort(<span class="number">2</span>)</span><br><span class="line">arr</span><br><span class="line">array([[[<span class="number">-0.89126438</span>, <span class="number">-0.17877176</span>],</span><br><span class="line">        [<span class="number">-0.15975234</span>,  <span class="number">0.55789277</span>],</span><br><span class="line">        [ <span class="number">0.29735591</span>,  <span class="number">0.64940349</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">-1.24561077</span>,  <span class="number">0.423854</span>  ],</span><br><span class="line">        [ <span class="number">0.20532171</span>,  <span class="number">0.5913198</span> ],</span><br><span class="line">        [ <span class="number">0.65558143</span>,  <span class="number">2.10879442</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">-1.62506822</span>,  <span class="number">0.55865895</span>],</span><br><span class="line">        [<span class="number">-1.10474883</span>,  <span class="number">0.87765436</span>],</span><br><span class="line">        [<span class="number">-0.29967409</span>,  <span class="number">1.18154769</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">-0.90662428</span>,  <span class="number">0.1386859</span> ],</span><br><span class="line">        [<span class="number">-0.36074442</span>,  <span class="number">1.01916762</span>],</span><br><span class="line">        [ <span class="number">2.03562367</span>,  <span class="number">2.61382019</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">-0.65355764</span>, <span class="number">-0.60707229</span>],</span><br><span class="line">        [<span class="number">-0.44060985</span>, <span class="number">-0.39515</span>   ],</span><br><span class="line">        [<span class="number">-0.39045661</span>,  <span class="number">1.39100898</span>]]])</span><br></pre></td></tr></table></figure><p>顶级方法np.sort返回的是数组的已排序副本，而就地排序则会修改数组本身。计算数组分位数最简单的办法是对其进行排序，然后选取特定位置的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">203</span>]: large_arr = np.random.randn(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">204</span>]: large_arr.sort()</span><br><span class="line"></span><br><span class="line">In [<span class="number">205</span>]: large_arr[int(<span class="number">0.05</span> * len(large_arr))] <span class="comment"># 5% quantile</span></span><br><span class="line">Out[<span class="number">205</span>]: <span class="number">-1.5311513550102103</span></span><br></pre></td></tr></table></figure><p>5% quantile解释：</p><p>随机变量的分布与分位数概念</p><p>在质量工程师的培训中，我们经常询问学员以下图形是什么曲线，学员普遍能够回答是正态分布曲线，但进一步询问学员该曲线的纵轴f(x)表示什么，许多同学以为是概率值。其实这个曲线是正态分布概率密度曲线，f(x)是指随机变量X在观察值为x时的概率密度，如果随机变量X的单位为mm，则f(x)的单位为%/mm。曲线与X轴所围成的面积表示概率，该面积等于1，因为随机变量的所有可能取值（即：100%）都在X轴上。</p><p>以下是一个均值=10，标准差=0.5的正态分布概率密度曲线的例子，x=9.020的垂线与该分布的概率密度曲线和X轴所围成的左侧区域面积=0.025，该面积表示在随机变量X的总体分布中，有2.5%的值小于9.020，也就是说在总体分布中，随机变量X的取值小于9.020的概率为2.5%。同样，x=10.98的垂线与该分布的概率密度曲线和X轴所围成的右侧区域面积=0.025，该面积表示在随机变量X的总体分布中，有2.5%的值大于10.98，也就是说在总体分布中，随机变量X的取值大于10.98的概率为2.5%（也即是随机变量X的取值小于10.98的概率为97.5%）。<strong>在这个分布中，x=9.020的值被称为X的2.5%分位数（即：X2.5%=9.020）</strong>，x=10.98的值被称为X的97.5%分位数（X97.5%=10.98）。随机变量X有95%（即：97.5% - 2.5%=95%）的取值落在9.020至10.98之间。每个分位数都是随机变量所有可能取值中的某个值。按照定义，若某个值Xp被称为随机变量X的p分位数，则随机变量X的取值小于Xp的概率为p。</p><p>​                        <a href="http://photo.blog.sina.com.cn/showpic.html#blogid=60be90250102vby8&amp;url=http://album.sina.com.cn/pic/001LQmQ5ty6PsNXZXty3c" target="_blank" rel="noopener"><img src="http://s13.sinaimg.cn/mw690/001LQmQ5ty6PsNXZXty3c&amp;690" alt="随机变量的分布与分位数概念"></a></p><h2 id="唯一化以及其它的集合逻辑">唯一化以及其它的集合逻辑</h2><p>NumPy提供了一些针对一维ndarray的基本集合运算。最常用的可能要数np.unique了，它用于找出数组中的唯一值并返回已排序的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">206</span>]: names = np.array([<span class="string">'Bob'</span>, <span class="string">'Joe'</span>, <span class="string">'Will'</span>, <span class="string">'Bob'</span>, <span class="string">'Will'</span>, <span class="string">'Joe'</span>, <span class="string">'Joe'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">207</span>]: np.unique(names)</span><br><span class="line">Out[<span class="number">207</span>]: </span><br><span class="line">array([<span class="string">'Bob'</span>, <span class="string">'Joe'</span>, <span class="string">'Will'</span>],</span><br><span class="line">      dtype=<span class="string">'&lt;U4'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">208</span>]: ints = np.array([<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">209</span>]: np.unique(ints)</span><br><span class="line">Out[<span class="number">209</span>]: array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure><p>拿跟np.unique等价的纯Python代码来对比一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">210</span>]: sorted(set(names))</span><br><span class="line">Out[<span class="number">210</span>]: [<span class="string">'Bob'</span>, <span class="string">'Joe'</span>, <span class="string">'Will'</span>]</span><br></pre></td></tr></table></figure><p>另一个函数np.in1d用于测试一个数组中的值在另一个数组中的成员资格，返回一个布尔型数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">211</span>]: values = np.array([<span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">212</span>]: np.in1d(values, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>])</span><br><span class="line">Out[<span class="number">212</span>]: array([ <span class="keyword">True</span>, <span class="keyword">False</span>, <span class="keyword">False</span>,  <span class="keyword">True</span>,  <span class="keyword">True</span>, <span class="keyword">False</span>,  <span class="keyword">True</span>], dtype=bool)</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/7178691-80e85ae6b9c89ada.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p><h2 id="用于数组的文件输入输出">用于数组的文件输入输出</h2><p>NumPy能够读写磁盘上的文本数据或二进制数据。</p><p>np.save和np.load是读写磁盘数组数据的两个主要函数。默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为.npy的文件中的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">213</span>]: arr = np.arange(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">214</span>]: np.save(<span class="string">'some_array'</span>, arr)</span><br></pre></td></tr></table></figure><p>如果文件路径末尾没有扩展名.npy，则该扩展名会被自动加上。然后就可以通过np.load读取磁盘上的数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">215</span>]: np.load(<span class="string">'some_array.npy'</span>)</span><br><span class="line">Out[<span class="number">215</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure><p>通过np.savez可以将多个数组保存到一个未压缩文件中，将数组以关键字参数的形式传入即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">216</span>]: np.savez(<span class="string">'array_archive.npz'</span>, a=arr, b=arr)</span><br></pre></td></tr></table></figure><p>加载.npz文件时，你会得到一个类似字典的对象，该对象会对各个数组进行延迟加载：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">217</span>]: arch = np.load(<span class="string">'array_archive.npz'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">218</span>]: arch[<span class="string">'b'</span>]</span><br><span class="line">Out[<span class="number">218</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure><p>如果数据压缩的很好，就可以使用numpy.savez_compressed：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">219</span>]: np.savez_compressed(<span class="string">'arrays_compressed.npz'</span>, a=arr, b=arr)</span><br></pre></td></tr></table></figure><h2 id="线性代数">线性代数</h2><p>只有当矩阵 <em>A</em>的列数与矩阵 <em>B</em>的行数相等时 <em>A</em>× <em>B</em>才有意义。一个 <em>m</em>× <em>n</em>的矩阵 <em>a（m</em>, <em>n</em>)左乘一个 <em>n</em>× <em>p</em>的矩阵 <em>b（n</em>, <em>p</em>)，会得到一个 <em>m</em>× <em>p</em>的矩阵 <em>c（m</em>, <em>p</em>)，满足</p><p>矩阵乘法满足结合律，但不满足<a href="http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=180324&amp;ss_c=ssc.citiao.link" target="_blank" rel="noopener">交换律</a></p><p>一般的矩乘要结合<a href="http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=70957172&amp;ss_c=ssc.citiao.link" target="_blank" rel="noopener">快速幂</a>才有效果。（基本上所有矩阵乘法都要用到快速幂的）</p><p>在计算机中，一个矩阵说穿了就是一个<a href="http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=6552947&amp;ss_c=ssc.citiao.link" target="_blank" rel="noopener">二维数组</a>。一个n行m列的矩阵可以乘以一个m行p列的矩阵，得到的结果是一个n行p列的矩阵，其中的第i行第j列位置上的数等于前一个矩阵第i行上的m个数与后一个矩阵第j列上的m个数对应相乘后所有m个乘积的和。比如，下面的算式表示一个2行2列的矩阵乘以2行3列的矩阵，其结果是一个2行3列的矩阵。其中，结果的那个4等于2<em>2+0</em>1：</p><p><a href="http://baike.sogou.com/PicBooklet.v?relateImageGroupIds=&amp;lemmaId=7527881&amp;now=http%3A%2F%2Fpic.baike.soso.com%2Fp%2F20140220%2F20140220153658-1217934520.jpg&amp;type=1" target="_blank" rel="noopener"><img src="http://pic.baike.soso.com/p/20140220/bki-20140220153658-1217934520.jpg" alt="img"></a></p><p>A中第一行乘B中第一列的和为结果第一行和第一列的值</p><p>1<em>0+1</em>1=1    1<em>2+1</em>1=3    1<em>3+1</em>2=5</p><p>2<em>0+0</em>1=0    2<em>2+0</em>1=4    2<em>3+0</em>2=6</p><h2 id="随机漫步">随机漫步</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">position=<span class="number">0</span></span><br><span class="line">walk=[position]</span><br><span class="line">steps=<span class="number">1000</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(steps):</span><br><span class="line">    step=<span class="number">1</span> <span class="keyword">if</span> random.randint(<span class="number">0</span>,<span class="number">1</span>) <span class="keyword">else</span> <span class="number">-1</span> <span class="comment"># 这句话实际上是一种逻辑判断句，random.randint是逻辑判断条件，与0比较。标准语句：a if condition else b .判断条件大于0，选择a，反之，选择b。</span></span><br><span class="line">    position+=step</span><br><span class="line">    walk.append(position)</span><br><span class="line">a=plt.plot(walk[:<span class="number">100</span>])</span><br><span class="line">a</span><br></pre></td></tr></table></figure><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAXwAAAD8CAYAAAB0IB+mAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADl0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uIDIuMS4yLCBodHRwOi8vbWF0cGxvdGxpYi5vcmcvNQv5yAAAIABJREFUeJzt3Xl429d95/v3AUBw3xcQ0EaJoiiJImA7tC3Li2RJliULiJu0mds2N+29zb2ZdLnTdDrTps0zz9M7aabTZpqmnSfTaabtrG1zWzsbSEleZMeONy2WDJBaqIVaSAHcxX0nzv0DABeRFEESIEjg+3oePiYPfsTv/AD5wx/O7/y+R2mtEUIIkfgM8e6AEEKI1SGBL4QQSUICXwghkoQEvhBCJAkJfCGESBIS+EIIkSQk8IUQIklI4AshRJKQwBdCiCRhincHZioqKtJlZWXx7oYQQqwrH3/8cafWunix7dZU4JeVlXH+/Pl4d0MIIdYVpdSdSLaTIR0hhEgSEvhCCJEkJPCFECJJSOALIUSSkMAXQogkIYEvhBBJQgJfCCGShAT+MtztGuJUgz/e3RBCiCWRwF+Gf3/qCr/6dxdo6xuJd1eEECJiEvhLNDA6wekr7WgNdV45yxdCrB8S+Ev05uU2RicCZKeZcHt98e6OEEJETAJ/iWq9Pmy5aXx5fzkX7/bQ3D0U7y4JIUREJPCXoHdonHeudXDcbsVltwFQVy/DOkKI9UECfwleu9zK+KTG5bCxuTADx6Y83B4Z1hFCrA8S+Evg9vjYXJBB9YZcAFx2K5d8fTR1DMS5Z0IIsTgJ/Ah1DYzywc0uXA4rSikAjtutANTKbB0hxDoggR+hkw2tTAY0ztDYPYA1N50nygpkWEcIsS5I4EfI7fFRXpzJztLsWe1Oh5Xr7QM0tvbHqWdCCBEZCfwItPWNcPZ2Ny6HbWo4J+zYHisGhZzlCyHWPAn8CNR5/WjNrOGcsOLsVJ4qL6TW60NrHYfeCSFEZCTwI+D2+thlzWF7Sda8j7vsNm53DdFwr2+VeyaEEJGTwF9Ec/cQF+/24HJYF9zm6J5STAZFrZRaEEKsYRL4iwjfSeuaZzgnLC/DzLMVRdR6/TKsI4RYs2Ie+Eqp20qpeqXUJ0qp87HeX7TVen04NuWxqSDjodu5HDbu9Qxz4W7PKvVMCCGWZrXO8J/XWj+ita5Zpf1Fxa3OQRru9eGyLzycE/bCbgtmk0Fm6wgh1iwZ0nmI2lB4H48g8LPTUni+spgT9X4mA7OHdUbGJ/nb924xMj4Zk34KIUQkViPwNfC6UupjpdSXHnxQKfUlpdR5pdT5jo6OVehO5NxeH4+X5WPNTY9oe5fDRnv/KGdvdc9q//EnPv5t7WW+f+FeLLophBARWY3Af1pr/RhwDPh1pdRzMx/UWn9Xa12jta4pLi5ehe5EprG1n2ttA3zasfDF2gcd3FlChtk4Z2GU8M8yi0cIEU8xD3yttS/033bgB8ATsd5nNNR6fRgUHN2z+HBOWIbZxKFdFk41tDI+GQCgM1R0LS8jhQ+bumiXdXCFEHES08BXSmUqpbLD3wNHgIZY7jMatNa4PT72lRdRnJ26pN912a10D47xwc0uYLro2tdf3oPWcEIWTBFCxEmsz/AtwHtKKQ9wFqjTWp+K8T5X7JKvj9tdQzgjuFj7oP2VxWSnmqZm69R6fGwvycJpt7KzNFtKKQsh4iamga+1btJaO0JfVVrrb8Ryf9Hi9vgwGRRH95Qu+XdTTUaOVJXy2qVWmruHgkXX7MGiay6HjfN37uPrGY5Br4UQ4uFkWuYDtNbUev08t6OYvAzzsp7D5bDSPzLBV7/vDRZdC5VlCH9iqJOzfCFEHEjgP+DC3R7u9Qwvazgn7OntReRnpPD+jS52W3MoLw4WXdtSmIl9Y+6cWTxCCLEakjbwa70+rvjnVrd0e3yYTQZe2G1Z9nOnGA1Ts3tcD0zrdNlteFt6ud05uOznF0KI5UjKwO8eHOMr3/uEP6y7PKt9MqA5Ue/n+cpistNSVrSPzz+5mfLiTH7m0dmBH75rt05m6wghVllSBv6phlYmApoPb3bR0T861X72Vjft/aNzzsqXY8+GXE7/9oE5d+na8tKp2ZIvNXeEEKsuKQO/1usjPyOFgIaTDdNn2m6vjwyzkYM7S2K6f5fDxtXWfq63yTq4QojVk3SB3943wodNXXzhqTIqLdlTZ9rjkwFONbRyaJeFDLMppn04Vl0aXAdXZusIIVZR0gX+ifrg+rQuuxWn3cq52/fx9w7zwc0uugfHIiqFvFIl2Wns3VZIrUfWwRVCrJ6kC/xar5+dpdlUWLJxhsbq67x+3B4f2akm9leuTgE3p91GU+cgl+eZKSSEELGQVIHv6xnm/J37UxdltxZlUr0hl+9fuMdrl1o5UlVKqsm4Kn0Jr4Pr9siwjhBidSRV4IfvcJ15U5XTbuWyv4/+kYmHLlQebQWZZp6pKKLWK8M6QojVkVSB7/b6sG/MZUth5lRbeF58fkYKT28vWtX+OO02Wu4Pc7FZ1sEVQsRe0gT+7c5BvC29c0ombMzP4LOPbuBXnt5KinF1X44jVRbMRgO1MqwjhFgFSRP44Ttbnfa5N1V96397hP/nUMVqd4mctBT2VxZTV+8jEJBhHSFEbCVN4Ls9Pmq25GPLi2x92tXictho6xvl3O3uxTcWQogVSIrAv97Wz9XW/qiUTIi2w7tKSE8xysIoQoiYS4rAd3v9GFTwDte1JsNs4uCuEk7U+5kIrYMrhBCxkPCBr7Wm1uNj77ZCSrLT4t2debnsNroGx/iwqSveXRFCJLCED/xLvj6aOgfnvVi7VhyoLCYr1SSzdYQQMZXwge/2Ln992tWSlmLkyG4LJxv8jE3IsI4QIjYSOvCDwzl+nqkooiBzeevTrhaXw0bfyAQ/vd4R764IIRJUQgf+xebw+rRrdzgn7OntReSmp8hsHSFEzCR04Ls9PsxGA0eqlr8+7Woxmwwc21PK65daGRmfjHd3hBAJKGEDfzKgqfP62V9ZTM4K16ddLU67jcGxSX7S2B7vrgghElDCBv6529Fbn3a17N1WQFGWWUomCyFiImEDv9brIy3FwKEYr08bTSajgWN7rJy+2sbg6ES8uyOESDAJGfgTkwFO1AfXp81Mje36tNHmctgYGQ/w5pW2eHdFCJFgEjLwV3N92mir2ZJPaU6aDOsIIaIuIQO/1usjK9XEgcr1M5wTZjAojtutvHutg97h8Xh3RwiRQBIu8McmApxqaOXIbgtpKauzPm20uRw2xiYDvH6pdcXPdaN9gP/2/q0o9Gphr3zcwifzrNr11tU23r46d8bRJ809vPpxS0z7JISYK+EC/6fXO+gbmcC5iuvTRptjYy6bCtKjchPWn715jT9wX+ZaW38UejZX18Aov/uql39Xd2VW+2RA8zuv1PO7r3qZfGBxlz+svczvvuqle3AsJn0SQswv4QLf7fGRm57CM9uL492VZVNK4bTbeO9G54pCcXB0gtOhi7+1Hl+0ujfLyYZWJgOas7e78fcOT7Wfaeqic2CU9v5Rzt6aXtzlXs8w5+/cZyKgOdWw8k8wQojIJVTgj4xP8sblNo5WlWI2re9Dc9qtTK4wFE9fbWdkPEBRViq1Xj9aR38ZxVqvj6KsVADqZnwicXt9ZJiNocVdpv/Y1IW+D/YpNn+EhBDzW9+p+IC3r7YzODa5rm62Wshuaw7bijNxr+DM3O3xYclJ5SuHK2jqHOSSry+KPYS2vhHO3Ormf9+7mSpbDu5Q4I9PBjjZ0MoLuy0c2lXCyYbWqcVdar1+qjfk8otPbubDpi7a+0ai2ichxMISKvDdXh+FmWb2biuId1dWTCmFy27jo1vLC8Xe4XHeaezgeLWNl6qtmAwKd5TPqOu8frQOloRwOWx4mnto7h7ivRud9AyN4wq1dw+O8cHNLm53DuJt6cXlsOKyW9EaTtTL9FMhVkvMA18pdVQp1aiUuqGU+mqs9jMwOsFbV9uD4WZMjL9jLsfyQ/GNy22MTQZwOqwUZJp5ensRtZ7oDuvUen3ssuawvSSL49XBi+Rurw+3x0d2molndxSxf0cx2akm3B7f1BDOcbuNCks2O0uzpTqoEKsopsmolDIC3wGOAbuBX1BK7Y7Fvk5faWNkPJAQwzlh20uCoeheRii6PT425KXz6KY8IDjV817PMBfnmT65HC33h7hwtwdXaDbUpoIMHtucxw8v3uONS8HrKKkmY3Bxl6pSTl1q5Yef+KjZks+GvPSpPp2/cx9fz/DDdiWEiJJYnwo/AdzQWjdprceA7wEvx2JHbo+f0pw0arbkx+Lp48blsPHxnfvcW0Iodg+O8f6NTpwOK0opAI5UWTAbDVFbRjF8gdZZPf0H1mm3ca1tgP7RCZwz/vA6HVb6Rya40T6Ac8bdz+Hv6+QsX4hVEevA3wA0z/i5JdQWVb3D47xzrZ3jdisGg4r208fVdCjOHX9/u7F93lk8pxpamQhoXDMWfslJS2F/ZTG1Xt+cefF9I+N8641rDI3NLtg2MRngL05fn/cagtvrw7Epj82FGVNtx+1WlIKCTDP7ygun2p/ZXkReRgoGBS/NCPwthZnYN+ZG/dqCEGJ+sQ78+dJ3Vtoopb6klDqvlDrf0bG85f2aOgbITU+ZdfaYKLYUZuLYmDtnrDsQ0Hzt+/V89fveOevg1np9bC3KpMqWM6vd5bDR3j/K+dvds9r/8Vwzf3H6Oj/+ZHbw/vR6J9964xp/897sO3VvdQ7ScK9vTq0iS04an39yM196bhspM66jpBgN/PPnyvn8k1soyU6b3Se7DW9LL3e6BiN4NYQQKxHrwG8BNs34eSMwK1W01t/VWtdorWuKi5d3s9Sjm/M58/uHeSQ0Xp1onKFQvN05HYoX7t7H1ztCz9A479/onGpv7x/ho6YuXPbp4ZywQztLSEsxzDmjDl8jmNMemhL64Bz+8E1cx+f5A/uHP1PNl/eXz2n/1QPlfP1n9sxpDz+HXLwVIvZiHfjngAql1FallBn4eeDHsdiR0aDmBFyimA7F6UCu9fpJNRnITjPNCuqT9a0ENPNevM5MNXFol4WT9dPz4pu7h/A091CcncqHN7vo6B8FgjexvX65jeLsVO71DHPh7vTFXrfXxxNlBVhz01d8bLa8dGq25K/ofgMhRGRiGvha6wngN4DXgCvAP2qtL8Vyn4koHIrhs+DJgKbW6+fgzpLQOrhtU+vguj0+Ki3ZVFiy530ul91K1+AYHzZ1BbcP/bH445+tJqDhZENwHz9p7GBgdIKvv1yF2WSYCuTG1n6utQ1EtVaR027lams/12NU70cIERTzCeta6xNa6x1a63Kt9Tdivb9E5XLYuNraz7W2/qk6NS6HDafdxsDoBD9p7MAXqlPjekgYH6gsISs0Lx6Cs5se3ZzHwZ0WKi3Z0+2hm9gO77JwsLKEunp/6A+ND4OCY3uiF/gv2a0YFMuafiqEiFxi3KGUBI5Vl2JQwfFzt9dPhtnI85Ul7CsvpCDTTK3XNz1V0r7wvQhpKUaO7LZwqqGVK/4+rvj7pmbzOO1Wzt2+z432AU5faZu6ic3psNLRP8qZW124PT72lRdRnJ0atWMryU5j77ZCar2+mNT7EUIESeCvE+FQ/JHHx6kGPy/stpBuNobWwS3l9JV2Xvm4heoNuZQVZT70uZwOK30jE/z+D+pRavoaQXju/L9+xcPIeGBq1tPBnSVkmI1887VGbncNxWQ2lNNuo6ljkMv+6Nb7EUJMk8BfR1wOG3e6hrgfqlMzs314fJLGtv6HDueEPbO9mNz0FC7e7eGJsgIsOcGpkluLMqnekMvFuz1YclJ5vCxYkyjDbOLwLgsX7/ZgMiiO7imN+rEd3VMarPcjSzsKETMS+OvI0apgKIbr1IQ9XlZASWiI5fhDhnPCzCYDR6uCoe18YDZP+Oz9eLVt1k1s4fZnK4rIyzCv7EDmMVXvR4Z1hIgZCfx1JD/TzP/5dBlf3l9Oqml6+UajQfFrB8r5hSc2T9WpWcwXntrC42X5OKtnfyL4zKMb+NSWfH7xyc2z2vdXFvNsRRFffGbbyg9kAS6HjZb7w/MulyiEWDm1ls6mampq9Pnz5+PdDREnfSPj1Hz9Tb7w1Bb+jTMmNfaESEhKqY+11jWLbSdn+GLNmFnvJxBYOyciQiQKCXyxprgcNtr6Rjn3QL0fIcTKSeCLNSVc70dq6wgRfRL4Yk0J1/s5Ue+fqvcjhIgOCXyx5rjsNroGx/ioSYZ1hIgmCXyx5hyoLJ5V70cIER0S+GLNCdf7Odngn7O4y8DoBH908gq9w+Nx6t360NQxwLffvDZnttP9wTH+6OQVhscm49QzEU8S+GJNCtf7ee/G7FXQfnDxHn/1ThP/dL55gd8UAN95+ybffvM6F5vvz2r/+7N3+at3mmatrSCShwS+WJPC9X4erK0zXb5ZZvEsZGR8ktcvBdc6ltdPzCSBL9akcL2f1y+1Ti3u0to7wrnb3ZTmpOFp7qG5eyjOvVyb3r3WQf/oBKU5aVPrGABcb+vnams/pTlpvH+jk+7BsTj3VKw2CXyxZrkcNgbHJvlJYzsAdfV+tIZvfs4OzF2DVwS5vX4KMs383ks7p9YxCLcbFPzxz9mZDOip1c1E8pDAF2vW3m0FFGWZp4Ylar0+dltzeLaimMc250kp5XkMjU3w5uU2ju4p5cjuUjLMRtye4CL0tV4fT24t5LmKIsqLM2UWVBKSwBdrVnBxFyunr7bR2NrPxbs9U4uzO+02rvj7uNE+EOderi1vXW1neHwSl91GutnI4V3B2U7ell6aOgZxOWwopXDabZy51U1730i8uyxWkQS+WNNcDhsj4wH+9SseYEa9frsVpZDZJg9we3yUZKfyxNbg4jUuh42eoXH+zY8aZi1e43JY0To4TCaShwS+WNNqtuRTmpOGt6WXRzblsakgAwBLThpPbi3A7ZEFU8L6R8Z5u7GDl6qtGEOL1zy3o4jsNBPell6e3l5EQWZw8ZrtJdnssuZIzaIkI4Ev1jSDQU2tueuaszqXjZsdg1zx989q11rzF6evc9mXXOvjvnG5jbGJwKzXKdVk5MWq8Fn93NXNPr5zn5b7MtspWUjgizXv809uZl95IS8/Mjuwju0pxWhQc4Z1Lvn6+NYb1/iPb11fzW7GndvjY0NeOo9tzpvV/n/sK+PZiiJerLLMag+vi1wnZ/lJQwJfrHnbirP4+/97L0VZqbPaC7NS2VdeSK3XP2tYJzxd862r7QyMTqxqX+OlZ2iMn17vxGm3opSa9dieDbn8zy8+SXZayqz2zYUZODbmyrBOEpHAF+uay2HjbvcQ3pZeIDicU+vxY8tNY3QiwJuX2+Lcw9VxqqGViYCeM2yzGJfDRv29Xm51DsaoZ2ItkcAX69qLu0tJMaqpOeUXm3u41zPMb72wA1tuWtLMNa/1+ikrzKDKlrOk33sptIh9bZK8TslOAl+sa7kZKezfUUxdvZ9AQOP2+DAbDby4p5TjdivvXu+gdyixK2t29I/ywc3OqTn2S2HLS+fxsnwZ1kkSEvhi3XPabfh7Rzh7u5s6r58DlcXkpKXgctgYn9S8FioklqhONfgJ6ODrsBxOu43Gtn4aW/sX31isaxL4Yt07vNtCqsnA12sv094/OjWOXb0hl80FGQlfc8ft8bPDkkVlafayfv9YdSkGuYktKUjgi3UvK9XEoV0lXPL1kZ5i5NCuEgCUUrgcVj642UXnwGicexkb/t5hzt7unppiuRwl2Wk8Nc9sJ5F4JPBFQggPZxzaVUKG2TSrfTKgOZmgJQTCc+idS5yd8yCn3catzkEa7s2+WU1rzbffvEbDvd4VPb9YGyTwRUI4uLOEw7tK+JVnts5q31mazfaSrIRd8MPt9VNly2FrUeaKnudoVSmmBW5i+/ab1/nz08l1E1uiksAXCSEtxchf//LjPLY5f1Z7sDKklXO3u2ntTazKkM3dQ3iae5Y8934++ZlmnqkomjOsE569805jB30jiT3bKRlI4IuE57TbErIyZPhi9PHQXPqVctlt3OsZ5sLdHoCpGvob8tIZmwzw+qXkuIktkUngi4S3vSSLXdachLsJy+3x8+jm6QqiK/VClQWz0TA1rPNJcw8t94f5yuEKNuSlJ9zrl4wk8EVScDmsfJJA6+DeaB/gir9vRbNzHpSTlsKBymLqvMF1cN0e/9RNbE6HVdbBTQAxC3yl1B8ope4ppT4Jfb0Uq30JsZhwMCbKHaW1Xh9KMVU6OlpcDhvtoXVw6+p97A/fxGa3MRHQnGpI7JvYEl2sz/D/TGv9SOjrRIz3JcSCNhVk4NiUlxA3F2kdLCHxRFkBlpy0qD73oV0lpKcY+cPaK7T1jU6tMBaeCZQIr18ykyEdkTRcdiuXfH00dazvdXCvtvZzM7Q+bbRlmIM3sV3295GWYuDwrmANfaUULruVj5q6aO9PrNlOySTWgf8bSimvUupvlVL5i28uROyEhz/cnsiHdc40dfGdt2/EqkvLUuv1YTQojoXWp422qZvYdlrITJ1xE5vDRkDDiSUMi/2ksZ2/fe9W1PsolmdFga+UelMp1TDP18vAXwLlwCOAH/jTBZ7jS0qp80qp8x0dHSvpjhAPZc1N54mygiUNS/zp69f45muN3O1aGxd7g8M5fvaVF1L4wIIw0XKgspijVaV88dnZN7HtsGRTacle0nWQPzpxlW+cuEJXgpa2WG9WFPha68Na6z3zfP1Ia92mtZ7UWgeA/wI8scBzfFdrXaO1rikuLl5Jd4RYlMth5Xr7QESVIf29w5y70w1Abf3aGLuuv9fL3e6hmAznhKWlGPnPX/jUnJvYIPj6nb9zH1/P8KLPc62tn8a2fiYDmlMJXrF0vYjlLJ2Z0wc+AzTEal9CROroHisGRURzyuu8frSGjfnpSxoGiiW3x0eKUfHi7tgM5yzGuYR1cGs9PgyKpFqIZq2L5Rj+nyil6pVSXuB54LdiuC8hIlKcncq+8iLcXt+ilSHDdWp+5emtXPH3caM9vhd7AwFNrdfP/h3F5GakLP4LMVBWlEn1htxFS05rrXF7/ezdVsjnajZx5lY3bX1ysTfeYhb4WusvaK2rtdZ2rfWntdZr4xRJJD2n3cqdrqE5lSFnmlmn5rjdiloD9eIv3L2Pv3dk2QudRIvTbsXb0sudroXXwb3k6+NWZ3AmkcthRWs4kWClLdYjmZYpks7RPcHKkA87S51Zp8aSk8YTZQW4PYt/Koglt8dHqsnA4d2WuPUBpmc7Pezirdvrw2RQHK0qZXtJdkKWtliPJPBF0snLMPPcjmAJgUBg/gCvfaBOjcth42bHIFfjtAzgZEBTV9/KoV0lZM2YKhkPG/Mz+NSW/AUDXGtNrcfPMxVF5GeageCnggt3e2i5vzZmOyUrCXyRlJx2K/d6hrnYfH/OYzfaB7js75s1dHJsTylGg4rbWeqZpuCqXfEezglz2q1cbe3netvcP4AXm3u41zM8q6+uJVzsFbEjgS+S0gu7LZhNhnln30zVqZlRdrgwK5V95YURXewNGxid4Gs/qKc9Chcr3V4fmWYjz1eWrPi5ouF4dfC6xnwLy7g9PsxGA0eqpoeeNhcGS1sk+vrCa50EvkhK2WkpPF9ZTF19sDJkWLhOzeNlBZTmzq5T43LYaO4extsS2XJ/dV4ff3fmLv/rzN0V9XV8MsDJhlYO77aQbjau6LmipSQnjSe3Bm9im/kHcDKgqfP6p4quzeSyW2m4F7yYK+JDAl8kLZfDRkeoMmTYw+rUvLi7lBRj5MM64U8PtSu82PvejU56hsajWgo5GlwOG00dg1z2T892One7m/b+0Xlfv6mLvXLxNm4k8EXSOrizhAyzcdZsk4fVqcnNSGH/juCngoUu9oZ1Dozywc1ONhdk0NQ5OxSXqtbjJyfNxLM7ipb9HLFwbI8Vo0HNef3SU4wc3jV36Gm6tIWM48eLBL5IWsHKkBZO1vsZnwzMqlNTtECdGpfDhr93hI/vzr3YO9PJej8BDX/yc/bgFNBl3qk7Mj7J65daebGqlFTT2hjOCSvINPP09qKp6aoTkwFO1rdycFcJGeb5ZxI5HVYa2/ojKm0hok8CXyQ1l93K/aFxPrjZNV2n5iFDJ4d2WUg1GRYd1nF7/OywZLF3WyFPby+aM9YdqXeuddA/OhHT2jkr4bJbabk/jKellw+buugaHHvo63csVNoi3jexJSsJfJHU9lcWk51qwu3xTdepqVq4Tk1WarBe/Il6PxOTgXm3CRddCwefy2Gj5f4wnzT3LLl/tV4/BZlm9pUXLvl3V8ORqlLMRsPU65eVauJA5cJFEIuzU3mqvJBarz+uN7ElKwl8kdRSTUaOVJXyWkMrbo+f5yoWr1PjstvoHBjjzK3ueR8PF11zhs7Kj4QWB1/qsM7Q2ARvXm7j2J5STMa1+b9qbnoKz+0optbr41RDK0d2W0hLefjQk8tu41bnIJd8y7+uIZZnbf4rEmIVuRxW+kcnaO0biWjo5PmdJWSajQsOS9R6/ezZEFwSEIKLg++vLKau3rfoxd6Z3rrazvD45JodzglzOay09Y3SNxLZ0FMkpS1EbEjgi6T39PYi8jNSIq5Tk5Zi5IXdFk42tDI2MXtYp7l7iE+ae+bcEety2GjrG+Xs7bmfCv7k1FXOzvNpwe3xUZKdyuNlBUs8otV1eJeFtBQDuekpPL198ZlEeRlmnq0ootYzd1jnXs8wX33Vy+DoxKz2gdEJvvqqF3/v4nX4xcIk8EXSSzEa+JdHKvnK4R0R16lxOWz0DI3z/o3OWe0zi67NdDi0OPiDnwoaW/v5Tz+5yZ+fvjarvX9knLcbO3ipOjj1cS3LTDXxW4d38NtHdmA2RRYpLoeNez3DXLg7+7rG//jwNt8718zJhtkLptR5fXzvXDP/66M70ep2UpLAFwL4wt4t/OqB8oi3f7aimJw005xhiQeLroVlmE0c3FXCyfrWWRd7w38APrzZRUf/9DKAb1xuY2wisOaHc8L++f5yfumpsoi3D5e2mPkHMFx0DebO4gnP3ZeLvSsjgS/EMphNBo7uKeX1S22MjE8C00XXFpqW6LI2+agxAAARJ0lEQVTb6Boc48Om4J294TIOWwozCGg42TB9Udft8bEhL53HNufF/mDiYKq0hXe6tEW46NqWwgzeu97J/cExIHgT2/s3OtlSmMGdriHq70VW2kLMJYEvxDK5HDYGRid451oHMKPomt067/YHKovJSjVNncU23OvjdtcQv3agnB2WrKn2+4Nj/PR6J06HFaXW9nDOSrgcNtr7RzkXuq7h9vgwmwz8+8/amZixDu7UTWw/ayfFqORO3RWQwBdimZ7aVkhhpnnqTlO3x8cTZQVYctLm3T4txciR3RZONvgZmwhQG1ok5MWqUlx2G2dvd+PvHea1S61MBPSaq50TbQd3Bq9ruD2+qaJrB3YUs3dbAduKMqdubnN7/VSUZPHktkKeqyim1rO02U5imgS+EMtkMho4Vl3K6SvtXLjbs2DRtZlcDht9IxO8e62DWq+f53YUk5dhnpqzX+f14/b62FqUSZUtZzUOI24yzCYOh2Y7fdTUNVV0TSmF027lo6Yu6lt6OXe7e+p1dTqs+HpHuLBIaQsxPwl8IVbAabcxPD7JV1/1Llh0baantxeRm57CH5+6GlokJDj8s7Uokz0bcvj7M3f58GYXTntiD+eEOe1WugfH+IMfXyI9xcihUNE1l8NGQMO//MdPgjexhV6nw6HSFjKsszwS+EKswONlBVhyUrnePsC+8kIKFyi6FmY2GTi2p5Tr7QOYTQZemDHv32W30dQ5SECzbmbnrNT+HcHSFtfbBzg0o+hahSWbnaXZXG8foMqWw7biLCB4sffgzpI56xiIyEjgC7ECRoPiePV0zZxIhLc7WFlC9oxFQsIXeyst2eywZEe5p2tTWkqwtAXMff3CP8/X3tE/ypmmLsTSxHc1ZCESwC89tYX2/hFeqp5/ds6DntxawOc+tZFfeHLzrPaN+Rn82oFyqjfkxqKba9b/9exWJgOBOUXXPlezkUu+Xn72sY2z2p+vDK5j4Pb62RfBnb1imlpLNzHU1NTo8+fPx7sbQog17je/d5F3rnVw7muHSVmjheVWk1LqY611zWLbySslhFh3nPb5S1uIh5PAF0KsO8/tKCI7zbTslcSSlQS+EGLdSTUZebGqlNcvtTI6MRnv7qwbEvhCiHXJ5bDRPzrBO40d8e7KuiGBL4RYl/aVF5KfkYJbbsKKmAS+EGJdSjEaOFZt5c3LbQyNTSz+C0ICXwixfrlCpS3eutoe766sCxL4Qoh164mtBRRnp06VlhYPJ4EvhFi3gqUtrLzV2E7/yHi8u7PmSeALIdY1l8PK2ESANy63xbsra54EvhBiXXt0Uz4b8tKlZHIEJPCFEOuawRBcMOXdax30DI3Fuztr2ooCXyn1OaXUJaVUQClV88Bjv6eUuqGUalRKvbiybgohxMKcdhsTAc1roXVwxfxWeobfAHwWeHdmo1JqN/DzQBVwFPhPSinjCvclhBDz2rMhh7LCDKmts4gVBb7W+orWunGeh14Gvqe1HtVa3wJuAE+sZF9CCLGQ4Dq4Nj642UlH/2i8u7NmxWoMfwPQPOPnllCbEELERHgd3JMNc8/y/+qdm/zT+eY57T+8eI/vvH1jNbq3Jiwa+EqpN5VSDfN8vfywX5unbd6VVpRSX1JKnVdKne/okCJIQojlqSzNZocla85NWL3D4/zp69f45muNs9bB1Vrzzdca+bM3rnF/MDku9i4a+Frrw1rrPfN8/eghv9YCbJrx80bAt8Dzf1drXaO1rikuLp5vEyGEiIjTbuPcnW78vcNTbW9cbmNsMkB7/yjnbndPtV+428O9nmEmAppTSXKxN1ZDOj8Gfl4plaqU2gpUAGdjtC8hhADAabeiNdTNmJPv9viw5aaRnmLE7fHNajebDGzMT5/VnshWOi3zM0qpFuApoE4p9RqA1voS8I/AZeAU8Otaa1mlQAgRU9uKs6iy5UyVTO4eHOP9G518+pENHN5t4WRDKxOTASYDmhP1fp6vLOazj23ko6Yu2vtH4tz72FvpLJ0faK03aq1TtdYWrfWLMx77hta6XGtdqbU+ufKuCiHE4lwOG57mHpq7hzjV0MpEQONyWHHarXQPjvHBzS7O3uqmvX8Ul8OGy24NXuytT/xhHbnTVgiRUI5XWwFwe33Uen1sK8pktzWH/TuKyU414fYE29NTjBzcWUKFJZudpdlJMawjgS+ESCibCjJ4dHMe/3D2Lh81deF02FBKkZZi5IUqC6cutXKyoZXDuy1kmE1AcOz//J37+HqGF3n29U0CXwiRcFx2G83dwwQ0uOzW6XaHjf6RCboHx2a1O+02YPbF3kQkgS+ESDjH7VaUgp2l2VRYsqfan9leRF5GCtmpJvZXTk8DLyvKpHpDLm5v7IZ1tNb83vfr+eBmZ8z2sRhT3PYshBAxYslJ47df2MHO0pxZ7SlGA79/bBcTAU2qaXZ5L5fDyr87cZU7XYNsKcyMep8uNvfwD2fv0tw9xL7yoqg/fyTkDF8IkZB+42AFh3db5rT/s8c38YtPbp7Tfjw0rBOruvrhO4A/uNlJ50B86v1I4AshBLAhL51PbcmPyWydyYCm1uujoiQrNAU0PtcKJPCFECLEZbdytbWfG+39UX3ec7eD8/5/4+B2Kkqy4lbGWQJfCCFCXqoOXuyNdiCH5/2/sNuCyzG33s9qkcAXQoiQkpw09m4txO31ofW8BX6XbGIywMn6Vg7uKiHDbJq33s9qkcAXQogZXA4bTR2DXPFHZ1jnw6YuugbHcIUuCofr/cRj0XUJfCGEmOHonlKMBhW1Ofluj4+sVBMHZsz7d9ptfBKq97OaJPCFEGKGgkwzz2wvwu1Z+bDO2ESAUw2tHNltIS1let6/0z5d72c1SeALIcQDnHYrLfeH8bT0ruh5fnq9g76RCZwO66z2TQUZPLIpb87qXLEmgS+EEA84UlWK2WhY8Zx8t8dHbnoKz2yfu5qfy2Hjsr+Pmx0DK9rHUkjgCyHEA3LTU3huRzF1Xj+BwPKGdUbGJ3njchtHq0oxm+ZG7fHQFNDVPMuXwBdCiHm4HFZa+0Y4f+f+sn7/7avtDI5N4nLY5n28NDeNx8sKojoFdDES+EIIMY/DuyykpSx/WMft9VGUZWbvtoIFt3E5bNxoH6CxLbp39i5EAl8IIeaRmWri0E4LJxv8TEwGlvS7A6MTvHW1nWN7rJiMC8fssfAU0FVabUsCXwghFuByWOkcGOOjpu4l/d7pK22MjAcWHM4JK8pKZV95IW6Pf1WGdSTwhRBiAQcqS8g0G6ld4nx5t8dPaU4aNVvyF93WZbdxt3uI+nsrmwIaCQl8IYRYQFqKkSNVpZxsaGVsIrJhnd7hcd691sFxuxWDQS26/YtVpaQYV2dYRwJfCCEewuWw0js8zns3OiLa/rVLrYxNBqbupl1MbkYK/6xmE8XZqSvpZkRkiUMhhHiIZ7YXk5ueQq3Hz8Gdc1fQelCt18+mgnQe2ZQX8T6+8ZnqlXQxYnKGL4QQD2E2GThaVcrrl9sYGZ986LZdA6O8f6MTp92GUosP56w2CXwhhFiE02FlYHSCnzS2P3S7U5damQzoiIdzVpsEvhBCLOKpbYUUZppxL1LD3u3xsa04k93WnFXq2dJI4AshxCJMRgPHqks5faWNwdGJebdp7xvhzK3uNTucAxL4QggREZfdxsh4gDevtM37eF29H62DC6GvVRL4QggRgcfLCrDkpC64NKHb42NnaTYVluxV7lnkJPCFECICBoPieLWNdxo76B0en/VYy/0hLtztWbSUQrxJ4AshRIRcDitjkwFev9Q6q70udNa/VmfnhEngCyFEhB7ZlMfG/PQ5wzq1Xj/2jblsKcyMU88iI4EvhBARUkrhtNt470Yn3YNjANzuHKT+Xi8u+9oezgEJfCGEWBKn3cpkQHOqITisE66keXyND+eABL4QQixJlS2HbUWZU9Ut3R4/NVvyseWlx7lni1tR4CulPqeUuqSUCiilama0lymlhpVSn4S+/vPKuyqEEPGnlMLpsPHRrS7ev9FJY1v/mp+dE7bSM/wG4LPAu/M8dlNr/Ujo68sr3I8QQqwZLrsVreF3XvFiUHCsujTeXYrIisoja62vAGv2NmIhhIiFCks2O0uzudraz77yQkqy0+LdpYjEcgx/q1LqolLqHaXUszHcjxBCrLrwnHvnOpidE7boGb5S6k1gvs8rX9Na/2iBX/MDm7XWXUqpTwE/VEpVaa375nn+LwFfAti8eXPkPRdCiDj6xSe30D04zqcfWT+Br6KxUrpS6ifAv9Jan1/O42E1NTX6/PmHbiKEEOIBSqmPtdY1i20XkyEdpVSxUsoY+n4bUAE0xWJfQgghIrPSaZmfUUq1AE8BdUqp10IPPQd4lVIe4BXgy1rr7pV1VQghxEqsdJbOD4AfzNP+KvDqSp5bCCFEdMmdtkIIkSQk8IUQIklI4AshRJKQwBdCiCQhgS+EEEkiKjdeRYtSqgO4s4KnKAI6o9Sd9SIZjxmS87jlmJPHUo97i9a6eLGN1lTgr5RS6nwkd5slkmQ8ZkjO45ZjTh6xOm4Z0hFCiCQhgS+EEEki0QL/u/HuQBwk4zFDch63HHPyiMlxJ9QYvhBCiIUl2hm+EEKIBSRE4CuljiqlGpVSN5RSX413f2JBKbVJKfW2UupKaOH43wy1Fyil3lBKXQ/9Nz/efY0FpZQxtIJabejnrUqpM6Hj/v+UUuZ49zGalFJ5SqlXlFJXQ+/5U8nwXiulfiv077tBKfUPSqm0RHyvlVJ/q5RqV0o1zGib9/1VQX8RyjevUuqx5e533Qd+qO7+d4BjwG7gF5RSu+Pbq5iYAH5ba70L2Av8eug4vwqc1lpXAKdDPyei3wSuzPj5j4E/Cx33feCLcelV7Pw5cEprvRNwEDz2hH6vlVIbgH8B1Git9wBG4OdJzPf6vwFHH2hb6P09RnBNkQqCqwP+5XJ3uu4DH3gCuKG1btJajwHfA16Oc5+iTmvt11pfCH3fTzAANhA81v8e2uy/Az8Tnx7GjlJqI3Ac+OvQzwo4SHCtBUiw41ZK5RBcU+JvALTWY1rrHpLgvSZYsj1dKWUCMggul5pw77XW+l3gwTVCFnp/Xwb+hw76CMhTSlmXs99ECPwNQPOMn1tCbQlLKVUGPAqcASxaaz8E/ygAJfHrWcx8G/gdIBD6uRDo0VpPhH5OtPd8G9AB/NfQMNZfK6UySfD3Wmt9D/gPwF2CQd8LfExiv9czLfT+Ri3jEiHw1TxtCTv1SCmVRXBxma/Mtyh8olFKOYF2rfXHM5vn2TSR3nMT8Bjwl1rrR4FBEmz4Zj6hMeuXga2ADcgkOJzxoER6ryMRtX/viRD4LcCmGT9vBHxx6ktMKaVSCIb932mtvx9qbgt/vAv9tz1e/YuRp4FPK6VuExyuO0jwjD8v9LEfEu89bwFatNZnQj+/QvAPQKK/14eBW1rrDq31OPB9YB+J/V7PtND7G7WMS4TAPwdUhK7kmwle5PlxnPsUdaFx678BrmitvzXjoR8Dvxz6/peBH61232JJa/17WuuNWusygu/tW1rrzwNvAz8X2iyhjltr3Qo0K6UqQ02HgMsk+HtNcChnr1IqI/TvPXzcCfteP2Ch9/fHwC+FZuvsBXrDQz9LprVe91/AS8A14CbwtXj3J0bH+AzBj3Fe4JPQ10sEx7NPA9dD/y2Id19j+BocAGpD328DzgI3gH8CUuPdvygf6yPA+dD7/UMgPxnea+D/Ba4CDcD/BFIT8b0G/oHgdYpxgmfwX1zo/SU4pPOdUL7VE5zFtKz9yp22QgiRJBJhSEcIIUQEJPCFECJJSOALIUSSkMAXQogkIYEvhBBJQgJfCCGShAS+EEIkCQl8IYRIEv8/Llh5OOD182EAAAAASUVORK5CYII=" alt="img"></p><p>python中的axis</p><ul><li>使用0值表示沿着每一列或行标签\索引值向下执行方法</li><li>使用1值表示沿着每一行或者列标签模向执行对应的方法</li></ul><p>下图代表在DataFrame当中axis为0和1时分别代表的含义:</p><p><img src="https://upload-images.jianshu.io/upload_images/2233157-b77105789e36c847.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/652" alt="img"></p><h1>pandas的数据结构介绍</h1><h2 id="series">Series</h2><p>Series是一种类似于一维数组的对象，它由一组数据（各种NumPy数据类型）以及一组与之相关的数据标签（即索引）组成。仅由一组数据即可产生最简单的Series：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">11</span>]: obj = pd.Series([<span class="number">4</span>, <span class="number">7</span>, <span class="number">-5</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: obj</span><br><span class="line">Out[<span class="number">12</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">4</span></span><br><span class="line"><span class="number">1</span>    <span class="number">7</span></span><br><span class="line"><span class="number">2</span>   <span class="number">-5</span></span><br><span class="line"><span class="number">3</span>    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><p>Series的字符串表现形式为：索引在左边，值在右边。由于我们没有为数据指定索引，于是会自动创建一个0到N-1（N为数据的长度）的整数型索引。你可以通过Series 的values和index属性获取其数组表示形式和索引对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">13</span>]: obj.values</span><br><span class="line">Out[<span class="number">13</span>]: array([ <span class="number">4</span>,  <span class="number">7</span>, <span class="number">-5</span>,  <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: obj.index  <span class="comment"># like range(4)</span></span><br><span class="line">Out[<span class="number">14</span>]: RangeIndex(start=<span class="number">0</span>, stop=<span class="number">4</span>, step=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>通常，我们希望所创建的Series带有一个可以对各个数据点进行标记的索引：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">15</span>]: obj2 = pd.Series([<span class="number">4</span>, <span class="number">7</span>, <span class="number">-5</span>, <span class="number">3</span>], index=[<span class="string">'d'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: obj2</span><br><span class="line">Out[<span class="number">16</span>]: </span><br><span class="line">d    <span class="number">4</span></span><br><span class="line">b    <span class="number">7</span></span><br><span class="line">a   <span class="number">-5</span></span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: obj2.index</span><br><span class="line">Out[<span class="number">17</span>]: Index([<span class="string">'d'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>], dtype=<span class="string">'object'</span>)</span><br></pre></td></tr></table></figure><p>与普通NumPy数组相比，你可以通过索引的方式选取Series中的单个或一组值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">18</span>]: obj2[<span class="string">'a'</span>]</span><br><span class="line">Out[<span class="number">18</span>]: <span class="number">-5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: obj2[<span class="string">'d'</span>] = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: obj2[[<span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'d'</span>]]</span><br><span class="line">Out[<span class="number">20</span>]: </span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">a   <span class="number">-5</span></span><br><span class="line">d    <span class="number">6</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><p>[‘c’, ‘a’, ‘d’]是索引列表，即使它包含的是字符串而不是整数。</p><p>使用NumPy函数或类似NumPy的运算（如根据布尔型数组进行过滤、标量乘法、应用数学函数等）都会保留索引值的链接：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">21</span>]: obj2[obj2 &gt; <span class="number">0</span>]</span><br><span class="line">Out[<span class="number">21</span>]: </span><br><span class="line">d    <span class="number">6</span></span><br><span class="line">b    <span class="number">7</span></span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: obj2 * <span class="number">2</span></span><br><span class="line">Out[<span class="number">22</span>]:</span><br><span class="line">d    <span class="number">12</span></span><br><span class="line">b    <span class="number">14</span></span><br><span class="line">a   <span class="number">-10</span></span><br><span class="line">c     <span class="number">6</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: np.exp(obj2)</span><br><span class="line">Out[<span class="number">23</span>]: </span><br><span class="line">d     <span class="number">403.428793</span></span><br><span class="line">b    <span class="number">1096.633158</span></span><br><span class="line">a       <span class="number">0.006738</span></span><br><span class="line">c      <span class="number">20.085537</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>还可以将Series看成是一个定长的有序字典，因为它是索引值到数据值的一个映射。它可以用在许多原本需要字典参数的函数中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">24</span>]: <span class="string">'b'</span> <span class="keyword">in</span> obj2</span><br><span class="line">Out[<span class="number">24</span>]: <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: <span class="string">'e'</span> <span class="keyword">in</span> obj2</span><br><span class="line">Out[<span class="number">25</span>]: <span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>如果数据被存放在一个Python字典中，也可以直接通过这个字典来创建Series：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">26</span>]: sdata = &#123;<span class="string">'Ohio'</span>: <span class="number">35000</span>, <span class="string">'Texas'</span>: <span class="number">71000</span>, <span class="string">'Oregon'</span>: <span class="number">16000</span>, <span class="string">'Utah'</span>: <span class="number">5000</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: obj3 = pd.Series(sdata)</span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: obj3</span><br><span class="line">Out[<span class="number">28</span>]: </span><br><span class="line">Ohio      <span class="number">35000</span></span><br><span class="line">Oregon    <span class="number">16000</span></span><br><span class="line">Texas     <span class="number">71000</span></span><br><span class="line">Utah       <span class="number">5000</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><p>如果只传入一个字典，则结果Series中的索引就是原字典的键（有序排列）。你可以传入排好序的字典的键以改变顺序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">29</span>]: states = [<span class="string">'California'</span>, <span class="string">'Ohio'</span>, <span class="string">'Oregon'</span>, <span class="string">'Texas'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: obj4 = pd.Series(sdata, index=states)</span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: obj4</span><br><span class="line">Out[<span class="number">31</span>]: </span><br><span class="line">California        NaN</span><br><span class="line">Ohio          <span class="number">35000.0</span></span><br><span class="line">Oregon        <span class="number">16000.0</span></span><br><span class="line">Texas         <span class="number">71000.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>在这个例子中，sdata中跟states索引相匹配的那3个值会被找出来并放到相应的位置上，但由于&quot;California&quot;所对应的sdata值找不到，所以其结果就为NaN（即“非数字”（not a number），在pandas中，它用于表示缺失或NA值）。因为‘Utah’不在states中，它被从结果中除去。</p><p>我将使用缺失（missing）或NA表示缺失数据。pandas的isnull和notnull函数可用于检测缺失数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">32</span>]: pd.isnull(obj4)</span><br><span class="line">Out[<span class="number">32</span>]: </span><br><span class="line">California     <span class="keyword">True</span></span><br><span class="line">Ohio          <span class="keyword">False</span></span><br><span class="line">Oregon        <span class="keyword">False</span></span><br><span class="line">Texas         <span class="keyword">False</span></span><br><span class="line">dtype: bool</span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: pd.notnull(obj4)</span><br><span class="line">Out[<span class="number">33</span>]: </span><br><span class="line">California    <span class="keyword">False</span></span><br><span class="line">Ohio           <span class="keyword">True</span></span><br><span class="line">Oregon         <span class="keyword">True</span></span><br><span class="line">Texas          <span class="keyword">True</span></span><br><span class="line">dtype: bool</span><br></pre></td></tr></table></figure><p>Series也有类似的实例方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">34</span>]: obj4.isnull()</span><br><span class="line">Out[<span class="number">34</span>]: </span><br><span class="line">California     <span class="keyword">True</span></span><br><span class="line">Ohio          <span class="keyword">False</span></span><br><span class="line">Oregon        <span class="keyword">False</span></span><br><span class="line">Texas         <span class="keyword">False</span></span><br><span class="line">dtype: bool</span><br></pre></td></tr></table></figure><p>对于许多应用而言，Series最重要的一个功能是，它会根据运算的索引标签自动对齐数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">35</span>]: obj3</span><br><span class="line">Out[<span class="number">35</span>]: </span><br><span class="line">Ohio      <span class="number">35000</span></span><br><span class="line">Oregon    <span class="number">16000</span></span><br><span class="line">Texas     <span class="number">71000</span></span><br><span class="line">Utah       <span class="number">5000</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: obj4</span><br><span class="line">Out[<span class="number">36</span>]: </span><br><span class="line">California        NaN</span><br><span class="line">Ohio          <span class="number">35000.0</span></span><br><span class="line">Oregon        <span class="number">16000.0</span></span><br><span class="line">Texas         <span class="number">71000.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: obj3 + obj4</span><br><span class="line">Out[<span class="number">37</span>]: </span><br><span class="line">California         NaN</span><br><span class="line">Ohio           <span class="number">70000.0</span></span><br><span class="line">Oregon         <span class="number">32000.0</span></span><br><span class="line">Texas         <span class="number">142000.0</span></span><br><span class="line">Utah               NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>Series对象本身及其索引都有一个name属性，该属性跟pandas其他的关键功能关系非常密切：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">38</span>]: obj4.name = <span class="string">'population'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: obj4.index.name = <span class="string">'state'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: obj4</span><br><span class="line">Out[<span class="number">40</span>]: </span><br><span class="line">state</span><br><span class="line">California        NaN</span><br><span class="line">Ohio          <span class="number">35000.0</span></span><br><span class="line">Oregon        <span class="number">16000.0</span></span><br><span class="line">Texas         <span class="number">71000.0</span></span><br><span class="line">Name: population, dtype: float64</span><br></pre></td></tr></table></figure><p>Series的索引可以通过赋值的方式就地修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">41</span>]: obj</span><br><span class="line">Out[<span class="number">41</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">4</span></span><br><span class="line"><span class="number">1</span>    <span class="number">7</span></span><br><span class="line"><span class="number">2</span>   <span class="number">-5</span></span><br><span class="line"><span class="number">3</span>    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: obj.index = [<span class="string">'Bob'</span>, <span class="string">'Steve'</span>, <span class="string">'Jeff'</span>, <span class="string">'Ryan'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: obj</span><br><span class="line">Out[<span class="number">43</span>]: </span><br><span class="line">Bob      <span class="number">4</span></span><br><span class="line">Steve    <span class="number">7</span></span><br><span class="line">Jeff    <span class="number">-5</span></span><br><span class="line">Ryan     <span class="number">3</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><h2 id="dataframe">DataFrame</h2><p>DataFrame是一个表格型的数据结构，它含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔值等）。DataFrame既有行索引也有列索引，它可以被看做由Series组成的字典（共用同一个索引）。DataFrame中的数据是以一个或多个二维块存放的（而不是列表、字典或别的一维数据结构）。</p><p>建DataFrame的办法有很多，最常用的一种是直接传入一个由等长列表或NumPy数组组成的字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;<span class="string">'state'</span>: [<span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Nevada'</span>, <span class="string">'Nevada'</span>, <span class="string">'Nevada'</span>],</span><br><span class="line">        <span class="string">'year'</span>: [<span class="number">2000</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2003</span>],</span><br><span class="line">        <span class="string">'pop'</span>: [<span class="number">1.5</span>, <span class="number">1.7</span>, <span class="number">3.6</span>, <span class="number">2.4</span>, <span class="number">2.9</span>, <span class="number">3.2</span>]&#125;</span><br><span class="line">frame = pd.DataFrame(data)</span><br></pre></td></tr></table></figure><p>结果DataFrame会自动加上索引（跟Series一样），且全部列会被有序排列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">45</span>]: frame</span><br><span class="line">Out[<span class="number">45</span>]: </span><br><span class="line">   pop   state  year</span><br><span class="line"><span class="number">0</span>  <span class="number">1.5</span>    Ohio  <span class="number">2000</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1.7</span>    Ohio  <span class="number">2001</span></span><br><span class="line"><span class="number">2</span>  <span class="number">3.6</span>    Ohio  <span class="number">2002</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2.4</span>  Nevada  <span class="number">2001</span></span><br><span class="line"><span class="number">4</span>  <span class="number">2.9</span>  Nevada  <span class="number">2002</span></span><br><span class="line"><span class="number">5</span>  <span class="number">3.2</span>  Nevada  <span class="number">2003</span></span><br></pre></td></tr></table></figure><p>通过类似字典标记的方式或属性的方式，可以将DataFrame的列获取为一个Series：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">51</span>]: frame2[<span class="string">'state'</span>]</span><br><span class="line">Out[<span class="number">51</span>]: </span><br><span class="line">one        Ohio</span><br><span class="line">two        Ohio</span><br><span class="line">three      Ohio</span><br><span class="line">four     Nevada</span><br><span class="line">five     Nevada</span><br><span class="line">six      Nevada</span><br><span class="line">Name: state, dtype: object</span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: frame2.year</span><br><span class="line">Out[<span class="number">52</span>]: </span><br><span class="line">one      <span class="number">2000</span></span><br><span class="line">two      <span class="number">2001</span></span><br><span class="line">three    <span class="number">2002</span></span><br><span class="line">four     <span class="number">2001</span></span><br><span class="line">five     <span class="number">2002</span></span><br><span class="line">six      <span class="number">2003</span></span><br><span class="line">Name: year, dtype: int64</span><br></pre></td></tr></table></figure><p>del方法可以用来删除这列(不能删除行⚠️)</p><p>对于DataFrame，可以删除任意轴上的索引值</p><p>用drop会从行标签（axis 0）删除值</p><p>axis=1或axis='columns’可以删除列的值</p><h2 id="基本功能">基本功能</h2><h3 id="重新索引">重新索引</h3><p>pandas对象的一个重要方法是reindex，其作用是创建一个新对象，它的数据符合新的索引。看下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">91</span>]: obj = pd.Series([<span class="number">4.5</span>, <span class="number">7.2</span>, <span class="number">-5.3</span>, <span class="number">3.6</span>], index=[<span class="string">'d'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">92</span>]: obj</span><br><span class="line">Out[<span class="number">92</span>]: </span><br><span class="line">d    <span class="number">4.5</span></span><br><span class="line">b    <span class="number">7.2</span></span><br><span class="line">a   <span class="number">-5.3</span></span><br><span class="line">c    <span class="number">3.6</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>用该Series的reindex将会根据新索引进行重排。如果某个索引值当前不存在，就引入缺失值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">93</span>]: obj2 = obj.reindex([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">94</span>]: obj2</span><br><span class="line">Out[<span class="number">94</span>]: </span><br><span class="line">a   <span class="number">-5.3</span></span><br><span class="line">b    <span class="number">7.2</span></span><br><span class="line">c    <span class="number">3.6</span></span><br><span class="line">d    <span class="number">4.5</span></span><br><span class="line">e    NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><h3 id="索引-选取和过滤">索引、选取和过滤</h3><p>Series索引（obj[…]）的工作方式类似于NumPy数组的索引，只不过Series的索引值不只是整数。下面是几个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">117</span>]: obj = pd.Series(np.arange(<span class="number">4.</span>), index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">118</span>]: obj</span><br><span class="line">Out[<span class="number">118</span>]: </span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">c    <span class="number">2.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">119</span>]: obj[<span class="string">'b'</span>]</span><br><span class="line">Out[<span class="number">119</span>]: <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">120</span>]: obj[<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">120</span>]: <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">121</span>]: obj[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">Out[<span class="number">121</span>]: </span><br><span class="line">c    <span class="number">2.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">122</span>]: obj[[<span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'d'</span>]]</span><br><span class="line">Out[<span class="number">122</span>]:</span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">123</span>]: obj[[<span class="number">1</span>, <span class="number">3</span>]]</span><br><span class="line">Out[<span class="number">123</span>]: </span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">124</span>]: obj[obj &lt; <span class="number">2</span>]</span><br><span class="line">Out[<span class="number">124</span>]: </span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>利用标签的切片运算<strong>与普通的Python切片运算不同，其末端是包含的：</strong>⚠️</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">125</span>]: obj[<span class="string">'b'</span>:<span class="string">'c'</span>]</span><br><span class="line">Out[<span class="number">125</span>]:</span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">c    <span class="number">2.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><h3 id="布尔类型数组的索引方法">布尔类型数组的索引方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">arr=np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: arr</span><br><span class="line"></span><br><span class="line">Out[<span class="number">4</span>]: </span><br><span class="line"></span><br><span class="line">array([[ <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line"></span><br><span class="line">[ <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>],</span><br><span class="line"></span><br><span class="line">[ <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"></span><br><span class="line">bioom = (arr&gt;<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">bloom</span><br><span class="line"></span><br><span class="line">Out[<span class="number">99</span>]: </span><br><span class="line"></span><br><span class="line">array([[<span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span>],</span><br><span class="line"></span><br><span class="line">[<span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">True</span>, <span class="keyword">True</span>],</span><br><span class="line"></span><br><span class="line">[ <span class="keyword">True</span>, <span class="keyword">True</span>, <span class="keyword">True</span>, <span class="keyword">True</span>]], dtype=bool)</span><br></pre></td></tr></table></figure><p>另一种用法是通过布尔型DataFrame（比如下面这个由标量比较运算得出的）进行索引：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">134</span>]: data &lt; <span class="number">5</span></span><br><span class="line">Out[<span class="number">134</span>]: </span><br><span class="line">            one    two  three   four</span><br><span class="line">Ohio       <span class="keyword">True</span>   <span class="keyword">True</span>   <span class="keyword">True</span>   <span class="keyword">True</span></span><br><span class="line">Colorado   <span class="keyword">True</span>  <span class="keyword">False</span>  <span class="keyword">False</span>  <span class="keyword">False</span></span><br><span class="line">Utah      <span class="keyword">False</span>  <span class="keyword">False</span>  <span class="keyword">False</span>  <span class="keyword">False</span></span><br><span class="line">New York  <span class="keyword">False</span>  <span class="keyword">False</span>  <span class="keyword">False</span>  <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">135</span>]: data[data &lt; <span class="number">5</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">136</span>]: data</span><br><span class="line">Out[<span class="number">136</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Ohio        <span class="number">0</span>    <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">Colorado    <span class="number">0</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span>    <span class="number">15</span></span><br></pre></td></tr></table></figure><h3 id="用loc和iloc进行选取-前者用标签-后者是数字">用loc和iloc进行选取（前者用标签，后者是数字）</h3><p>对于DataFrame的行的标签索引，我引入了特殊的标签运算符loc和iloc。它们可以让你用类似NumPy的标记，使用轴标签（loc）或整数索引（iloc），从DataFrame选择行和列的子集。</p><p>作为一个初步示例，让我们通过标签选择一行和多列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">137</span>]: data.loc[<span class="string">'Colorado'</span>, [<span class="string">'two'</span>, <span class="string">'three'</span>]]</span><br><span class="line">Out[<span class="number">137</span>]: </span><br><span class="line">two      <span class="number">5</span></span><br><span class="line">three    <span class="number">6</span></span><br><span class="line">Name: Colorado, dtype: int64</span><br></pre></td></tr></table></figure><p>然后用iloc和整数进行选取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">138</span>]: data.iloc[<span class="number">2</span>, [<span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>]]<span class="comment">#2为行，3，0，1为列</span></span><br><span class="line">Out[<span class="number">138</span>]: </span><br><span class="line">four    <span class="number">11</span></span><br><span class="line">one      <span class="number">8</span></span><br><span class="line">two      <span class="number">9</span></span><br><span class="line">Name: Utah, dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">139</span>]: data.iloc[<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">139</span>]: </span><br><span class="line">one       <span class="number">8</span></span><br><span class="line">two       <span class="number">9</span></span><br><span class="line">three    <span class="number">10</span></span><br><span class="line">four     <span class="number">11</span></span><br><span class="line">Name: Utah, dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">140</span>]: data.iloc[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line">Out[<span class="number">140</span>]: </span><br><span class="line">          four  one  two</span><br><span class="line">Colorado     <span class="number">7</span>    <span class="number">0</span>    <span class="number">5</span></span><br><span class="line">Utah        <span class="number">11</span>    <span class="number">8</span>    <span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="算术运算和数据对齐">算术运算和数据对齐</h3><p>对于DataFrame，对齐操作会同时发生在行和列上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">155</span>]: df1 = pd.DataFrame(np.arange(<span class="number">9.</span>).reshape((<span class="number">3</span>, <span class="number">3</span>)), columns=list(<span class="string">'bcd'</span>),</span><br><span class="line">   .....:                    index=[<span class="string">'Ohio'</span>, <span class="string">'Texas'</span>, <span class="string">'Colorado'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">156</span>]: df2 = pd.DataFrame(np.arange(<span class="number">12.</span>).reshape((<span class="number">4</span>, <span class="number">3</span>)), columns=list(<span class="string">'bde'</span>),</span><br><span class="line">   .....:                    index=[<span class="string">'Utah'</span>, <span class="string">'Ohio'</span>, <span class="string">'Texas'</span>, <span class="string">'Oregon'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">157</span>]: df1</span><br><span class="line">Out[<span class="number">157</span>]: </span><br><span class="line">            b    c    d</span><br><span class="line">Ohio      <span class="number">0.0</span>  <span class="number">1.0</span>  <span class="number">2.0</span></span><br><span class="line">Texas     <span class="number">3.0</span>  <span class="number">4.0</span>  <span class="number">5.0</span></span><br><span class="line">Colorado  <span class="number">6.0</span>  <span class="number">7.0</span>  <span class="number">8.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">158</span>]: df2</span><br><span class="line">Out[<span class="number">158</span>]: </span><br><span class="line">          b     d     e</span><br><span class="line">Utah    <span class="number">0.0</span>   <span class="number">1.0</span>   <span class="number">2.0</span></span><br><span class="line">Ohio    <span class="number">3.0</span>   <span class="number">4.0</span>   <span class="number">5.0</span></span><br><span class="line">Texas   <span class="number">6.0</span>   <span class="number">7.0</span>   <span class="number">8.0</span></span><br><span class="line">Oregon  <span class="number">9.0</span>  <span class="number">10.0</span>  <span class="number">11.0</span></span><br></pre></td></tr></table></figure><p>把它们相加后将会返回一个新的DataFrame，其索引和列为原来那两个DataFrame的并集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">159</span>]: df1 + df2</span><br><span class="line">Out[<span class="number">159</span>]: </span><br><span class="line">            b   c     d   e</span><br><span class="line">Colorado  NaN NaN   NaN NaN</span><br><span class="line">Ohio      <span class="number">3.0</span> NaN   <span class="number">6.0</span> NaN</span><br><span class="line">Oregon    NaN NaN   NaN NaN</span><br><span class="line">Texas     <span class="number">9.0</span> NaN  <span class="number">12.0</span> NaN</span><br><span class="line">Utah      NaN NaN   NaN NaN</span><br></pre></td></tr></table></figure><p>因为’c’和’e’列均不在两个DataFrame对象中，在结果中以缺省值呈现。行也是同样。</p><p>如果DataFrame对象相加，<strong>没有共用的列或行标签，结果都会是空</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">160</span>]: df1 = pd.DataFrame(&#123;<span class="string">'A'</span>: [<span class="number">1</span>, <span class="number">2</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">161</span>]: df2 = pd.DataFrame(&#123;<span class="string">'B'</span>: [<span class="number">3</span>, <span class="number">4</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">162</span>]: df1</span><br><span class="line">Out[<span class="number">162</span>]: </span><br><span class="line">   A</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">163</span>]: df2</span><br><span class="line">Out[<span class="number">163</span>]: </span><br><span class="line">   B</span><br><span class="line"><span class="number">0</span>  <span class="number">3</span></span><br><span class="line"><span class="number">1</span>  <span class="number">4</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">164</span>]: df1 - df2</span><br><span class="line">Out[<span class="number">164</span>]: </span><br><span class="line">    A   B</span><br><span class="line"><span class="number">0</span> NaN NaN</span><br><span class="line"><span class="number">1</span> NaN NaN</span><br></pre></td></tr></table></figure><h3 id="dataframe和series之间的运算">DataFrame和Series之间的运算</h3><p>跟不同维度的NumPy数组一样，DataFrame和Series之间算术运算也是有明确规定的。先来看一个具有启发性的例子，计算一个二维数组与其某行之间的差：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">175</span>]: arr = np.arange(<span class="number">12.</span>).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">176</span>]: arr</span><br><span class="line">Out[<span class="number">176</span>]: </span><br><span class="line">array([[  <span class="number">0.</span>,   <span class="number">1.</span>,   <span class="number">2.</span>,   <span class="number">3.</span>],</span><br><span class="line">       [  <span class="number">4.</span>,   <span class="number">5.</span>,   <span class="number">6.</span>,   <span class="number">7.</span>],</span><br><span class="line">       [  <span class="number">8.</span>,   <span class="number">9.</span>,  <span class="number">10.</span>,  <span class="number">11.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">177</span>]: arr[<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">177</span>]: array([ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">178</span>]: arr - arr[<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">178</span>]: </span><br><span class="line">array([[ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">4.</span>,  <span class="number">4.</span>,  <span class="number">4.</span>,  <span class="number">4.</span>],</span><br><span class="line">       [ <span class="number">8.</span>,  <span class="number">8.</span>,  <span class="number">8.</span>,  <span class="number">8.</span>]])</span><br></pre></td></tr></table></figure><p>当我们从arr减去arr[0]，每一行都会执行这个操作。这就叫做广播（broadcasting）</p><p>如果某个索引值在DataFrame的列或Series的索引中找不到，则参与运算的两个对象就会被重新索引以形成并集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">184</span>]: series2 = pd.Series(range(<span class="number">3</span>), index=[<span class="string">'b'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">185</span>]: frame + series2</span><br><span class="line">Out[<span class="number">185</span>]: </span><br><span class="line">          b   d     e   f</span><br><span class="line">Utah    <span class="number">0.0</span> NaN   <span class="number">3.0</span> NaN</span><br><span class="line">Ohio    <span class="number">3.0</span> NaN   <span class="number">6.0</span> NaN</span><br><span class="line">Texas   <span class="number">6.0</span> NaN   <span class="number">9.0</span> NaN</span><br><span class="line">Oregon  <span class="number">9.0</span> NaN  <span class="number">12.0</span> NaN</span><br></pre></td></tr></table></figure><p>如果你希望匹配行且在列上广播，则必须使用算术运算方法。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">186</span>]: series3 = frame[<span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">187</span>]: frame</span><br><span class="line">Out[<span class="number">187</span>]: </span><br><span class="line">          b     d     e</span><br><span class="line">Utah    <span class="number">0.0</span>   <span class="number">1.0</span>   <span class="number">2.0</span></span><br><span class="line">Ohio    <span class="number">3.0</span>   <span class="number">4.0</span>   <span class="number">5.0</span></span><br><span class="line">Texas   <span class="number">6.0</span>   <span class="number">7.0</span>   <span class="number">8.0</span></span><br><span class="line">Oregon  <span class="number">9.0</span>  <span class="number">10.0</span>  <span class="number">11.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">188</span>]: series3</span><br><span class="line">Out[<span class="number">188</span>]: </span><br><span class="line">Utah       <span class="number">1.0</span></span><br><span class="line">Ohio       <span class="number">4.0</span></span><br><span class="line">Texas      <span class="number">7.0</span></span><br><span class="line">Oregon    <span class="number">10.0</span></span><br><span class="line">Name: d, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">189</span>]: frame.sub(series3, axis=<span class="string">'index'</span>)</span><br><span class="line">Out[<span class="number">189</span>]: </span><br><span class="line">          b    d    e</span><br><span class="line">Utah   <span class="number">-1.0</span>  <span class="number">0.0</span>  <span class="number">1.0</span></span><br><span class="line">Ohio   <span class="number">-1.0</span>  <span class="number">0.0</span>  <span class="number">1.0</span></span><br><span class="line">Texas  <span class="number">-1.0</span>  <span class="number">0.0</span>  <span class="number">1.0</span></span><br><span class="line">Oregon <span class="number">-1.0</span>  <span class="number">0.0</span>  <span class="number">1.0</span></span><br></pre></td></tr></table></figure><p>传入的轴号就是希望匹配的轴。在本例中，我们的目的是匹配DataFrame的行索引（axis=‘index’ or axis=0）并进行广播。</p><h3 id="函数应用和映射">函数应用和映射</h3><p>NumPy的ufuncs（元素级数组方法）也可用于操作pandas对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">190</span>]: frame = pd.DataFrame(np.random.randn(<span class="number">4</span>, <span class="number">3</span>), columns=list(<span class="string">'bde'</span>),</span><br><span class="line">   .....:                      index=[<span class="string">'Utah'</span>, <span class="string">'Ohio'</span>, <span class="string">'Texas'</span>, <span class="string">'Oregon'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">191</span>]: frame</span><br><span class="line">Out[<span class="number">191</span>]: </span><br><span class="line">               b         d         e</span><br><span class="line">Utah   <span class="number">-0.204708</span>  <span class="number">0.478943</span> <span class="number">-0.519439</span></span><br><span class="line">Ohio   <span class="number">-0.555730</span>  <span class="number">1.965781</span>  <span class="number">1.393406</span></span><br><span class="line">Texas   <span class="number">0.092908</span>  <span class="number">0.281746</span>  <span class="number">0.769023</span></span><br><span class="line">Oregon  <span class="number">1.246435</span>  <span class="number">1.007189</span> <span class="number">-1.296221</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">192</span>]: np.abs(frame)</span><br><span class="line">Out[<span class="number">192</span>]: </span><br><span class="line">               b         d         e</span><br><span class="line">Utah    <span class="number">0.204708</span>  <span class="number">0.478943</span>  <span class="number">0.519439</span></span><br><span class="line">Ohio    <span class="number">0.555730</span>  <span class="number">1.965781</span>  <span class="number">1.393406</span></span><br><span class="line">Texas   <span class="number">0.092908</span>  <span class="number">0.281746</span>  <span class="number">0.769023</span></span><br><span class="line">Oregon  <span class="number">1.246435</span>  <span class="number">1.007189</span>  <span class="number">1.296221</span></span><br></pre></td></tr></table></figure><p>另一个常见的操作是，将函数应用到由各列或行所形成的一维数组上。DataFrame的apply方法即可实现此功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">193</span>]: f = <span class="keyword">lambda</span> x: x.max() - x.min()</span><br><span class="line"></span><br><span class="line">In [<span class="number">194</span>]: frame.apply(f)</span><br><span class="line">Out[<span class="number">194</span>]: </span><br><span class="line">b    <span class="number">1.802165</span></span><br><span class="line">d    <span class="number">1.684034</span></span><br><span class="line">e    <span class="number">2.689627</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>这里的函数f，计算了一个Series的最大值和最小值的差，在frame的每列都执行了一次。结果是一个Series，使用frame的列作为索引。</p><p>如果传递axis='columns’到apply，这个函数会在每行执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">195</span>]: frame.apply(f, axis=<span class="string">'columns'</span>)</span><br><span class="line">Out[<span class="number">195</span>]:</span><br><span class="line">Utah      <span class="number">0.998382</span></span><br><span class="line">Ohio      <span class="number">2.521511</span></span><br><span class="line">Texas     <span class="number">0.676115</span></span><br><span class="line">Oregon    <span class="number">2.542656</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>许多最为常见的数组统计功能都被实现成DataFrame的方法（如sum和mean），因此无需使用apply方法。</p><p>传递到apply的函数不是必须返回一个标量，还可以返回由多个值组成的Series：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">196</span>]: <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">   .....:     <span class="keyword">return</span> pd.Series([x.min(), x.max()], index=[<span class="string">'min'</span>, <span class="string">'max'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">197</span>]: frame.apply(f)</span><br><span class="line">Out[<span class="number">197</span>]: </span><br><span class="line">            b         d         e</span><br><span class="line">min <span class="number">-0.555730</span>  <span class="number">0.281746</span> <span class="number">-1.296221</span></span><br><span class="line">max  <span class="number">1.246435</span>  <span class="number">1.965781</span>  <span class="number">1.393406</span></span><br></pre></td></tr></table></figure><p>元素级的Python函数也是可以用的。假如你想得到frame中各个浮点值的格式化字符串，使用applymap即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">198</span>]: format = <span class="keyword">lambda</span> x: <span class="string">'%.2f'</span> % x</span><br><span class="line"></span><br><span class="line">In [<span class="number">199</span>]: frame.applymap(format)</span><br><span class="line">Out[<span class="number">199</span>]: </span><br><span class="line">            b     d      e</span><br><span class="line">Utah    <span class="number">-0.20</span>  <span class="number">0.48</span>  <span class="number">-0.52</span></span><br><span class="line">Ohio    <span class="number">-0.56</span>  <span class="number">1.97</span>   <span class="number">1.39</span></span><br><span class="line">Texas    <span class="number">0.09</span>  <span class="number">0.28</span>   <span class="number">0.77</span></span><br><span class="line">Oregon   <span class="number">1.25</span>  <span class="number">1.01</span>  <span class="number">-1.30</span></span><br></pre></td></tr></table></figure><p>之所以叫做applymap，是因为Series有一个用于应用元素级函数的map方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">200</span>]: frame[<span class="string">'e'</span>].map(format)</span><br><span class="line">Out[<span class="number">200</span>]: </span><br><span class="line">Utah      <span class="number">-0.52</span></span><br><span class="line">Ohio       <span class="number">1.39</span></span><br><span class="line">Texas      <span class="number">0.77</span></span><br><span class="line">Oregon    <span class="number">-1.30</span></span><br><span class="line">Name: e, dtype: object</span><br></pre></td></tr></table></figure><p>排序和排名</p><p>根据条件对数据集排序（sorting）也是一种重要的内置运算。要对行或列索引进行排序（按字典顺序），可使用sort_index方法，它将返回一个已排序的新对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">201</span>]: obj = pd.Series(range(<span class="number">4</span>), index=[<span class="string">'d'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">202</span>]: obj.sort_index()</span><br><span class="line">Out[<span class="number">202</span>]:</span><br><span class="line">a    <span class="number">1</span></span><br><span class="line">b    <span class="number">2</span></span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">d    <span class="number">0</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><p>对于DataFrame，则可以根据任意一个轴上的索引进行排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">203</span>]: frame = pd.DataFrame(np.arange(<span class="number">8</span>).reshape((<span class="number">2</span>, <span class="number">4</span>)),</span><br><span class="line">   .....:                      index=[<span class="string">'three'</span>, <span class="string">'one'</span>],</span><br><span class="line">   .....:                      columns=[<span class="string">'d'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">204</span>]: frame.sort_index()</span><br><span class="line">Out[<span class="number">204</span>]: </span><br><span class="line">       d  a  b  c</span><br><span class="line">one    <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span></span><br><span class="line">three  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">205</span>]: frame.sort_index(axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">205</span>]:</span><br><span class="line">       a  b  c  d</span><br><span class="line">three  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">0</span></span><br><span class="line">one    <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">4</span></span><br></pre></td></tr></table></figure><p>数据默认是按升序排序的，但也可以降序排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">206</span>]: frame.sort_index(axis=<span class="number">1</span>, ascending=<span class="keyword">False</span>)</span><br><span class="line">Out[<span class="number">206</span>]: </span><br><span class="line">       d  c  b  a</span><br><span class="line">three  <span class="number">0</span>  <span class="number">3</span>  <span class="number">2</span>  <span class="number">1</span></span><br><span class="line">one    <span class="number">4</span>  <span class="number">7</span>  <span class="number">6</span>  <span class="number">5</span></span><br></pre></td></tr></table></figure><p>若要按值对Series进行排序，可使用其sort_values方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">207</span>]: obj = pd.Series([<span class="number">4</span>, <span class="number">7</span>, <span class="number">-3</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">208</span>]: obj.sort_values()</span><br><span class="line">Out[<span class="number">208</span>]: </span><br><span class="line"><span class="number">2</span>   <span class="number">-3</span></span><br><span class="line"><span class="number">3</span>    <span class="number">2</span></span><br><span class="line"><span class="number">0</span>    <span class="number">4</span></span><br><span class="line"><span class="number">1</span>    <span class="number">7</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><p>在排序时，任何缺失值默认都会被放到Series的末尾：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">209</span>]: obj = pd.Series([<span class="number">4</span>, np.nan, <span class="number">7</span>, np.nan, <span class="number">-3</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">210</span>]: obj.sort_values()</span><br><span class="line">Out[<span class="number">210</span>]: </span><br><span class="line"><span class="number">4</span>   <span class="number">-3.0</span></span><br><span class="line"><span class="number">5</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">0</span>    <span class="number">4.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">7.0</span></span><br><span class="line"><span class="number">1</span>    NaN</span><br><span class="line"><span class="number">3</span>    NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>当排序一个DataFrame时，你可能希望根据一个或多个列中的值进行排序。将一个或多个列的名字传递给sort_values的by选项即可达到该目的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">211</span>]: frame = pd.DataFrame(&#123;<span class="string">'b'</span>: [<span class="number">4</span>, <span class="number">7</span>, <span class="number">-3</span>, <span class="number">2</span>], <span class="string">'a'</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">212</span>]: frame</span><br><span class="line">Out[<span class="number">212</span>]: </span><br><span class="line">   a  b</span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">4</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1</span>  <span class="number">7</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0</span> <span class="number">-3</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1</span>  <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">213</span>]: frame.sort_values(by=<span class="string">'b'</span>)</span><br><span class="line">Out[<span class="number">213</span>]: </span><br><span class="line">   a  b</span><br><span class="line"><span class="number">2</span>  <span class="number">0</span> <span class="number">-3</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1</span>  <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">4</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1</span>  <span class="number">7</span></span><br></pre></td></tr></table></figure><p>默认情况下，rank是通过“为各组分配一个平均排名”的方式破坏平级关系的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">215</span>]: obj = pd.Series([<span class="number">7</span>, <span class="number">-5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>])</span><br><span class="line">In [<span class="number">216</span>]: obj.rank()</span><br><span class="line">Out[<span class="number">216</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">6.5</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">6.5</span></span><br><span class="line"><span class="number">3</span>    <span class="number">4.5</span></span><br><span class="line"><span class="number">4</span>    <span class="number">3.0</span></span><br><span class="line"><span class="number">5</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">6</span>    <span class="number">4.5</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>也可以根据值在原数据中出现的顺序给出排名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">217</span>]: obj.rank(method=<span class="string">'first'</span>)</span><br><span class="line">Out[<span class="number">217</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">6.0</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">7.0</span></span><br><span class="line"><span class="number">3</span>    <span class="number">4.0</span></span><br><span class="line"><span class="number">4</span>    <span class="number">3.0</span></span><br><span class="line"><span class="number">5</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">6</span>    <span class="number">5.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>这里，条目0和2没有使用平均排名6.5，它们被设成了6和7，因为数据中标签0位于标签2的前面。</p><h4 id="rank-理解">rank()理解</h4><p>rank 表示在这个数在原来的Series中排第几名，有相同的数，取其排名平均（默认）作为值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">obj = pd.Series([<span class="number">7</span>,<span class="number">-5</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>])</span><br><span class="line">obj.rank()</span><br><span class="line"><span class="number">0</span>    <span class="number">6.5</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">6.5</span></span><br><span class="line"><span class="number">3</span>    <span class="number">4.5</span></span><br><span class="line"><span class="number">4</span>    <span class="number">3.0</span></span><br><span class="line"><span class="number">5</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">6</span>    <span class="number">4.5</span></span><br><span class="line">dtype: float6412345678910</span><br></pre></td></tr></table></figure><p>在obj中，4和4的排名是第4名和第五名，取平均得4.5。7和7的排名分别是第六名和第七名，则其排名取平均得6.5</p><p>WEEKDAY 是一个 Excel 函数，返回代表一周中第几天的数值，是一个1到7（或0到6）之间的整数。语法格式 WEEKDAY(date,type)，其中 date为日期；type表示返值是从1到7还是从0到6，以及从星期几开始计数，如省略则返值为1到7，且从星期日起计。</p><h3 id="dataframe-多重索引">DataFrame 多重索引</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#### 61. 根据多重索引创建 DataFrame</span></span><br><span class="line"><span class="comment">#创建一个以 `letters = ['A', 'B']` 和 `numbers = list(range(6))`为索引，值为随机数据的多重索引 DataFrame。</span></span><br><span class="line">frame=pd.DataFrame(np.arange(<span class="number">12</span>).reshape(<span class="number">6</span>,<span class="number">2</span>),</span><br><span class="line">                index=[list(<span class="string">'AAABBB'</span>),list(<span class="string">'123123'</span>)],</span><br><span class="line">                columns=[<span class="string">'hello'</span>,<span class="string">'shiyanlou'</span>])</span><br><span class="line">frame</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th></th><th>hello</th><th>shiyanlou</th></tr></thead><tbody><tr><td>A</td><td>1</td><td>0</td><td>1</td></tr><tr><td>2</td><td>2</td><td>3</td><td></td></tr><tr><td>3</td><td>4</td><td>5</td><td></td></tr><tr><td>B</td><td>1</td><td>6</td><td>7</td></tr><tr><td>2</td><td>8</td><td>9</td><td></td></tr><tr><td>3</td><td>10</td><td>11</td><td></td></tr></tbody></table><h2 id="多重索引-series">多重索引 Series</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#### 58. 创建多重索引 Series</span></span><br><span class="line"></span><br><span class="line">构建一个 `letters = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]` 和 `numbers = list(range(<span class="number">10</span>))`为索引，值为随机数的多重索引 Series。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">letters = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]</span><br><span class="line">numbers = list(range(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">mi = pd.MultiIndex.from_product([letters, numbers]) <span class="comment"># 设置多重索引</span></span><br><span class="line">s = pd.Series(np.random.rand(<span class="number">30</span>), index=mi) <span class="comment"># 随机数</span></span><br><span class="line">s</span><br><span class="line">A  <span class="number">0</span>    <span class="number">0.659206</span></span><br><span class="line">   <span class="number">1</span>    <span class="number">0.507671</span></span><br><span class="line">   <span class="number">2</span>    <span class="number">0.316128</span></span><br><span class="line">   <span class="number">3</span>    <span class="number">0.366559</span></span><br><span class="line">   <span class="number">4</span>    <span class="number">0.049803</span></span><br><span class="line">   <span class="number">5</span>    <span class="number">0.907505</span></span><br><span class="line">   <span class="number">6</span>    <span class="number">0.166473</span></span><br><span class="line">   <span class="number">7</span>    <span class="number">0.151544</span></span><br><span class="line">   <span class="number">8</span>    <span class="number">0.967564</span></span><br><span class="line">   <span class="number">9</span>    <span class="number">0.677385</span></span><br><span class="line">B  <span class="number">0</span>    <span class="number">0.682520</span></span><br><span class="line">   <span class="number">1</span>    <span class="number">0.175077</span></span><br><span class="line">   <span class="number">2</span>    <span class="number">0.087177</span></span><br><span class="line">   <span class="number">3</span>    <span class="number">0.430598</span></span><br><span class="line">   <span class="number">4</span>    <span class="number">0.128109</span></span><br><span class="line">   <span class="number">5</span>    <span class="number">0.349514</span></span><br><span class="line">   <span class="number">6</span>    <span class="number">0.253366</span></span><br><span class="line">   <span class="number">7</span>    <span class="number">0.934514</span></span><br><span class="line">   <span class="number">8</span>    <span class="number">0.028554</span></span><br><span class="line">   <span class="number">9</span>    <span class="number">0.566348</span></span><br><span class="line">C  <span class="number">0</span>    <span class="number">0.220956</span></span><br><span class="line">   <span class="number">1</span>    <span class="number">0.023640</span></span><br><span class="line">   <span class="number">2</span>    <span class="number">0.213058</span></span><br><span class="line">   <span class="number">3</span>    <span class="number">0.344396</span></span><br><span class="line">   <span class="number">4</span>    <span class="number">0.766365</span></span><br><span class="line">   <span class="number">5</span>    <span class="number">0.338038</span></span><br><span class="line">   <span class="number">6</span>    <span class="number">0.813972</span></span><br><span class="line">   <span class="number">7</span>    <span class="number">0.547278</span></span><br><span class="line">   <span class="number">8</span>    <span class="number">0.437249</span></span><br><span class="line">   <span class="number">9</span>    <span class="number">0.738858</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询索引为 1，3，6 的值</span></span><br><span class="line">s.loc[:, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>]]</span><br><span class="line">A  <span class="number">1</span>    <span class="number">0.603413</span></span><br><span class="line">   <span class="number">3</span>    <span class="number">0.965357</span></span><br><span class="line">   <span class="number">6</span>    <span class="number">0.490679</span></span><br><span class="line">B  <span class="number">1</span>    <span class="number">0.517383</span></span><br><span class="line">   <span class="number">3</span>    <span class="number">0.567798</span></span><br><span class="line">   <span class="number">6</span>    <span class="number">0.822650</span></span><br><span class="line">C  <span class="number">1</span>    <span class="number">0.933315</span></span><br><span class="line">   <span class="number">3</span>    <span class="number">0.974962</span></span><br><span class="line">   <span class="number">6</span>    <span class="number">0.127213</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><h3 id="多重索引-series-切片">多重索引 Series 切片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s.loc[pd.IndexSlice[:<span class="string">'B'</span>, <span class="number">5</span>:]]</span><br><span class="line">A  <span class="number">5</span>    <span class="number">0.863231</span></span><br><span class="line">   <span class="number">6</span>    <span class="number">0.490679</span></span><br><span class="line">   <span class="number">7</span>    <span class="number">0.566480</span></span><br><span class="line">   <span class="number">8</span>    <span class="number">0.254349</span></span><br><span class="line">   <span class="number">9</span>    <span class="number">0.043830</span></span><br><span class="line">B  <span class="number">5</span>    <span class="number">0.493134</span></span><br><span class="line">   <span class="number">6</span>    <span class="number">0.822650</span></span><br><span class="line">   <span class="number">7</span>    <span class="number">0.333771</span></span><br><span class="line">   <span class="number">8</span>    <span class="number">0.737994</span></span><br><span class="line">   <span class="number">9</span>    <span class="number">0.126518</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><h1>数据聚合与分组计算</h1><p>GroupBy机制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">10</span>]: df = pd.DataFrame(&#123;<span class="string">'key1'</span> : [<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>],</span><br><span class="line">   ....:                    <span class="string">'key2'</span> : [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'one'</span>],</span><br><span class="line">   ....:                    <span class="string">'data1'</span> : np.random.randn(<span class="number">5</span>),</span><br><span class="line">   ....:                    <span class="string">'data2'</span> : np.random.randn(<span class="number">5</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: df</span><br><span class="line">Out[<span class="number">11</span>]: </span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">0</span> <span class="number">-0.204708</span>  <span class="number">1.393406</span>    a  one</span><br><span class="line"><span class="number">1</span>  <span class="number">0.478943</span>  <span class="number">0.092908</span>    a  two</span><br><span class="line"><span class="number">2</span> <span class="number">-0.519439</span>  <span class="number">0.281746</span>    b  one</span><br><span class="line"><span class="number">3</span> <span class="number">-0.555730</span>  <span class="number">0.769023</span>    b  two</span><br><span class="line"><span class="number">4</span>  <span class="number">1.965781</span>  <span class="number">1.246435</span>    a  one</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: grouped = df[<span class="string">'data1'</span>].groupby(df[<span class="string">'key1'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: grouped</span><br><span class="line">Out[<span class="number">13</span>]: &lt;pandas.core.groupby.SeriesGroupBy object at <span class="number">0x7faa31537390</span>&gt;</span><br></pre></td></tr></table></figure><p>变量grouped是一个GroupBy对象。它实际上还没有进行任何计算，只是含有一些有关分组键df[‘key1’]的中间数据而已。换句话说，该对象已经有了接下来对各分组执行运算所需的一切信息。</p><p>无论你准备拿groupby做什么，都有可能会用到GroupBy的<strong>size方法</strong>，它可以返回一个含有分组大小的Series：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">23</span>]: df.groupby([<span class="string">'key1'</span>, <span class="string">'key2'</span>]).size()</span><br><span class="line">Out[<span class="number">23</span>]: </span><br><span class="line">key1  key2</span><br><span class="line">a     one     <span class="number">2</span></span><br><span class="line">      two     <span class="number">1</span></span><br><span class="line">b     one     <span class="number">1</span></span><br><span class="line">      two     <span class="number">1</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;Jupyter Notebook&lt;/h1&gt;
&lt;h2 id=&quot;tab补全&quot;&gt;Tab补全&lt;/h2&gt;
&lt;p&gt;从外观上，IPython shell和标准的Python解释器只是看起来不同。IPython shell的进步之一是其它IDE和交互计算分析环境都有的tab补全功能。在s
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="http://WSCZou.com/2018/05/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://WSCZou.com/2018/05/27/数据结构/</id>
    <published>2018-05-27T07:19:10.000Z</published>
    <updated>2018-06-27T11:56:01.310Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-串">一.串</h2><p>1.计算子串的个数：</p><p>字串： n（n+1）/2 + 1</p><p>非空子串：n（n+1）/2</p><p>非空真子串：n（n+1）/2 - 1</p><p>2.index函数</p><p>3.编写一个程序，求两个字符串S和T的一个最长公共子串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> *ch;</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line">&#125;Hstring;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">MaxComString</span><span class="params">(Hstring S,Hstring T,<span class="keyword">int</span> &amp;length)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">index=<span class="number">0</span>;</span><br><span class="line">length=<span class="number">0</span>;</span><br><span class="line">i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//令i作为扫描字符串S的指针</span></span><br><span class="line"><span class="keyword">while</span>(i&lt;S.length)&#123;</span><br><span class="line">j=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//令j作为扫描字符串T的指针</span></span><br><span class="line"><span class="keyword">while</span>(j&lt;T.length)&#123;</span><br><span class="line"><span class="keyword">if</span>(s.ch[i]==T.ch[j])&#123;</span><br><span class="line"><span class="comment">//找一个子串，其在字符串S中的序号为i，长度为length1</span></span><br><span class="line">length1=i;</span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">1</span>;S.ch[i+k]==T.ch[j+k];k++)length1++;</span><br><span class="line"><span class="keyword">if</span>(length1&gt;length)&#123;</span><br><span class="line"><span class="comment">//将较大长度值赋给index与length</span></span><br><span class="line">index=i;</span><br><span class="line">length=length1;</span><br><span class="line">&#125;</span><br><span class="line">j=j+length1;<span class="comment">//继续扫描字符串T中第j=length1个字符之后的字符</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//while</span></span><br><span class="line">i++;</span><br><span class="line">&#125;<span class="comment">//while</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"最长公共子串:"</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;length;i++)<span class="built_in">printf</span>(<span class="string">"%c"</span>,S.ch[index+i]);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>二.图</h1><p>极大和极小不是指一个意思,不要弄混了,极大连通子图是讨论连通分量的,极小连通子图是讨论生成树的.</p><p>完全图是一个简单的无向图，其中每对不同的顶点之间都恰连有一条边相连。完整的有向图又是一个有向图，其中每对不同的顶点通过一对唯一的边缘（每个方向一个）连接。n个端点的完全图有n个端点以及n(n − 1) / 2条边，以Kn表示</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-串&quot;&gt;一.串&lt;/h2&gt;
&lt;p&gt;1.计算子串的个数：&lt;/p&gt;
&lt;p&gt;字串： n（n+1）/2 + 1&lt;/p&gt;
&lt;p&gt;非空子串：n（n+1）/2&lt;/p&gt;
&lt;p&gt;非空真子串：n（n+1）/2 - 1&lt;/p&gt;
&lt;p&gt;2.index函数&lt;/p&gt;
&lt;p&gt;3.编写一个程序，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python仔细学习</title>
    <link href="http://WSCZou.com/2018/04/19/python%E4%BB%94%E7%BB%86%E5%AD%A6%E4%B9%A0/"/>
    <id>http://WSCZou.com/2018/04/19/python仔细学习/</id>
    <published>2018-04-19T10:49:08.000Z</published>
    <updated>2018-06-24T10:38:48.696Z</updated>
    
    <content type="html"><![CDATA[<h1>python3基础语法：</h1><h2 id="标识符-当时学c语言时也没注意-😢">标识符（当时学c语言时也没注意）😢</h2><ul><li>第一个字符必须是字母表中<strong>字母</strong>或下__划线 ___ 。</li><li>标识符的<strong>其他的部分</strong>由<strong>字母、数字和下划线</strong>组成。</li><li>标识符对<strong>大小写敏感</strong>。</li></ul><h2 id="python关键字">python关键字</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'False'</span>, <span class="string">'None'</span>, <span class="string">'True'</span>, <span class="string">'and'</span>, <span class="string">'as'</span>, <span class="string">'assert'</span>, <span class="string">'break'</span>, <span class="string">'class'</span>, <span class="string">'continue'</span>, <span class="string">'def'</span>, <span class="string">'del'</span>, <span class="string">'elif'</span>, <span class="string">'else'</span>, <span class="string">'except'</span>, <span class="string">'finally'</span>, <span class="string">'for'</span>, <span class="string">'from'</span>, <span class="string">'global'</span>, <span class="string">'if'</span>, <span class="string">'import'</span>, <span class="string">'in'</span>, <span class="string">'is'</span>, <span class="string">'lambda'</span>, <span class="string">'nonlocal'</span>, <span class="string">'not'</span>, <span class="string">'or'</span>, <span class="string">'pass'</span>, <span class="string">'raise'</span>, <span class="string">'return'</span>, <span class="string">'try'</span>, <span class="string">'while'</span>, <span class="string">'with'</span>, <span class="string">'yield'</span>]</span><br></pre></td></tr></table></figure><h2 id="行与缩进">行与缩进</h2><p>python最具特色的就是使用缩进来表示代码块，不需要使用大括号 {}</p><p>缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数</p><h2 id="多行语句">多行语句</h2><p>Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠(\)来实现多行语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total = item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br></pre></td></tr></table></figure><p>在 [], {}, 或 () 中的多行语句，不需要使用反斜杠()，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">total = [<span class="string">'item_one'</span>, <span class="string">'item_two'</span>, <span class="string">'item_three'</span>,</span><br><span class="line">        <span class="string">'item_four'</span>, <span class="string">'item_five'</span>]</span><br></pre></td></tr></table></figure><h2 id="数字-number-类型">数字(Number)类型</h2><p>除了我所学的C语言中的还有一个</p><ul><li><strong>complex</strong> (复数), 如 1 + 2j、 1.1 + 2.2j</li></ul><h2 id="字符串-string">字符串(String)</h2><p><strong>在Python3中，所有的字符串都是Unicode字符串。</strong></p><ul><li>反斜杠可以用来转义，使用<strong>r</strong>可以让反斜杠不发生转义。。 如 r&quot;this is a line with \n&quot; 则\n会显示，并不是换行。</li><li>按字面意义级联字符串，如&quot;this &quot; &quot;is &quot; &quot;string&quot;会被自动转换为this is string。</li><li>字符串可以用 + 运算符连接在一起，用 * 运算符重复。</li><li>Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。</li><li>Python中的字符串不能改变。</li><li>字符串的截取的语法格式如下：变量[头下标:尾下标]等待用户输入</li><li>Python 不支持单字符类型，<strong>单字符</strong>在 Python 中也是作为一个<strong>字符串使用</strong>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input(<span class="string">"\n\n按下 enter 键后退出。"</span>)</span><br></pre></td></tr></table></figure><p>以上代码中 ，&quot;\n\n&quot;在结果输出前会输出两个新的空行。一旦用户按下 enter 键时，程序将退出。</p><h3 id="python三引号">python三引号</h3><p>python三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。</p><p>三引号让程序员从引号和特殊字符串的泥潭里面解脱出来，自始至终保持一小块字符串的格式是所谓的WYSIWYG（所见即所得）格式的。</p><p>一个典型的用例是，当你需要一块HTML或者SQL时，这时用字符串组合，特殊字符串转义将会非常的繁琐。</p><p><strong>而三引号使其不再复杂</strong></p><h3 id="python-的字符串内建函数"><strong>Python 的字符串内建函数</strong></h3><p>Python 的字符串常用内建函数如下：</p><table><thead><tr><th>序号</th><th>方法及描述</th></tr></thead><tbody><tr><td>1</td><td><a href="http://www.runoob.com/python3/python3-string-capitalize.html" target="_blank" rel="noopener">capitalize()</a>将字符串的第一个字符转换为大写</td></tr><tr><td>2</td><td><a href="http://www.runoob.com/python3/python3-string-center.html" target="_blank" rel="noopener">center(width, fillchar)</a>返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。</td></tr><tr><td>3</td><td><a href="http://www.runoob.com/python3/python3-string-count.html" target="_blank" rel="noopener">count(str, beg= 0,end=len(string))</a>返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</td></tr><tr><td>4</td><td><a href="http://www.runoob.com/python3/python3-string-decode.html" target="_blank" rel="noopener">bytes.decode(encoding=“utf-8”, errors=“strict”)</a>Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。</td></tr><tr><td>5</td><td><a href="http://www.runoob.com/python3/python3-string-encode.html" target="_blank" rel="noopener">encode(encoding=‘UTF-8’,errors=‘strict’)</a>以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’</td></tr><tr><td>6</td><td><a href="http://www.runoob.com/python3/python3-string-endswith.html" target="_blank" rel="noopener">endswith(suffix, beg=0, end=len(string))</a>检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.</td></tr><tr><td>7</td><td><a href="http://www.runoob.com/python3/python3-string-expandtabs.html" target="_blank" rel="noopener">expandtabs(tabsize=8)</a>把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。</td></tr><tr><td>8</td><td><a href="http://www.runoob.com/python3/python3-string-find.html" target="_blank" rel="noopener">find(str, beg=0 end=len(string))</a>检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1</td></tr><tr><td>9</td><td><a href="http://www.runoob.com/python3/python3-string-index.html" target="_blank" rel="noopener">index(str, beg=0, end=len(string))</a>跟find()方法一样，只不过如果str不在字符串中会报一个异常.</td></tr><tr><td>10</td><td><a href="http://www.runoob.com/python3/python3-string-isalnum.html" target="_blank" rel="noopener">isalnum()</a>如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True,否则返回 False</td></tr><tr><td>11</td><td><a href="http://www.runoob.com/python3/python3-string-isalpha.html" target="_blank" rel="noopener">isalpha()</a>如果字符串至少有一个字符并且所有字符都是字母则返回 True, 否则返回 False</td></tr><tr><td>12</td><td><a href="http://www.runoob.com/python3/python3-string-isdigit.html" target="_blank" rel="noopener">isdigit()</a>如果字符串只包含数字则返回 True 否则返回 False…</td></tr><tr><td>13</td><td><a href="http://www.runoob.com/python3/python3-string-islower.html" target="_blank" rel="noopener">islower()</a>如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</td></tr><tr><td>14</td><td><a href="http://www.runoob.com/python3/python3-string-isnumeric.html" target="_blank" rel="noopener">isnumeric()</a>如果字符串中只包含数字字符，则返回 True，否则返回 False</td></tr><tr><td>15</td><td><a href="http://www.runoob.com/python3/python3-string-isspace.html" target="_blank" rel="noopener">isspace()</a>如果字符串中只包含空白，则返回 True，否则返回 False.</td></tr><tr><td>16</td><td><a href="http://www.runoob.com/python3/python3-string-istitle.html" target="_blank" rel="noopener">istitle()</a>如果字符串是标题化的(见 title())则返回 True，否则返回 False</td></tr><tr><td>17</td><td><a href="http://www.runoob.com/python3/python3-string-isupper.html" target="_blank" rel="noopener">isupper()</a>如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</td></tr><tr><td>18</td><td><a href="http://www.runoob.com/python3/python3-string-join.html" target="_blank" rel="noopener">join(seq)</a>以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</td></tr><tr><td>19</td><td><a href="http://www.runoob.com/python3/python3-string-len.html" target="_blank" rel="noopener">len(string)</a>返回字符串长度</td></tr><tr><td>20</td><td>[ljust(width<a href="http://www.runoob.com/python3/python3-string-ljust.html" target="_blank" rel="noopener">, fillchar])</a>返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。</td></tr><tr><td>21</td><td><a href="http://www.runoob.com/python3/python3-string-lower.html" target="_blank" rel="noopener">lower()</a>转换字符串中所有大写字符为小写.</td></tr><tr><td>22</td><td><a href="http://www.runoob.com/python3/python3-string-lstrip.html" target="_blank" rel="noopener">lstrip()</a>截掉字符串左边的空格或指定字符。</td></tr><tr><td>23</td><td><a href="http://www.runoob.com/python3/python3-string-maketrans.html" target="_blank" rel="noopener">maketrans()</a>创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。</td></tr><tr><td>24</td><td><a href="http://www.runoob.com/python3/python3-string-max.html" target="_blank" rel="noopener">max(str)</a>返回字符串 str 中最大的字母。</td></tr><tr><td>25</td><td><a href="http://www.runoob.com/python3/python3-string-min.html" target="_blank" rel="noopener">min(str)</a>返回字符串 str 中最小的字母。</td></tr><tr><td>26</td><td>[replace(old, new <a href="http://www.runoob.com/python3/python3-string-replace.html" target="_blank" rel="noopener">, max])</a>把 将字符串中的 str1 替换成 str2,如果 max 指定，则替换不超过 max 次。</td></tr><tr><td>27</td><td><a href="http://www.runoob.com/python3/python3-string-rfind.html" target="_blank" rel="noopener">rfind(str, beg=0,end=len(string))</a>类似于 find()函数，不过是从右边开始查找.</td></tr><tr><td>28</td><td><a href="http://www.runoob.com/python3/python3-string-rindex.html" target="_blank" rel="noopener">rindex( str, beg=0, end=len(string))</a>类似于 index()，不过是从右边开始.</td></tr><tr><td>29</td><td>[rjust(width,<a href="http://www.runoob.com/python3/python3-string-rjust.html" target="_blank" rel="noopener">, fillchar])</a>返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串</td></tr><tr><td>30</td><td><a href="http://www.runoob.com/python3/python3-string-rstrip.html" target="_blank" rel="noopener">rstrip()</a>删除字符串字符串末尾的空格.</td></tr><tr><td>31</td><td><a href="http://www.runoob.com/python3/python3-string-split.html" target="_blank" rel="noopener">split(str=&quot;&quot;, num=string.count(str))</a>num=string.count(str)) 以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num 个子字符串</td></tr><tr><td>32</td><td>[splitlines(<a href="http://www.runoob.com/python3/python3-string-splitlines.html" target="_blank" rel="noopener">keepends])</a>按照行(’\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。</td></tr><tr><td>33</td><td><a href="http://www.runoob.com/python3/python3-string-startswith.html" target="_blank" rel="noopener">startswith(str, beg=0,end=len(string))</a>检查字符串是否是以 obj 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。</td></tr><tr><td>34</td><td>[strip(<a href="http://www.runoob.com/python3/python3-string-strip.html" target="_blank" rel="noopener">chars])</a>在字符串上执行 lstrip()和 rstrip()</td></tr><tr><td>35</td><td><a href="http://www.runoob.com/python3/python3-string-swapcase.html" target="_blank" rel="noopener">swapcase()</a>将字符串中大写转换为小写，小写转换为大写</td></tr><tr><td>36</td><td><a href="http://www.runoob.com/python3/python3-string-title.html" target="_blank" rel="noopener">title()</a>返回&quot;标题化&quot;的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())</td></tr><tr><td>37</td><td><a href="http://www.runoob.com/python3/python3-string-translate.html" target="_blank" rel="noopener">translate(table, deletechars=&quot;&quot;)</a>根据 str 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中</td></tr><tr><td>38</td><td><a href="http://www.runoob.com/python3/python3-string-upper.html" target="_blank" rel="noopener">upper()</a>转换字符串中的小写字母为大写</td></tr><tr><td>39</td><td><a href="http://www.runoob.com/python3/python3-string-zfill.html" target="_blank" rel="noopener">zfill (width)</a>返回长度为 width 的字符串，原字符串右对齐，前面填充0</td></tr><tr><td>40</td><td><a href="http://www.runoob.com/python3/python3-string-isdecimal.html" target="_blank" rel="noopener">isdecimal()</a>检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。</td></tr></tbody></table><h2 id="print-输出">Print 输出</h2><p>print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 <strong>end=&quot;&quot;</strong>：</p><p>在 Python 中，字符串格式化使用与 C 中 sprintf 函数一样的语法。</p><p>#!/usr/bin/python3 print (“我叫 %s 今年 %d 岁!” **% <strong>(‘小明’, 10))（注意这里与c语言不同的是引号后面是</strong>%**而不是，）</p><h1>Python3 基本数据类型：</h1><h3 id="多个变量赋值-再也不用像c语言那样一个一个赋值了😄">多个变量赋值（再也不用像C语言那样一个一个赋值了😄）</h3><p>Python允许你同时为多个变量赋值。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b = c = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>以上实例，创建一个整型对象，值为1，三个变量被分配到相同的内存空间上。</p><p>您也可以为多个对象指定多个变量。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="string">"runoob"</span></span><br></pre></td></tr></table></figure><p>以上实例，两个整型对象 1 和 2 的分配给变量 a 和 b，字符串对象 “runoob” 分配给变量 c。</p><h2 id="标准数据类型">标准数据类型</h2><p>Python3 中有六个标准的数据类型：</p><ul><li>Number（数字）</li><li>String（字符串）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Sets（集合）</li><li>Dictionary（字典）</li></ul><p>Python3 的六个标准数据类型中：</p><ul><li>**不可变数据（四个）：**Number（数字）、String（字符串）、Tuple（元组）、Sets（集合）；</li><li>**可变数据（两个）：**List（列表）、Dictionary（字典）。</li></ul><p><strong>内置的 type() 函数可以用来查询变量所指的对象类型。</strong></p><p>此外还可以用 isinstance 来判断：</p><p>&gt;&gt;&gt;a = 111&gt;&gt;&gt; isinstance(a, int)True&gt;&gt;&gt;</p><p>isinstance 和 type 的区别在于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">isinstance(A(), A)  <span class="comment"># returns True</span></span><br><span class="line">type(A()) == A      <span class="comment"># returns True</span></span><br><span class="line">isinstance(B(), A)    <span class="comment"># returns True</span></span><br><span class="line">type(B()) == A        <span class="comment"># returns False</span></span><br></pre></td></tr></table></figure><p>区别就是:</p><ul><li>type()不会认为子类是一种父类类型。</li><li>isinstance()会认为子类是一种父类类型。</li></ul><p>当你指定一个值时，Number 对象就会被创建：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var1 = <span class="number">1</span></span><br><span class="line">var2 = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>您也可以使用del语句删除一些对象引用。</p><p>del语句的语法是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> var1[,var2[,var3[....,varN]]]]</span><br></pre></td></tr></table></figure><p>您可以通过使用del语句删除单个或多个对象。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> var</span><br><span class="line"><span class="keyword">del</span> var_a, var_b</span><br></pre></td></tr></table></figure><h3 id="数值运算">数值运算</h3><p>数值的除法（/）总是返回一个浮点数，要获取整数使用//操作符。</p><p>在混合计算时，Python会把整型转换成为浮点数。</p><p>Python还支持复数，复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型</p><h2 id="string-字符串">String（字符串）</h2><p>索引值以 0 为开始值，-1 为从末尾的开始位置。</p><p>加号 (+) 是字符串的连接符， 星号 (*) 表示复制当前字符串，紧跟的数字为复制的次数</p><p>Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。</p><h2 id="list-列表">List（列表）</h2><p>列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。</p><p>列表是写在方括号([])之间、用逗号分隔开的元素列表。</p><p>和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。</p><p><strong>与Python字符串不一样的是，列表中的元素是可以改变的</strong></p><h3 id="嵌套列表">嵌套列表</h3><p>使用嵌套列表即在列表里创建其它列表，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [a, n]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="number">0</span>]</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line"><span class="string">'b'</span></span><br></pre></td></tr></table></figure><h3 id="python列表函数-方法">Python列表函数&amp;方法</h3><p>Python包含以下函数:</p><table><thead><tr><th>序号</th><th>函数</th></tr></thead><tbody><tr><td>1</td><td><a href="http://www.runoob.com/python3/python3-att-list-len.html" target="_blank" rel="noopener">len(list)</a>列表元素个数</td></tr><tr><td>2</td><td><a href="http://www.runoob.com/python3/python3-att-list-max.html" target="_blank" rel="noopener">max(list)</a>返回列表元素最大值</td></tr><tr><td>3</td><td><a href="http://www.runoob.com/python3/python3-att-list-min.html" target="_blank" rel="noopener">min(list)</a>返回列表元素最小值</td></tr><tr><td>4</td><td><a href="http://www.runoob.com/python3/python3-att-list-list.html" target="_blank" rel="noopener">list(seq)</a>将元组转换为列表</td></tr></tbody></table><p>Python包含以下方法:</p><table><thead><tr><th>序号</th><th>方法</th></tr></thead><tbody><tr><td>1</td><td><a href="http://www.runoob.com/python3/python3-att-list-append.html" target="_blank" rel="noopener">list.append(obj)</a>在列表末尾添加新的对象</td></tr><tr><td>2</td><td><a href="http://www.runoob.com/python3/python3-att-list-count.html" target="_blank" rel="noopener">list.count(obj)</a>统计某个元素在列表中出现的次数</td></tr><tr><td>3</td><td><a href="http://www.runoob.com/python3/python3-att-list-extend.html" target="_blank" rel="noopener">list.extend(seq)</a>在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td></tr><tr><td>4</td><td><a href="http://www.runoob.com/python3/python3-att-list-index.html" target="_blank" rel="noopener">list.index(obj)</a>从列表中找出某个值第一个匹配项的索引位置</td></tr><tr><td>5</td><td><a href="http://www.runoob.com/python3/python3-att-list-insert.html" target="_blank" rel="noopener">list.insert(index, obj)</a>将对象插入列表</td></tr><tr><td>6</td><td>[list.pop(obj=list<a href="http://www.runoob.com/python3/python3-att-list-pop.html" target="_blank" rel="noopener">-1])</a>移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td></tr><tr><td>7</td><td><a href="http://www.runoob.com/python3/python3-att-list-remove.html" target="_blank" rel="noopener">list.remove(obj)</a>移除列表中某个值的第一个匹配项</td></tr><tr><td>8</td><td><a href="http://www.runoob.com/python3/python3-att-list-reverse.html" target="_blank" rel="noopener">list.reverse()</a>反向列表中元素</td></tr><tr><td>9</td><td>[list.sort(<a href="http://www.runoob.com/python3/python3-att-list-sort.html" target="_blank" rel="noopener">func])</a>对原列表进行排序</td></tr><tr><td>10</td><td><a href="http://www.runoob.com/python3/python3-att-list-clear.html" target="_blank" rel="noopener">list.clear()</a>清空列表</td></tr><tr><td>11</td><td><a href="http://www.runoob.com/python3/python3-att-list-copy.html" target="_blank" rel="noopener">list.copy()</a>复制列表</td></tr></tbody></table><h2 id="tuple-元组">Tuple（元组）</h2><p>元组（tuple）与列表类似，不同之处在于元组的元素<strong>不能修改</strong>。元组写在小括号 () 里，元素之间用逗号隔开。</p><p><strong>虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。</strong></p><p>构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tup1 = ()    <span class="comment"># 空元组</span></span><br><span class="line">tup2 = (<span class="number">20</span>,) <span class="comment"># 一个元素，需要在元素后添加逗号</span></span><br></pre></td></tr></table></figure><p>元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup1 = (<span class="number">50</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(tup1)     <span class="comment"># 不加逗号，类型为整型</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line">&gt;&gt;&gt; tup1 = (50,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(tup1)     <span class="comment"># 加上逗号，类型为元组</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">tuple</span>'&gt;</span></span><br></pre></td></tr></table></figure><h3 id="元组内置函数">元组内置函数</h3><p>Python元组包含了以下内置函数</p><table><thead><tr><th>序号</th><th>方法及描述</th><th>实例</th></tr></thead><tbody><tr><td>1</td><td>len(tuple)计算元组元素个数。</td><td><code>&gt;&gt;&gt; tuple1 = ('Google', 'Runoob', 'Taobao')&gt;&gt;&gt; len(tuple1)3&gt;&gt;&gt;</code></td></tr><tr><td>2</td><td>max(tuple)返回元组中元素最大值。</td><td><code>&gt;&gt;&gt; tuple2 = ('5', '4', '8')&gt;&gt;&gt; max(tuple2)'8'&gt;&gt;&gt;</code></td></tr><tr><td>3</td><td>min(tuple)返回元组中元素最小值。</td><td><code>&gt;&gt;&gt; tuple2 = ('5', '4', '8')&gt;&gt;&gt; min(tuple2)'4'&gt;&gt;&gt;</code></td></tr><tr><td>4</td><td>tuple(seq)将列表转换为元组。</td><td><code>&gt;&gt;&gt; list1= ['Google', 'Taobao', 'Runoob', 'Baidu']&gt;&gt;&gt; tuple1=tuple(list1)&gt;&gt;&gt; tuple1('Google', 'Taobao', 'Runoob', 'Baidu')</code></td></tr></tbody></table><h2 id="set-集合">Set（集合）</h2><p>集合（set）是一个无序不重复元素的序列。</p><p>基本功能是进行成员关系测试和删除重复元素。</p><p>可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个<strong>空集合必须用 set() 而不是 { }</strong>，因为 <strong>{ } 是用来创建一个空字典。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#set可以进行集合运算</span></span><br><span class="line">a = set(<span class="string">'abracadabra'</span>)</span><br><span class="line">b = set(<span class="string">'alacazam'</span>)</span><br><span class="line"> </span><br><span class="line">print(a)</span><br><span class="line"> </span><br><span class="line">print(a - b)     <span class="comment"># a和b的差集</span></span><br><span class="line"> </span><br><span class="line">print(a | b)     <span class="comment"># a和b的并集</span></span><br><span class="line"> </span><br><span class="line">print(a &amp; b)     <span class="comment"># a和b的交集</span></span><br><span class="line"> </span><br><span class="line">print(a ^ b)     <span class="comment"># a和b中不同时存在的元素</span></span><br></pre></td></tr></table></figure><h2 id="dictionary-字典">Dictionary（字典）</h2><p>列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。</p><p>字典是一种映射类型，字典用&quot;{ }&quot;标识，它是一个无序的**键(key) : 值(value)**对集合。</p><p>键(key)必须使用不可变类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;x: x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>)&#125;</span><br><span class="line">&#123;<span class="number">2</span>: <span class="number">4</span>, <span class="number">4</span>: <span class="number">16</span>, <span class="number">6</span>: <span class="number">36</span>&#125;</span><br></pre></td></tr></table></figure><p>这里的x**2是x平方的意思</p><h3 id="字典键的特性">字典键的特性</h3><p>字典值可以是任何的 python 对象，既可以是标准的对象，也可以是用户定义的，但键不行。</p><p>两个重要的点需要记住：</p><p>1）不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住，如下实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line">dict = &#123;<span class="string">'Name'</span>: <span class="string">'Runoob'</span>, <span class="string">'Age'</span>: <span class="number">7</span>, <span class="string">'Name'</span>: <span class="string">'小菜鸟'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"dict['Name']: "</span>, dict[<span class="string">'Name'</span>])</span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict[<span class="string">'Name'</span>]:  小菜鸟</span><br></pre></td></tr></table></figure><p>2）键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行，如下实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line">dict = &#123;[<span class="string">'Name'</span>]: <span class="string">'Runoob'</span>, <span class="string">'Age'</span>: <span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"dict['Name']: "</span>, dict[<span class="string">'Name'</span>])</span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"test.py"</span>, line <span class="number">3</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    dict = &#123;[<span class="string">'Name'</span>]: <span class="string">'Runoob'</span>, <span class="string">'Age'</span>: <span class="number">7</span>&#125;</span><br><span class="line">TypeError: unhashable type: <span class="string">'list'</span></span><br></pre></td></tr></table></figure><h3 id="字典内置函数-方法">字典内置函数&amp;方法</h3><p>Python字典包含了以下内置函数：</p><table><thead><tr><th>序号</th><th>函数及描述</th><th>实例</th></tr></thead><tbody><tr><td>1</td><td>len(dict)计算字典元素个数，即键的总数。</td><td><code>&gt;&gt;&gt; dict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'}&gt;&gt;&gt; len(dict)3</code></td></tr><tr><td>2</td><td>str(dict)输出字典，以可打印的字符串表示。</td><td><code>&gt;&gt;&gt; dict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'}&gt;&gt;&gt; str(dict)&quot;{'Name': 'Runoob', 'Class': 'First', 'Age': 7}&quot;</code></td></tr><tr><td>3</td><td>type(variable)返回输入的变量类型，如果变量是字典就返回字典类型。</td><td><code>&gt;&gt;&gt; dict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'}&gt;&gt;&gt; type(dict)&lt;class 'dict'&gt;</code></td></tr></tbody></table><p>Python字典包含了以下内置方法：</p><table><thead><tr><th>序号</th><th>函数及描述</th></tr></thead><tbody><tr><td>1</td><td><a href="http://www.runoob.com/python3/python3-att-dictionary-clear.html" target="_blank" rel="noopener">radiansdict.clear()</a>删除字典内所有元素</td></tr><tr><td>2</td><td><a href="http://www.runoob.com/python3/python3-att-dictionary-copy.html" target="_blank" rel="noopener">radiansdict.copy()</a>返回一个字典的浅复制</td></tr><tr><td>3</td><td><a href="http://www.runoob.com/python3/python3-att-dictionary-fromkeys.html" target="_blank" rel="noopener">radiansdict.fromkeys()</a>创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值</td></tr><tr><td>4</td><td><a href="http://www.runoob.com/python3/python3-att-dictionary-get.html" target="_blank" rel="noopener">radiansdict.get(key, default=None)</a>返回指定键的值，如果值不在字典中返回default值</td></tr><tr><td>5</td><td><a href="http://www.runoob.com/python3/python3-att-dictionary-in.html" target="_blank" rel="noopener">key in dict</a>如果键在字典dict里返回true，否则返回false</td></tr><tr><td>6</td><td><a href="http://www.runoob.com/python3/python3-att-dictionary-items.html" target="_blank" rel="noopener">radiansdict.items()</a>以列表返回可遍历的(键, 值) 元组数组</td></tr><tr><td>7</td><td><a href="http://www.runoob.com/python3/python3-att-dictionary-keys.html" target="_blank" rel="noopener">radiansdict.keys()</a>以列表返回一个字典所有的键</td></tr><tr><td>8</td><td><a href="http://www.runoob.com/python3/python3-att-dictionary-setdefault.html" target="_blank" rel="noopener">radiansdict.setdefault(key, default=None)</a>和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</td></tr><tr><td>9</td><td><a href="http://www.runoob.com/python3/python3-att-dictionary-update.html" target="_blank" rel="noopener">radiansdict.update(dict2)</a>把字典dict2的键/值对更新到dict里</td></tr><tr><td>10</td><td><a href="http://www.runoob.com/python3/python3-att-dictionary-values.html" target="_blank" rel="noopener">radiansdict.values()</a>以列表返回字典中的所有值</td></tr><tr><td>11</td><td>[pop(key<a href="http://www.runoob.com/python3/python3-att-dictionary-pop.html" target="_blank" rel="noopener">,default])</a>删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</td></tr><tr><td>12</td><td><a href="http://www.runoob.com/python3/python3-att-dictionary-popitem.html" target="_blank" rel="noopener">popitem()</a>随机返回并删除字典中的一对键和值(一般删除末尾对)。</td></tr></tbody></table><p>字典是支持无限极嵌套的，如下面代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cities=&#123;</span><br><span class="line">    <span class="string">'北京'</span>:&#123;</span><br><span class="line">        <span class="string">'朝阳'</span>:[<span class="string">'国贸'</span>,<span class="string">'CBD'</span>,<span class="string">'天阶'</span>,<span class="string">'我爱我家'</span>,<span class="string">'链接地产'</span>],</span><br><span class="line">        <span class="string">'海淀'</span>:[<span class="string">'圆明园'</span>,<span class="string">'苏州街'</span>,<span class="string">'中关村'</span>,<span class="string">'北京大学'</span>],</span><br><span class="line">        <span class="string">'昌平'</span>:[<span class="string">'沙河'</span>,<span class="string">'南口'</span>,<span class="string">'小汤山'</span>,],</span><br><span class="line">        <span class="string">'怀柔'</span>:[<span class="string">'桃花'</span>,<span class="string">'梅花'</span>,<span class="string">'大山'</span>],</span><br><span class="line">        <span class="string">'密云'</span>:[<span class="string">'密云A'</span>,<span class="string">'密云B'</span>,<span class="string">'密云C'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'河北'</span>:&#123;</span><br><span class="line">        <span class="string">'石家庄'</span>:[<span class="string">'石家庄A'</span>,<span class="string">'石家庄B'</span>,<span class="string">'石家庄C'</span>,<span class="string">'石家庄D'</span>,<span class="string">'石家庄E'</span>],</span><br><span class="line">        <span class="string">'张家口'</span>:[<span class="string">'张家口A'</span>,<span class="string">'张家口B'</span>,<span class="string">'张家口C'</span>],</span><br><span class="line">        <span class="string">'承德'</span>:[<span class="string">'承德A'</span>,<span class="string">'承德B'</span>,<span class="string">'承德C'</span>,<span class="string">'承德D'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用如下方法进行列出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> cities[<span class="string">'北京'</span>]:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><p>将列出如下结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">朝阳</span><br><span class="line">海淀</span><br><span class="line">昌平</span><br><span class="line">怀柔</span><br><span class="line">密云</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> cities[<span class="string">'北京'</span>][<span class="string">'海淀'</span>]:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><p>输出如下结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">圆明园</span><br><span class="line">苏州街</span><br><span class="line">中关村</span><br><span class="line">北京大学</span><br></pre></td></tr></table></figure><h1>Python3 运算符</h1><table><thead><tr><th>**=</th><th>幂赋值运算符</th><th>c **= a 等效于 c = c ** a</th></tr></thead><tbody><tr><td>//=</td><td>取整除赋值运算符</td><td>c //= a 等效于 c = c // a</td></tr></tbody></table><h2 id="python成员运算符">Python成员运算符</h2><p>除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>in</td><td>如果在指定的序列中找到值返回 True，否则返回 False。</td><td>x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td></tr><tr><td>not in</td><td>如果在指定的序列中没有找到值返回 True，否则返回 False。</td><td>x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td></tr></tbody></table><h2 id="python身份运算符">Python身份运算符</h2><p>身份运算符用于比较两个对象的存储单元</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>is</td><td>is 是判断两个标识符是不是引用自一个对象</td><td><strong>x is y</strong>, 类似 <strong>id(x) == id(y)</strong> , 如果引用的是同一个对象则返回 True，否则返回 False</td></tr><tr><td>is not</td><td>is not 是判断两个标识符是不是引用自不同对象</td><td><strong>x is not y</strong> ， 类似 <strong>id(a) != id(b)</strong>。如果引用的不是同一个对象则返回结果 True，否则返回 False。</td></tr></tbody></table><p><strong>注：</strong> <a href="http://www.runoob.com/python/python-func-id.html" target="_blank" rel="noopener">id()</a> 函数用于获取对象内存地址。</p><p><strong>s 与 == 区别：</strong></p><p><strong>is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。</strong></p><h1>Python3 数字(Number)</h1><h2 id="python-数字类型转换">Python 数字类型转换</h2><p>有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。</p><ul><li><p><strong>int(x)</strong> 将x转换为一个整数。</p></li><li><p><strong>float(x)</strong> 将x转换到一个浮点数。</p></li><li><p><strong>complex(x)</strong> 将x转换到一个复数，实数部分为 x，虚数部分为 0。</p></li><li><p><strong>complex(x, y)</strong> 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式。</p></li><li><p><strong>变量在使用前必须先&quot;定义&quot;（即赋予变量一个值）</strong></p><h2 id="数学函数">数学函数</h2><table><thead><tr><th>函数</th><th>返回值 ( 描述 )</th></tr></thead><tbody><tr><td><a href="http://www.runoob.com/python3/python3-func-number-abs.html" target="_blank" rel="noopener">abs(x)</a></td><td>返回数字的绝对值，如abs(-10) 返回 10</td></tr><tr><td><a href="http://www.runoob.com/python3/python3-func-number-ceil.html" target="_blank" rel="noopener">ceil(x)</a></td><td>返回数字的上入整数，如math.ceil(4.1) 返回 5</td></tr><tr><td>cmp(x, y)</td><td>如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1。 <strong>Python 3 已废弃</strong> 。使用 <strong>使用 (x&gt;y)-(x&lt;y)</strong> 替换。</td></tr><tr><td><a href="http://www.runoob.com/python3/python3-func-number-exp.html" target="_blank" rel="noopener">exp(x)</a></td><td>返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045</td></tr><tr><td><a href="http://www.runoob.com/python3/python3-func-number-fabs.html" target="_blank" rel="noopener">fabs(x)</a></td><td>返回数字的绝对值，如math.fabs(-10) 返回10.0</td></tr><tr><td><a href="http://www.runoob.com/python3/python3-func-number-floor.html" target="_blank" rel="noopener">floor(x)</a></td><td>返回数字的下舍整数，如math.floor(4.9)返回 4</td></tr><tr><td><a href="http://www.runoob.com/python3/python3-func-number-log.html" target="_blank" rel="noopener">log(x)</a></td><td>如math.log(math.e)返回1.0,math.log(100,10)返回2.0</td></tr><tr><td><a href="http://www.runoob.com/python3/python3-func-number-log10.html" target="_blank" rel="noopener">log10(x)</a></td><td>返回以10为基数的x的对数，如math.log10(100)返回 2.0</td></tr><tr><td><a href="http://www.runoob.com/python3/python3-func-number-max.html" target="_blank" rel="noopener">max(x1, x2,…)</a></td><td>返回给定参数的最大值，参数可以为序列。</td></tr><tr><td><a href="http://www.runoob.com/python3/python3-func-number-min.html" target="_blank" rel="noopener">min(x1, x2,…)</a></td><td>返回给定参数的最小值，参数可以为序列。</td></tr><tr><td><a href="http://www.runoob.com/python3/python3-func-number-modf.html" target="_blank" rel="noopener">modf(x)</a></td><td>返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</td></tr><tr><td><a href="http://www.runoob.com/python3/python3-func-number-pow.html" target="_blank" rel="noopener">pow(x, y)</a></td><td>x**y 运算后的值。</td></tr><tr><td>[round(x <a href="http://www.runoob.com/python3/python3-func-number-round.html" target="_blank" rel="noopener">,n])</a></td><td>返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。</td></tr><tr><td><a href="http://www.runoob.com/python3/python3-func-number-sqrt.html" target="_blank" rel="noopener">sqrt(x)</a></td><td>返回数字x的平方根。</td></tr></tbody></table><h2 id="随机数函数">随机数函数</h2><p>随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。</p><p>Python包含以下常用随机数函数：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><a href="http://www.runoob.com/python3/python3-func-number-choice.html" target="_blank" rel="noopener">choice(seq)</a></td><td>从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。</td></tr><tr><td>[randrange (<a href="http://www.runoob.com/python3/python3-func-number-randrange.html" target="_blank" rel="noopener">start,] stop [,step])</a></td><td>从指定范围内，按指定基数递增的集合中获取一个随机数，基数缺省值为1</td></tr><tr><td><a href="http://www.runoob.com/python3/python3-func-number-random.html" target="_blank" rel="noopener">random()</a></td><td>随机生成下一个实数，它在[0,1)范围内。</td></tr><tr><td>[seed(<a href="http://www.runoob.com/python3/python3-func-number-seed.html" target="_blank" rel="noopener">x])</a></td><td>改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。</td></tr><tr><td><a href="http://www.runoob.com/python3/python3-func-number-shuffle.html" target="_blank" rel="noopener">shuffle(lst)</a></td><td>将序列的所有元素随机排序</td></tr><tr><td><a href="http://www.runoob.com/python3/python3-func-number-uniform.html" target="_blank" rel="noopener">uniform(x, y)</a></td><td>随机生成下一个实数，它在[x,y]范围内。</td></tr></tbody></table><h2 id="数学常量">数学常量</h2><table><thead><tr><th>常量</th><th>描述</th></tr></thead><tbody><tr><td>pi</td><td>数学常量 pi（圆周率，一般以π来表示）</td></tr><tr><td>e</td><td>数学常量 e，e即自然常数（自然常数）。</td></tr></tbody></table></li></ul><h1>Python3 条件控制</h1><p>Python 中用 <strong>elif</strong> 代替了 <strong>else if</strong>，所以if语句的关键字为：<strong>if – elif – else</strong>。</p><p><strong>注意：</strong></p><ul><li><p>1、每个条件后面要使用冒号（:），表示接下来是满足条件后要执行的语句块。</p></li><li><p>2、使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。</p></li><li><p>3、在Python中没有switch – case语句。</p><p><strong>下面请记住</strong>⚠️</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 程序演示了 == 操作符</span></span><br><span class="line"><span class="comment"># 使用数字</span></span><br><span class="line">print(<span class="number">5</span> == <span class="number">6</span>)</span><br><span class="line"><span class="comment"># 使用变量</span></span><br><span class="line">x = <span class="number">5</span></span><br><span class="line">y = <span class="number">8</span></span><br><span class="line">print(x == y)</span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2 id="if-嵌套">if 嵌套</h2><p>在嵌套 if 语句中，可以把 if…elif…else 结构放在另外一个 if…elif…else 结构中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式<span class="number">1</span>:</span><br><span class="line">    语句</span><br><span class="line">    <span class="keyword">if</span> 表达式<span class="number">2</span>:</span><br><span class="line">        语句</span><br><span class="line">    <span class="keyword">elif</span> 表达式<span class="number">3</span>:</span><br><span class="line">        语句</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        语句</span><br><span class="line"><span class="keyword">elif</span> 表达式<span class="number">4</span>:</span><br><span class="line">    语句</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    语句</span><br></pre></td></tr></table></figure><h2 id="三元表达式">三元表达式</h2><p>Python中的三元表达式可以将if-else语句放到一行里。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = true-expr <span class="keyword">if</span> condition <span class="keyword">else</span> false-expr</span><br></pre></td></tr></table></figure><p><code>true-expr</code>或<code>false-expr</code>可以是任何Python代码。它和下面的代码效果相同：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition:</span><br><span class="line">    value = true-expr</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    value = false-expr</span><br></pre></td></tr></table></figure><p>下面是一个更具体的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">126</span>]: x = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">127</span>]: <span class="string">'Non-negative'</span> <span class="keyword">if</span> x &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="string">'Negative'</span></span><br><span class="line">Out[<span class="number">127</span>]: <span class="string">'Non-negative'</span></span><br></pre></td></tr></table></figure><p>和if-else一样，只有一个表达式会被执行。因此，三元表达式中的if和else可以包含大量的计算，但只有True的分支会被执行。</p><p>虽然使用三元表达式可以压缩代码，但会降低代码可读性。</p><h1>Python3 循环语句</h1><h2 id="while-循环使用-else-语句">while 循环使用 else 语句</h2><p>在 while … else 在条件语句为 false 时执行 else 的语句块：</p><h2 id="for-语句">for 语句</h2><p>Python for循环可以遍历任何序列的项目，如一个列表或者一个字符串</p><h2 id="range-函数">range()函数</h2><p>如果你需要遍历数字序列，可以使用内置range()函数。它会生成数列，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;for i in range(5):</span><br><span class="line">...     print(i)</span><br><span class="line">...</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>你也可以使用range指定区间的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>,<span class="number">9</span>) :</span><br><span class="line">    print(i)</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>也可以使range以指定数字开始并指定不同的增量(甚至可以是负数，有时这也叫做’步长’):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>, <span class="number">3</span>) :</span><br><span class="line">    print(i)</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>您可以结合range()和len()函数以遍历一个序列的索引,如下所示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a = [<span class="string">'Google'</span>, <span class="string">'Baidu'</span>, <span class="string">'Runoob'</span>, <span class="string">'Taobao'</span>, <span class="string">'QQ'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line"><span class="meta">... </span>    print(i, a[i])</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">0</span> Google</span><br><span class="line"><span class="number">1</span> Baidu</span><br><span class="line"><span class="number">2</span> Runoob</span><br><span class="line"><span class="number">3</span> Taobao</span><br><span class="line"><span class="number">4</span> QQ</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>还可以使用range()函数来创建一个列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;list(range(<span class="number">5</span>))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>循环语句可以有 else 子句，它在穷尽列表(以for循环)或条件变为 false (以while循环)导致循环终止时被执行,但循环被break终止时不执行。</p><p>如下实例用于查询质数的循环例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">        <span class="keyword">if</span> n % x == <span class="number">0</span>:</span><br><span class="line">            print(n, <span class="string">'等于'</span>, x, <span class="string">'*'</span>, n//x)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 循环中没有找到元素</span></span><br><span class="line">        print(n, <span class="string">' 是质数'</span>)</span><br></pre></td></tr></table></figure><p>执行以上脚本输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>  是质数</span><br><span class="line"><span class="number">3</span>  是质数</span><br><span class="line"><span class="number">4</span> 等于 <span class="number">2</span> * <span class="number">2</span></span><br><span class="line"><span class="number">5</span>  是质数</span><br><span class="line"><span class="number">6</span> 等于 <span class="number">2</span> * <span class="number">3</span></span><br><span class="line"><span class="number">7</span>  是质数</span><br><span class="line"><span class="number">8</span> 等于 <span class="number">2</span> * <span class="number">4</span></span><br><span class="line"><span class="number">9</span> 等于 <span class="number">3</span> * <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="pass-语句">pass 语句</h2><p>Python pass是空语句，是为了保持程序结构的完整性。</p><p>pass 不做任何事情，一般用做占位语句Python3 迭代器与生成器</p><h2 id="迭代器">迭代器</h2><p>迭代是Python最强大的功能之一，是访问集合元素的一种方式。</p><p>迭代器是一个可以记住遍历的位置的对象。</p><p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p><p>迭代器有两个基本的方法：<strong>iter()</strong> 和 <strong>next()</strong>。</p><p>字符串，列表或元组对象都可用于创建迭代器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;list=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it = iter(list)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> (next(it))   <span class="comment"># 输出迭代器的下一个元素</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> (next(it))</span><br><span class="line"><span class="number">2</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>迭代器对象可以使用常规for语句进行遍历：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">list=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = iter(list)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> it:</span><br><span class="line">    <span class="keyword">print</span> (x, end=<span class="string">" "</span>)</span><br></pre></td></tr></table></figure><p>执行以上程序，输出结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>也可以使用 next() 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> sys         <span class="comment"># 引入 sys 模块</span></span><br><span class="line"> </span><br><span class="line">list=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = iter(list)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">print</span> (next(it))</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure><p>执行以上程序，输出结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="生成器">生成器</h2><p>在 Python 中，使用了 yield 的函数被称为生成器（generator）。</p><p>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。</p><p>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。</p><p>调用一个生成器函数，返回的是一个迭代器对象。</p><p>以下实例使用 yield 实现斐波那契数列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span> <span class="comment"># 生成器函数 - 斐波那契</span></span><br><span class="line">    a, b, counter = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">if</span> (counter &gt; n): </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">f = fibonacci(<span class="number">10</span>) <span class="comment"># f 是一个迭代器，由生成器返回生成</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">print</span> (next(f), end=<span class="string">" "</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure><p>执行以上程序，输出结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span></span><br></pre></td></tr></table></figure><h1>Python3 函数</h1><p>你可以定义一个由自己想要功能的函数，以下是简单的规则：</p><ul><li><p>函数代码块以 <strong>def</strong> 关键词开头，后接函数标识符名称和圆括号 <strong>()</strong>。</p></li><li><p>任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。</p></li><li><p>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</p></li><li><p>函数内容以冒号起始，并且缩进。</p></li><li><p><strong>return [表达式]</strong> 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。</p></li><li><p>Python 定义函数使用 def 关键字，一般格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名（参数列表）:</span></span><br><span class="line">    函数体</span><br></pre></td></tr></table></figure></li></ul><h2 id="参数传递">参数传递</h2><p><strong>当你将对象作为参数传递给函数时，新的局域变量创建了对原始对象的引用，而不是复制</strong>。如果在函数里绑定一个新对象到一个变量，这个变动不会反映到上一层。因此可以改变可变参数的内容。假设有以下函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">append_element</span><span class="params">(some_list, element)</span>:</span></span><br><span class="line">    some_list.append(element)</span><br></pre></td></tr></table></figure><p>然后有：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">27</span>]: data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: append_element(data, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: data</span><br><span class="line">Out[<span class="number">29</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>在 python 中，类型属于对象，变量是没有类型的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">a=<span class="string">"Runoob"</span></span><br></pre></td></tr></table></figure><p>以上代码中，<strong>[1,2,3]</strong> 是 List 类型，<strong>“Runoob”</strong> 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是指向 List 类型对象，也可以是指向 String 类型对象。</p><h2 id="鸭子类型">鸭子类型</h2><p>经常地，你可能不关心对象的类型，只关心对象是否有某些方法或用途。这通常被称为“鸭子类型”，来自“走起来像鸭子、叫起来像鸭子，那么它就是鸭子”的说法。例如，你可以通过验证一个对象是否遵循迭代协议，判断它是可迭代的。对于许多对象，这意味着它有一个<code>__iter__</code>魔术方法，其它更好的判断方法是使用<code>iter</code>函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isiterable</span><span class="params">(obj)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        iter(obj)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">except</span> TypeError: <span class="comment"># not iterable</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>这个函数会返回字符串以及大多数Python集合类型为<code>True</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">29</span>]: isiterable(<span class="string">'a string'</span>)</span><br><span class="line">Out[<span class="number">29</span>]: <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: isiterable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">Out[<span class="number">30</span>]: <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: isiterable(<span class="number">5</span>)</span><br><span class="line">Out[<span class="number">31</span>]: <span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>我总是用这个功能编写可以接受多种输入类型的函数。常见的例子是编写一个函数可以接受任意类型的序列（list、tuple、ndarray）或是迭代器。你可先检验对象是否是列表（或是NUmPy数组），如果不是的话，将其转变成列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, list) <span class="keyword">and</span> isiterable(x):</span><br><span class="line">    x = list(x)</span><br></pre></td></tr></table></figure><h2 id="重点⚠-可更改-mutable-与不可更改-immutable-对象">(重点⚠️)可更改(mutable)与不可更改(immutable)对象</h2><p>👇</p><p>在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。</p><ul><li>**不可变类型：**变量赋值 <strong>a=5</strong> 后再赋值 <strong>a=10</strong>，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。</li><li>**可变类型：**变量赋值 <strong>la=[1,2,3,4]</strong> 后再赋值 <strong>la[2]=5</strong> 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。</li></ul><p>python 函数的参数传递：</p><ul><li>**不可变类型：**类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。</li><li>**可变类型：**类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响</li></ul><p><strong>python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。</strong></p><h3 id="python-传不可变对象实例">python 传不可变对象实例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ChangeInt</span><span class="params">( a )</span>:</span></span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">ChangeInt(b)</span><br><span class="line">print( b ) <span class="comment"># 结果是 2</span></span><br></pre></td></tr></table></figure><p>实例中有 int 对象 2，指向它的变量是 b，在传递给 ChangeInt 函数时，按传值的方式复制了变量 b，a 和 b 都指向了同一个 Int 对象，在 a=10 时，则新生成一个 int 值对象 10，并让 a 指向它。</p><h3 id="传可变对象实例">传可变对象实例</h3><p>可变对象在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">changeme</span><span class="params">( mylist )</span>:</span></span><br><span class="line">   <span class="string">"修改传入的列表"</span></span><br><span class="line">   mylist.append([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line">   <span class="keyword">print</span> (<span class="string">"函数内取值: "</span>, mylist)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用changeme函数</span></span><br><span class="line">mylist = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>];</span><br><span class="line">changeme( mylist );</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"函数外取值: "</span>, mylist)</span><br></pre></td></tr></table></figure><p>传入函数的和在末尾添加新内容的对象用的是同一个引用。故输出结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数内取值:  [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">函数外取值:  [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]]</span><br></pre></td></tr></table></figure><h2 id="参数">参数</h2><p>以下是调用函数时可使用的正式参数类型：</p><ul><li><p>必需参数</p></li><li><p>关键字参数</p></li><li><p>默认参数</p></li><li><p>不定长参数</p></li><li><h3 id="关键字参数">关键字参数</h3><p>关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。</p><p>使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。</p><p>以下实例在函数 printme() 调用时使用参数名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printme</span><span class="params">( str )</span>:</span></span><br><span class="line">   <span class="string">"打印任何传入的字符串"</span></span><br><span class="line">   <span class="keyword">print</span> (str);</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printme函数</span></span><br><span class="line">printme( str = <span class="string">"菜鸟教程"</span>);</span><br></pre></td></tr></table></figure></li></ul><p>以下实例中演示了函数参数的使用不需要使用指定顺序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span><span class="params">( name, age )</span>:</span></span><br><span class="line">   <span class="string">"打印任何传入的字符串"</span></span><br><span class="line">   <span class="keyword">print</span> (<span class="string">"名字: "</span>, name);</span><br><span class="line">   <span class="keyword">print</span> (<span class="string">"年龄: "</span>, age);</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printinfo函数</span></span><br><span class="line">printinfo( age=<span class="number">50</span>, name=<span class="string">"runoob"</span> );</span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">名字:  runoob</span><br><span class="line">年龄:  <span class="number">50</span></span><br></pre></td></tr></table></figure><h3 id="不定长参数">不定长参数</h3><p>你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述2种参数不同，声明时不会命名。基本语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">functionname</span><span class="params">([formal_args,] *var_args_tuple )</span>:</span></span><br><span class="line">   <span class="string">"函数_文档字符串"</span></span><br><span class="line">   function_suite</span><br><span class="line">   <span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure><p>加了星号（*）的变量名会存放所有未命名的变量参数。如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。如下实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span><span class="params">( arg1, *vartuple )</span>:</span></span><br><span class="line">   <span class="string">"打印任何传入的参数"</span></span><br><span class="line">   <span class="keyword">print</span> (<span class="string">"输出: "</span>)</span><br><span class="line">   <span class="keyword">print</span> (arg1)</span><br><span class="line">   <span class="keyword">for</span> var <span class="keyword">in</span> vartuple:</span><br><span class="line">      <span class="keyword">print</span> (var)</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用printinfo 函数</span></span><br><span class="line">printinfo( <span class="number">10</span> );</span><br><span class="line">printinfo( <span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span> );</span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输出:</span><br><span class="line"><span class="number">10</span></span><br><span class="line">输出:</span><br><span class="line"><span class="number">70</span></span><br><span class="line"><span class="number">60</span></span><br><span class="line"><span class="number">50</span></span><br></pre></td></tr></table></figure><h2 id="变量作用域">变量作用域</h2><p>Python 中，程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。</p><p>变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。Python的作用域一共有4种，分别是：</p><ul><li>L （Local） 局部作用域</li><li>E （Enclosing） 闭包函数外的函数中</li><li>G （Global） 全局作用域</li><li>B （Built-in） 内建作用域</li></ul><p>以 L –&gt; E –&gt; G –&gt;B 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内建中找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = int(<span class="number">2.9</span>)  <span class="comment"># 内建作用域</span></span><br><span class="line"> </span><br><span class="line">g_count = <span class="number">0</span>  <span class="comment"># 全局作用域</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></span><br><span class="line">    o_count = <span class="number">1</span>  <span class="comment"># 闭包函数外的函数中</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        i_count = <span class="number">2</span>  <span class="comment"># 局部作用域</span></span><br></pre></td></tr></table></figure><p>Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 if/elif/else/、try/except、for/while等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问，如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> <span class="keyword">True</span>:</span><br><span class="line"><span class="meta">... </span> msg = <span class="string">'I am from Runoob'</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>msg</span><br><span class="line"><span class="string">'I am from Runoob'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>实例中 msg 变量定义在 if 语句块中，但外部还是可以访问的。</p><p>如果将 msg 定义在函数中，则它就是局部变量，外部不能访问：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    msg_inner = <span class="string">'I am from Runoob'</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>msg_inner</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">'msg_inner'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>从报错的信息上看，说明了 msg_inner 未定义，无法使用，因为它是局部变量，只有在函数内可以使用。</p><h3 id="全局变量和局部变量">全局变量和局部变量</h3><p>定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。</p><p>局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。如下实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line">total = <span class="number">0</span>; <span class="comment"># 这是一个全局变量</span></span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">( arg1, arg2 )</span>:</span></span><br><span class="line">    <span class="comment">#返回2个参数的和."</span></span><br><span class="line">    total = arg1 + arg2; <span class="comment"># total在这里是局部变量.</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"函数内是局部变量 : "</span>, total)</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line"></span><br><span class="line"><span class="comment">#调用sum函数</span></span><br><span class="line">sum( <span class="number">10</span>, <span class="number">20</span> );</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"函数外是全局变量 : "</span>, total)</span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数内是局部变量 :  <span class="number">30</span></span><br><span class="line">函数外是全局变量 :  <span class="number">0</span></span><br></pre></td></tr></table></figure><p>如果要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量则需要 nonlocal 关键字了，如下实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></span><br><span class="line">    num = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> num   <span class="comment"># nonlocal关键字声明</span></span><br><span class="line">        num = <span class="number">100</span></span><br><span class="line">        print(num)</span><br><span class="line">    inner()</span><br><span class="line">    print(num)</span><br><span class="line">outer()</span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure><p>另外有一种特殊情况，假设下面这段代码被运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    a = a + <span class="number">1</span></span><br><span class="line">    print(a)</span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>以上程序执行，报错信息如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"test.py"</span>, line <span class="number">7</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    test()</span><br><span class="line">  File <span class="string">"test.py"</span>, line <span class="number">5</span>, <span class="keyword">in</span> test</span><br><span class="line">    a = a + <span class="number">1</span></span><br><span class="line">UnboundLocalError: local variable <span class="string">'a'</span> referenced before assignment</span><br></pre></td></tr></table></figure><p>错误信息为局部作用域引用错误，因为 test 函数中的 a 使用的是局部，未定义，无法修改。</p><h1>Python标准库：内置函数</h1><h2 id="any-iterable">any(iterable)</h2><p>如果可迭代的对象的所有元素中只要有一个元素为True就返回True，否则返回False。或者可迭代对象为空，也返回False。<strong>这个函数主要用来判断列表、元组、字典等对象是否有元素为True，提高计算速度</strong>，与之等效的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">any</span><span class="params">(iterable)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> iterable:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> element:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>例子：</p><p><strong>[python]</strong> <a href="https://blog.csdn.net/caimouse/article/details/40652697#" target="_blank" rel="noopener">view plain</a> <a href="https://blog.csdn.net/caimouse/article/details/40652697#" target="_blank" rel="noopener">copy</a></p><ol><li>#any()函数</li><li>a = []</li><li>b = {}</li><li>c = (1, 3, 4)</li><li>d = (None, 1, 3)</li><li></li><li>print(‘a:’, any(a), ‘b:’, any(b), ‘c:’, any©, ‘d:’, any(d))</li></ol><p>输出结果如下：</p><p>a: False b: False c: True d: True</p><h2 id="python-bytes和str两种类型转换的函数encode-decode">python bytes和str两种类型转换的函数<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431664106267f12e9bef7ee14cf6a8776a479bdec9b9000" target="_blank" rel="noopener">encode(),decode()</a></h2><ul><li>str通过encode()方法可以编码为指定的bytes</li><li>反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法：</li></ul><h1>网络编程</h1><p>socket.send（bytes [，flags]）</p><p>socket.recv（bufsize [，flags]）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;python3基础语法：&lt;/h1&gt;
&lt;h2 id=&quot;标识符-当时学c语言时也没注意-😢&quot;&gt;标识符（当时学c语言时也没注意）😢&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;第一个字符必须是字母表中&lt;strong&gt;字母&lt;/strong&gt;或下__划线 ___ 。&lt;/li&gt;
&lt;li&gt;标识符的
      
    
    </summary>
    
    
      <category term="Python3" scheme="http://WSCZou.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Splash使用</title>
    <link href="http://WSCZou.com/2018/04/10/Splash%E4%BD%BF%E7%94%A8/"/>
    <id>http://WSCZou.com/2018/04/10/Splash使用/</id>
    <published>2018-04-10T03:10:18.000Z</published>
    <updated>2018-04-12T09:37:36.625Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么有splash">为什么有splash</h2><p>为了更加有效的制作网页爬虫,由于目前很多的网页通过javascript模式进行交互,简单的爬取网页模式无法胜任javascript页面的生成和ajax网页的爬取,同时通过分析连接请求的方式来落实局部连接数据请求,相对比较复杂,尤其是对带有特定时间戳算法的页面,分析难度较大,效率不高。而通过调用浏览器模拟页面动作模式,需要使用浏览器,无法实现异步和大规模爬取需求。鉴于上述理由Splash也就有了用武之地。一个页面渲染服务器,返回渲染后的页面,便于爬取,便于规模应用</p><h2 id="splash-lua脚本">splash lua脚本</h2><p>Splash是通过Lua脚本来控制了页面的加载过程的，加载过程完全模拟浏览器，最后可返回各种格式的结果，如网页源码和截图等。</p><h2 id="splash对象属性">Splash对象属性</h2><h3 id="1args">1<code>args</code></h3><p>该属性可以获取加载时配置的参数，比如URL</p><h3 id="2-js-enabled">2.<code>js_enabled</code></h3><p>这个属性是Splash的JavaScript执行开关，可以将其配置为<code>true</code>或<code>false</code>来控制是否执行JavaScript代码，默认为<code>true</code></p><h3 id="3-resource-timeout">3.<code>resource_timeout</code></h3><p>此属性可以设置加载的超时时间，单位是秒。如果设置为0或<code>nil</code>（类似Python中的<code>None</code>），代表不检测超时</p><h3 id="4-images-enabled">4.<code>images_enabled</code></h3><p>此属性可以设置图片是否加载，默认情况下是加载的。禁用该属性后，可以节省网络流量并提高网页加载速度。但是需要注意的是，禁用图片加载可能会影响JavaScript渲染。因为禁用图片之后，它的外层DOM节点的高度会受影响，进而影响DOM节点的位置。因此，如果JavaScript对图片节点有操作的话，其执行就会受到影响。另外值得注意的是，Splash使用了缓存。如果一开始加载出来了网页图片，然后禁用了图片加载，再重新加载页面，之前加载好的图片可能还会显示出来，这时直接重启Splash即可。</p><h3 id="5-plugins-enabled">5.<code>plugins_enabled</code></h3><p>此属性可以控制浏览器插件（如Flash插件）是否开启。默认情况下，此属性是<code>false</code>，表示不开启。</p><h3 id="6-scroll-position">6.<code>scroll_position</code></h3><p>通过设置此属性，我们可以控制页面上下或左右滚动。</p><h2 id="splash对象的方法">Splash对象的方法</h2><h3 id="1-go">1.<code>go()</code></h3><p>该方法用来请求某个链接，而且它可以模拟GET和POST请求，同时支持传入请求头、表单等数据</p><h3 id="2-wait">2.<code>wait()</code></h3><p>此方法可以控制页面的等待时间</p><h3 id="3-jsfunc">3.<code>jsfunc()</code></h3><p>此方法可以直接调用JavaScript定义的方法，但是所调用的方法需要用双中括号包围，这相当于实现了JavaScript方法到Lua脚本的转换。</p><h3 id="4-evaljs">4.<code>evaljs()</code></h3><p>此方法可以执行JavaScript代码并返回最后一条JavaScript语句的返回结果</p><h3 id="5-runjs">5.<code>runjs()</code></h3><p>此方法可以执行JavaScript代码，它与<code>evaljs()</code>的功能类似，但是更偏向于执行某些动作或声明某些方法</p><h3 id="6-autoload">6.<code>autoload()</code></h3><p>此方法可以设置每个页面访问时自动加载的对象.但是此方法只负责加载JavaScript代码或库，不执行任何操作。如果要执行操作，可以调用<code>evaljs()</code>或<code>runjs()</code>方法。</p><h3 id="7-call-later">7.<code>call_later()</code></h3><p>此方法可以通过设置定时任务和延迟时间来实现任务延时执行，并且可以在执行前通过<code>cancel()</code>方法重新执行定时任务。</p><h3 id="8-http-get">8.<code>http_get()</code></h3><p>此方法可以模拟发送HTTP的GET请求</p><h3 id="9-http-post">9.<code>http_post()</code></h3><p>和<code>http_get()</code>方法类似，此方法用来模拟发送POST请求，不过多了一个参数<code>body</code></p><h3 id="10-set-content">10.<code>set_content()</code></h3><p>此方法用来设置页面的内容</p><h3 id="11-html">11.<code>html()</code></h3><p>此方法用来获取网页的源代码，它是非常简单又常用的方法</p><h3 id="12-png">12.<code>png()</code></h3><p>此方法用来获取PNG格式的网页截图</p><h3 id="13-jpeg">13.<code>jpeg()</code></h3><p>此方法用来获取JPEG格式的网页截图</p><h3 id="14-har">14.<code>har()</code></h3><p>此方法用来获取页面加载过程描述</p><h3 id="15-url">15.<code>url()</code></h3><p>此方法可以获取当前正在访问的URL</p><h3 id="16-get-cookies">16.<code>get_cookies()</code></h3><p>此方法可以获取当前页面的Cookies</p><h3 id="17-add-cookie">17.<code>add_cookie()</code></h3><p>此方法可以为当前页面添加Cookie</p><h3 id="18-clear-cookies">18.<code>clear_cookies()</code></h3><p>此方法可以清除所有的Cookies</p><h3 id="19-get-viewport-size">19.<code>get_viewport_size()</code></h3><p>此方法可以获取当前浏览器页面的大小，即宽高</p><h3 id="20-set-viewport-size">20.<code>set_viewport_size()</code></h3><p>此方法可以设置当前浏览器页面的大小，即宽高</p><h3 id="21-set-viewport-full">21.<code>set_viewport_full()</code></h3><p>此方法可以设置浏览器全屏显示</p><h3 id="22-set-user-agent">22.<code>set_user_agent()</code></h3><p>此方法可以设置浏览器的<code>User-Agent</code></p><h3 id="23-set-custom-headers">23.<code>set_custom_headers()</code></h3><p>此方法可以设置请求头</p><h3 id="24-select">24.<code>select()</code></h3><p>该方法可以选中符合条件的第一个节点，如果有多个节点符合条件，则只会返回一个，其参数是CSS选择器。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">(splash)</span></span></span><br><span class="line">  splash:go(<span class="string">"https://www.baidu.com/"</span>)</span><br><span class="line">  <span class="built_in">input</span> = splash:<span class="built_in">select</span>(<span class="string">"#kw"</span>)</span><br><span class="line">  <span class="built_in">input</span>:send_text(<span class="string">'Splash'</span>)</span><br><span class="line">  splash:wait(<span class="number">3</span>)</span><br><span class="line">  <span class="keyword">return</span> splash:png()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里我们首先访问了百度，然后选中了搜索框，随后调用了<code>send_text()</code>方法填写了文本，然后返回网页截图我们成功在输入框中输入了Splash</p><h3 id="25-select-all">25.<code>select_all()</code></h3><p>此方法可以选中所有符合条件的节点，其参数是CSS选择器</p><h3 id="26-mouse-click">26.<code>mouse_click()</code></h3><p>此方法可以模拟鼠标点击操作，传入的参数为坐标值<code>x</code>和<code>y</code>。此外，也可以直接选中某个节点，然后调用此方法</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">(splash)</span></span></span><br><span class="line">  splash:go(<span class="string">"https://www.baidu.com/"</span>)</span><br><span class="line">  <span class="built_in">input</span> = splash:<span class="built_in">select</span>(<span class="string">"#kw"</span>)</span><br><span class="line">  <span class="built_in">input</span>:send_text(<span class="string">'Splash'</span>)</span><br><span class="line">  submit = splash:<span class="built_in">select</span>(<span class="string">'#su'</span>)</span><br><span class="line">  submit:mouse_click()</span><br><span class="line">  splash:wait(<span class="number">3</span>)</span><br><span class="line">  <span class="keyword">return</span> splash:png()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里我们首先选中页面的输入框，输入了文本，然后选中“提交”按钮，调用了<code>mouse_click()</code>方法提交查询，然后页面等待三秒，返回截图，这里我们成功获取了查询后的页面内容，模拟了百度搜索操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么有splash&quot;&gt;为什么有splash&lt;/h2&gt;
&lt;p&gt;为了更加有效的制作网页爬虫,由于目前很多的网页通过javascript模式进行交互,简单的爬取网页模式无法胜任javascript页面的生成和ajax网页的爬取,同时通过分析连接请求的方式来落实局部连接
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://WSCZou.com/2018/04/09/hello-world/"/>
    <id>http://WSCZou.com/2018/04/09/hello-world/</id>
    <published>2018-04-09T02:12:10.670Z</published>
    <updated>2018-04-09T02:12:10.670Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
